diff -Nur mantis-0.19.4.orig/bug_report_mail.php mantis-0.19.4/bug_report_mail.php
--- mantis-0.19.4.orig/bug_report_mail.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/bug_report_mail.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,39 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	# This page receives an E-Mail via POP3 and generates an Report
+	header("Content-type: text/plain");
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'string_api.php' );
+	require_once( $t_core_path . 'bug_api.php' );
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$t_mailaccounts = mail_get_accounts();
+
+	foreach ($t_mailaccounts as $t_mailaccount) {
+		if ( config_get( 'mail_debug' ) ) {
+			print_r($t_mailaccounts);
+		}
+		$t_mails = mail_get_all_mails($t_mailaccount);
+		foreach ($t_mails as $t_mail)
+		{
+			if ( config_get( 'mail_debug' ) ) {
+				print_r($t_mail);
+			}
+			$GLOBALS['g_cache_current_user_id'] = mail_get_user( $t_mail['From'] );
+			mail_add_bug($t_mail, $t_mailaccount);
+		}
+	}
+?>
+
diff -Nur mantis-0.19.4.orig/config_defaults_inc.php mantis-0.19.4/config_defaults_inc.php
--- mantis-0.19.4.orig/config_defaults_inc.php	2005-12-13 12:27:54.000000000 +0100
+++ mantis-0.19.4/config_defaults_inc.php	2005-12-23 13:56:09.000000000 +0100
@@ -1474,4 +1474,37 @@
 	# NOTE: These are meaningless under Windows! Just ignore them!
 	$g_dot_tool							= '/usr/bin/dot';
 	$g_neato_tool						= '/usr/bin/neato';
-?>
\ Kein Zeilenumbruch am Dateiende.
+
+	######################
+	# Mail Reporting
+	######################
+
+	# --- mail reporting settings -----
+	# This tells Mantis to report all the Mail with only one account
+	$g_mail_use_reporter	= ON;
+
+	# The account's name for mail reporting
+	# Also used for fallback if a user is not found in database
+	$g_mail_reporter	= 'Mail';
+
+	# Signup new users automatically (possible security risk!)
+	# Default is OFF, ignored if mail_use_reporter is ON
+	$g_mail_auto_signup	= OFF;
+
+	# Write complete mail into the "Additional Information"
+	$g_mail_additional	= OFF;
+
+	# Write sender of the message into the bug report
+	$g_mail_save_from	= OFF;
+
+	# Parse MIME mails (may require a lot of memory)
+	$g_mail_parse_mime	= OFF;
+
+	# How many mails should be fetched at the same time
+	# If big mails with attachments should be received, specify only one
+	$g_mail_fetch_max	= 1;
+
+	# Signup new users automatically (possible security risk!)
+	# Default is OFF, ignored if mail_use_reporter is ON
+	$g_mail_debug		= OFF;
+?>
diff -Nur mantis-0.19.4.orig/core/category_api.php mantis-0.19.4/core/category_api.php
--- mantis-0.19.4.orig/core/category_api.php	2004-04-08 20:04:53.000000000 +0200
+++ mantis-0.19.4/core/category_api.php	2005-12-23 13:56:09.000000000 +0100
@@ -186,7 +186,7 @@
 
 		$t_project_category_table = config_get( 'mantis_project_category_table' );
 
-		$query = "SELECT category, user_id
+		$query = "SELECT category, user_id, pop3_host, pop3_user, pop3_pass
 				FROM $t_project_category_table
 				WHERE project_id='$c_project_id' AND
 					category='$c_category'";
@@ -206,7 +206,7 @@
 
 		$t_project_category_table = config_get( 'mantis_project_category_table' );
 
-		$query = "SELECT category, user_id
+		$query = "SELECT category, user_id, pop3_host, pop3_user, pop3_pass
 				FROM $t_project_category_table
 				WHERE project_id='$c_project_id'
 				ORDER BY category";
@@ -221,4 +221,4 @@
 
 		return $rows;
 	}
-?>
\ Kein Zeilenumbruch am Dateiende.
+?>
diff -Nur mantis-0.19.4.orig/core/file_api.php mantis-0.19.4/core/file_api.php
--- mantis-0.19.4.orig/core/file_api.php	2005-11-21 03:45:53.000000000 +0100
+++ mantis-0.19.4/core/file_api.php	2005-12-23 13:56:09.000000000 +0100
@@ -509,7 +509,7 @@
 			trigger_error( ERROR_DUPLICATE_FILE, ERROR );
 		}  
 
-		if ( is_uploaded_file( $p_tmp_file ) ) {
+		if ( is_uploaded_file( $p_tmp_file )  || $GLOBALS['_mail_file_']  == $p_file_name ) {
 			if ( 'bug' == $p_table ) {
 				$t_project_id	= bug_get_field( $p_bug_id, 'project_id' );
 				$t_bug_id		= bug_format_id( $p_bug_id );
diff -Nur mantis-0.19.4.orig/core/mail_api.php mantis-0.19.4/core/mail_api.php
--- mantis-0.19.4.orig/core/mail_api.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/core/mail_api.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,443 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	$t_core_dir = dirname( __FILE__ ).DIRECTORY_SEPARATOR;
+
+	require_once( $t_core_dir . 'bug_api.php' );
+	require_once( $t_core_dir . 'bugnote_api.php' );
+	require_once( $t_core_dir . 'user_api.php' );
+	require_once( $t_core_dir . 'project_api.php' );
+	require_once( $t_core_dir . 'file_api.php' );
+
+	# This page receives an E-Mail via POP3 and generates an Report
+
+	require_once( 'Net/POP3.php' );
+	require_once( 'Mail/mimeDecode.php' );
+
+	# --------------------
+	# Return mail account data for the specified project
+	function mail_get_account_data( $p_project_id ) {
+		$v_project_id = db_prepare_int( $p_project_id );
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "SELECT pop3_host, pop3_user, pop3_pass, pop3_categories
+				FROM $t_project_table 
+				WHERE id='$v_project_id'";
+
+		$result = db_query( $query );
+
+		return db_fetch_array( $result );
+	}
+
+	# --------------------
+	# Update the mail account data for a project
+	function mail_update( $p_project_id, $p_pop3_host, $p_pop3_user, $p_pop3_pass ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_pop3_host	= db_prepare_string( $p_pop3_host );
+		$v_pop3_user	= db_prepare_string( $p_pop3_user );
+		$v_pop3_pass	= db_prepare_string( $p_pop3_pass );
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "UPDATE $t_project_table 
+			 	SET pop3_host='$v_pop3_host',
+				pop3_user='$v_pop3_user',
+				pop3_pass='$v_pop3_pass'
+				WHERE id='$v_project_id'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Removes the mail account data from a project
+	function mail_delete( $p_project_id ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "UPDATE $t_project_table 
+				SET pop3_host=NULL,
+				pop3_user=NULL,
+				pop3_pass=NULL
+				WHERE id='$v_project_id'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Activate the 'Mail per Category' feature for a project
+	function mail_categories( $p_project_id, $p_active ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+
+		if ($p_active == 'On') {
+			$v_active = 1;
+		} else {
+			$v_active = 0;
+		}
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "UPDATE $t_project_table 
+				SET pop3_categories='$v_active'
+				WHERE id='$v_project_id'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Return mail account data for the specified project and category
+	function mail_category_get_account_data( $p_project_id, $p_category ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_category	= db_prepare_string( $p_category );
+
+		$t_project_category_table = config_get( 'mantis_project_category_table' );
+
+		$query = "SELECT pop3_host, pop3_user, pop3_pass
+				FROM $t_project_category_table 
+				WHERE project_id='$v_project_id' AND category='$v_category'";
+
+		$result = db_query( $query );
+
+		return db_fetch_array( $result );
+	}
+
+	# --------------------
+	# Update the mail account data for a category
+	function mail_category_update( $p_project_id, $p_category, $p_pop3_host, $p_pop3_user, $p_pop3_pass ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_category	= db_prepare_string( $p_category );
+		$v_pop3_host	= db_prepare_string( $p_pop3_host );
+		$v_pop3_user	= db_prepare_string( $p_pop3_user );
+		$v_pop3_pass	= db_prepare_string( $p_pop3_pass );
+
+		$t_project_category_table = config_get( 'mantis_project_category_table' );
+
+		$query = "UPDATE $t_project_category_table 
+			 	SET pop3_host='$v_pop3_host',
+				pop3_user='$v_pop3_user',
+				pop3_pass='$v_pop3_pass'
+				WHERE project_id='$v_project_id' AND category='$v_category'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Removes the mail account data for a category
+	function mail_category_delete( $p_project_id, $p_category ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_category	= db_prepare_string( $p_category );
+		
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$t_project_category_table = config_get( 'mantis_project_category_table' );
+
+		$query = "UPDATE $t_project_category_table 
+			 	SET pop3_host=NULL,
+				pop3_user=NULL,
+				pop3_pass=NULL
+				WHERE project_id='$v_project_id' AND category='$v_category'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# return all mailaccounts
+	#  return an empty array if there are no
+	function mail_get_accounts() {
+		$v_accounts = array();
+		$t_projects = mail_project_get_all_rows();
+
+		foreach ($t_projects as $t_project) {
+			if ($t_project['pop3_categories']) {
+				$v_categories = mail_categories_get_all_rows( $t_project['id'] );
+				$v_accounts = array_merge($v_accounts, $v_categories);
+			} else {
+				array_push($v_accounts, $t_project);
+			}
+		}
+
+		return $v_accounts;
+	}
+
+	# --------------------
+	# return all projects with valid data for mail access
+	#  return an empty array if there are no such projects
+	function mail_project_get_all_rows() {
+		$v_projects = array();
+		$t_projects = project_get_all_rows();
+
+		foreach ($t_projects as $t_project) {
+			if ($t_project['pop3_host'] || $t_project['pop3_categories']) {
+				array_push($v_projects, $t_project);
+			}
+		}
+
+		return $v_projects;
+	}
+
+	# --------------------
+	# return all categories from a project with valid data for mail access
+	#  return an empty array if there are no such categories
+	function mail_categories_get_all_rows( $p_project_id ) {
+		$v_categories = array();
+		$t_categories = category_get_all_rows( $p_project_id );
+
+		foreach ($t_categories as $t_category) {
+			if ($t_category['pop3_host']) {
+				$t_category['id'] = $p_project_id;
+				array_push($v_categories, $t_category);
+			}
+		}
+
+		return $v_categories;
+	}
+
+	# --------------------
+	# return all mails for an account
+	#  return an empty array if there are no new mails
+	function mail_get_all_mails( $p_account ) {
+		$t_mail_parse_mime	= config_get( 'mail_parse_mime' );
+		$t_mail_fetch_max	= config_get( 'mail_fetch_max' );
+		$t_mail_additional	= config_get( 'mail_additional' );
+		
+		$v_mails = array();
+		$t_pop3 = &new Net_POP3();
+		$t_pop3_host = $p_account['pop3_host'];
+		$t_pop3_user = $p_account['pop3_user'];
+		$t_pop3_password = $p_account['pop3_pass'];
+		$t_pop3->connect($t_pop3_host, 110);
+		$t_pop3->login($t_pop3_user, $t_pop3_password);
+
+		if ( 0 == $t_pop3->numMsg() ) {
+			return $v_mails;
+		}
+		for ($i = 1; $i <= $t_mail_fetch_max; $i++) {
+			$t_headers = $t_pop3->getParsedHeaders($i);
+			$t_msg = $t_pop3->getMsg($i);
+			if (true == $t_mail_parse_mime &&
+				true == isset( $t_headers['MIME-Version'] ) &&
+				'multipart' == strtolower ( substr( $t_headers['Content-Type'], 0, 9 ) ) ) {
+				$t_mail = mail_parse_content( $t_msg );
+			} else {
+				$t_mail = $t_headers;
+				$t_mail['X-Mantis-Body'] = $t_pop3->getBody($i);
+			}
+
+			if (true == $t_mail_additional) {
+				$t_mail['X-Mantis-Complete'] = $t_msg;
+			}
+
+			array_push($v_mails, $t_mail);
+			$t_pop3->deleteMsg($i);
+		}
+
+		$t_pop3->disconnect();
+		return $v_mails;
+	}
+
+	# --------------------
+	# return the mail parsed for Mantis
+	function mail_parse_content ( $p_mail ) {
+		$v_mail = array ();
+		$t_decoder = new Mail_mimeDecode($p_mail);
+		$t_params['include_bodies'] = true;
+		$t_params['decode_bodies']  = true;
+		$t_params['decode_headers'] = true;
+		$t_structure = $t_decoder->decode($t_params);
+		$v_mail['To'] = $t_structure->headers['to'];
+		$v_mail['From'] = $t_structure->headers['from'];
+		$v_mail['Subject'] = $t_structure->headers['subject'];
+		if (is_array($t_structure->parts)) {
+			$t_parts = mail_parse_parts( $t_structure->parts );
+		} else {
+                	$t_parts = array ( mail_parse_part( $t_structure ) );
+		}
+		if (strtolower($t_parts[0]['Content-Type']) == 'text/plain' ||
+			strtolower($t_parts[0]['Content-Type']) == 'text/html' ) {
+			$t_body['Body'] = $t_parts[0]['Body'];
+		} else {
+			$t_body['Body'] = "It seems, there is no text... :-o";
+		}
+		$v_mail['X-Mantis-Parts'] = $t_parts;
+		$v_mail['X-Mantis-Body'] = $t_body['Body'];
+
+		return $v_mail;
+	}
+
+	# --------------------
+	# return the parsed parts from the mail
+	function mail_parse_parts ( $p_parts ) {
+		$v_parts = array ();
+		foreach ( $p_parts as $t_part ) {
+			array_push($v_parts, mail_parse_part( $t_part ));
+		}
+
+		return $v_parts;
+	}
+
+	# --------------------
+	# return one parsed part
+	function mail_parse_part ( $p_part ) {
+		$v_part = array ();
+		$v_part['Content-Type'] = $p_part->ctype_primary."/".$p_part->ctype_secondary;
+		$v_part['Name'] = $p_part->ctype_parameters['name'];
+		$v_part['Body'] = $p_part->body;
+
+		return $v_part;
+	}
+
+	# --------------------
+	# return the mailadress from the mail's 'From'
+	function mail_parse_address ( $p_mailaddress ) {
+		if (preg_match("/<(.*?)>/", $p_mailaddress, $matches)) {
+			$v_mailaddress = $matches[1];
+		}
+
+		return $v_mailaddress;
+	}
+
+	# --------------------
+	# return the a valid username from an email address
+	function mail_user_name_from_address ( $p_mailaddress ) {
+		return preg_replace("/[@\.-]/", '_', $p_mailaddress);
+	}
+
+	# --------------------
+	# return true if there is a valid mantis bug referernce in subject
+	function mail_is_a_bugnote ( $p_mail_subject ) {
+		return preg_match("/\[([A-Za-z0-9-_\. ]*\s[0-9]{7})\]/", $p_mail_subject);
+	}
+
+	# --------------------
+	# return the bug's id from the subject
+	function mail_get_bug_id_from_subject ( $p_mail_subject ) {
+		preg_match("/\[([A-Za-z0-9-_\. ]*\s([0-9]{7}?))\]/", $p_mail_subject, $v_matches);
+
+		return $v_matches[2];
+	}
+
+	# --------------------
+	# return the user id for the mail reporting user
+	function mail_get_user ($p_mailaddress) {
+		$t_mail_use_reporter	= config_get( 'mail_use_reporter' );
+		$t_mail_auto_signup	= config_get( 'mail_auto_signup' );
+		$t_mail_reporter	= config_get( 'mail_reporter' );
+		
+		$v_mailaddress = mail_parse_address( $p_mailaddress );
+
+		if ( $t_mail_use_reporter ) {
+			// Always report as mail_reporter
+			$t_reporter_id = user_get_id_by_name( $t_mail_reporter );
+		} else {
+			// Try to get the reporting users id
+			$t_reporter_id = user_get_id_by_mail ( $v_mailaddress );
+			if ( ! $t_reporter_id && $t_mail_auto_signup ) {
+				// So, we've to sign up a new user...
+				$t_user_name = mail_user_name_from_address ( $v_mailaddress );
+				user_signup($t_user_name, $v_mailaddress);
+				$t_reporter_id = user_get_id_by_name($t_user_name);
+			} elseif ( ! $t_reporter_id ) {
+				// Fall back to the default mail_reporter
+				$t_reporter_id = user_get_id_by_name( $t_mail_reporter );
+			}
+		}
+
+		// dirty: Set the identified user's id
+		// required if bug_report_mail is run via command line
+		$GLOBAL['g_cache_current_user_id'] = $t_reporter_id;
+
+		return $t_reporter_id;
+	}
+
+	# --------------------
+	# Very dirty: Adds a file to a bug.
+	function mail_add_file( $p_bug_id, $p_part ) {
+		$GLOBALS['_mail_file_'] = $p_part['Name'];
+		if ( 0 < strlen($p_part['Name']) ) {
+			$t_file_name = '/tmp/'.$p_part['Name'];
+			file_put_contents($t_file_name, $p_part['Body']);
+			file_add($p_bug_id, $t_file_name,  $p_part['Name'], $p_part['Content-Type'], 'bug');
+			unlink($t_file_name);
+		}
+	}
+
+	# --------------------
+	# Adds a bug which is reported via email
+	# Taken from bug_report.php and 
+	function mail_add_bug ( $p_mail, $p_account ) {
+		$t_mail_save_from	= config_get( 'mail_save_from' );
+
+		$t_bug_data = new BugData;
+		$t_bug_data->build			= gpc_get_string( 'build', '' );
+		$t_bug_data->platform			= gpc_get_string( 'platform', '' );
+		$t_bug_data->os				= gpc_get_string( 'os', '' );
+		$t_bug_data->os_build			= gpc_get_string( 'os_build', '' );
+		$t_bug_data->version			= gpc_get_string( 'product_version', '' );
+		$t_bug_data->profile_id			= gpc_get_int( 'profile_id', 0 );
+		$t_bug_data->handler_id			= gpc_get_int( 'handler_id', 0 );
+		$t_bug_data->view_state			= gpc_get_int( 'view_state', config_get( 'default_bug_view_status' ) );
+
+		if ( $p_account['category']) {
+			$t_bug_data->category			= gpc_get_string( 'category', $p_account['category'] );
+		} else {
+			$t_bug_data->category			= gpc_get_string( 'category', '' );
+		}
+		$t_bug_data->reproducibility		= 10;
+		$t_bug_data->severity			= 50;
+		$t_bug_data->priority			= gpc_get_int( 'priority', NORMAL );
+		$t_bug_data->summary			= $p_mail['Subject'];
+		if ( $t_mail_save_from ) {
+			$t_bug_data->description	= "Report from: ".$p_mail['From']."\n\n".$p_mail['X-Mantis-Body'];
+		}
+		else {
+			$t_bug_data->description	= $p_mail['X-Mantis-Body'];
+		}
+		$t_bug_data->steps_to_reproduce		= gpc_get_string( 'steps_to_reproduce', '' );
+		$t_bug_data->additional_information	= $p_mail['X-Mantis-Complete'];
+
+		$t_bug_data->project_id			= $p_account['id'];
+
+		$t_bug_data->reporter_id		= mail_get_user( $p_mail['From'] );
+
+		if ( mail_is_a_bugnote( $p_mail['Subject'] ) ) {
+			# Add a bug note
+			$t_bug_id = mail_get_bug_id_from_subject( $p_mail['Subject'] );
+			if ( ! bug_is_readonly( $t_bug_id ) ) {
+				bugnote_add ( $t_bug_id, $p_mail['X-Mantis-Body'] );
+				email_bugnote_add ( $t_bug_id );
+			}
+		} else	{
+			# Create the bug
+			$t_bug_id = bug_create( $t_bug_data );
+			email_new_bug( $t_bug_id );
+		}
+		# Add files
+		if ( null != $p_mail['X-Mantis-Parts'] ) {
+			foreach ($p_mail['X-Mantis-Parts'] as $part) {
+				mail_add_file ( $t_bug_id, $part );
+			}
+		}
+
+	}
+
+?>
+
diff -Nur mantis-0.19.4.orig/core/user_api.php mantis-0.19.4/core/user_api.php
--- mantis-0.19.4.orig/core/user_api.php	2004-11-19 13:29:00.000000000 +0100
+++ mantis-0.19.4/core/user_api.php	2005-12-23 13:56:09.000000000 +0100
@@ -477,6 +477,24 @@
 		}
 	}
 
+	# get a user id from an mail address
+	#  return false if the mail address does not exist
+	function user_get_id_by_mail( $p_mailaddress ) {
+		$c_mailaddress = db_prepare_string( $p_mailaddress );
+		$t_user_table = config_get( 'mantis_user_table' );
+
+		$query = "SELECT id
+				  FROM $t_user_table
+				  WHERE email='$c_mailaddress'";
+		$result = db_query( $query );
+
+		if ( 0 == db_num_rows( $result ) ) {
+			return false;
+		} else {
+			return db_result( $result );
+		}
+	}
+
 	# --------------------
 	# return all data associated with a particular user name
 	#  return false if the username does not exist
diff -Nur mantis-0.19.4.orig/doc/README.bug_report_mail mantis-0.19.4/doc/README.bug_report_mail
--- mantis-0.19.4.orig/doc/README.bug_report_mail	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/doc/README.bug_report_mail	2005-12-23 14:07:05.000000000 +0100
@@ -0,0 +1,118 @@
+The current version of bug_report_mail support plain text and MIME
+encoded e-mails via POP3 Mailaccounts with PEAR's Net_POP3 package.
+
+bug_report_mail is able to recognize if mail is a reply to an already opened
+bug and adds the content as a bugnote.
+
+If you are alway running Mantis you have to alter your projects table
+with the sql/bug_report_mail.sql script.
+If not, you can create the database tables in the way described in
+the doc/INSTALL file.
+
+This patch changes the following files:
+    core/category_api.php
+    core/file_api.php
+    core/user_api.php
+    sql/db_generate.sql
+    config_defaults_inc.php
+    manage_proj_cat_edit_page.php
+    manage_proj_edit_page.php
+These files are new:
+    core/mail_api.php
+    doc/README.bug_report_mail
+    sql/bug_report_mail.sql
+    bug_report_mail.php
+    manage_proj_cat_mail_delete.php
+    manage_proj_cat_mail_update.php
+    manage_proj_mail_categories.php
+    manage_proj_mail_delete.php
+    manage_proj_mail_update.php
+
+After installing this patch, you can add a POP3 server's hostname
+and authentication data for each of your projects with the project edit form.
+
+There are two ways to receive mail with bug_report_mail:
+The secure (and default) way is to use a standard reporting user:
+You have to create a reporter account, for example 'Mail'.
+The name for this reporter account you have to write in your config_inc.php file:
+	$g_mail_reporter = "Mail";
+and then, bug_report_mail must be informed to behave like this:
+	$g_mail_use_reporter = ON;
+
+The other way is to signup new user accounts automatically.
+For using this, you have to change this
+	$g_mail_auto_signup     = OFF;
+from OFF to ON.
+Now, bug_report_mail will look for an user named like the mail's sender
+or an user which mail adress is identical.
+If no user is found, then a new account will be created.
+The new user's name will be the mail address.
+
+This could be used for attacks, but there is no other way in the moment.
+
+If you like to parse MIME encoded mails, you have to install the PEAR
+Mail_Mime package and set
+	$g_mail_parse_mime	= OFF;
+from OFF to ON.
+
+For debugging controls there is the switch
+	$g_mail_additional	= OFF;
+which puts the complete message into the Additional Information field,
+if it is activated.
+
+In this case you should decrease the amount of fetched messages via
+	$g_mail_fetch_max	= 1;
+because the mime decoding needs a lot of memory.
+
+If you'd like to use the Mail Reporter but don't save the whole message for
+making the sender's address available, set
+	$g_mail_save_from	= OFF;
+to ON.
+
+After this, bug_report_mail can be used via cron like this:
+
+*/5 *   *   *   * lynx --dump http://mantis.homepage.com/bug_report_mail.php
+or via command line interface
+*/5 *   *   *   * /usr/local/bin/php /path/to/mantis/bug_report_mail.php
+
+This line fetch bug reports from via POP3 every 5 minutes. 
+
+This addon is distributed under the same conditions as Mantis itself.
+
+Gerrit Beine, August 2004
+
+Changelog:
+Dec 2005
+	- update to Mantis 0.19.4
+Oct 2005
+	- update to Mantis 0.19.3
+Sep 2005:
+	- update to Mantis 1.0.0rc2
+	- fixed a bug in getting all categories for a project
+		category_get_all_rows in core/category_api.php
+Aug 2005:
+	- update to Mantis 1.0.0rc1
+	- include the additional patches submitted by
+		- gernot (Fixed MIME handling and save the mail's sender)
+		  mail_get_all_mails in core/mail_api.php
+		  mail_parse_content in core/mail_api.php
+		  mail_add_bug in core/mail_api.php
+		- stevenc (Fixed MIME handling)
+		  mail_parse_content in core/mail_api.php
+		- rainman (Fixed empty files bug and regex for finding a bug id)
+		  mail_add_file in core/mail_api.php
+		  mail_get_bug_id_from_subject in core/mail_api.php
+Dec 2004:
+	- update to Mantis 0.19.2
+	- add config: g_mail_parse_mime
+	- add config: g_mail_additional
+	- add config: g_mail_fetch_max
+	- make it working via CLI
+Nov 2004:
+	- update to Mantis 0.19.1
+	- add support for MIME decoding
+Sep 2004:
+	- update to Mantis 0.19.0
+Aug 2004:
+	- create patch for Mantis 0.18.3
+
diff -Nur mantis-0.19.4.orig/Mail/mimeDecode.php mantis-0.19.4/Mail/mimeDecode.php
--- mantis-0.19.4.orig/Mail/mimeDecode.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/Mail/mimeDecode.php	2005-03-03 05:19:39.000000000 +0100
@@ -0,0 +1,837 @@
+<?php
+/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003  Richard Heyes                                |
+// | Copyright (c) 2003-2005  The PHP Group                                |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// +-----------------------------------------------------------------------+
+
+require_once 'PEAR.php';
+
+/**
+*  +----------------------------- IMPORTANT ------------------------------+
+*  | Usage of this class compared to native php extensions such as        |
+*  | mailparse or imap, is slow and may be feature deficient. If available|
+*  | you are STRONGLY recommended to use the php extensions.              |
+*  +----------------------------------------------------------------------+
+*
+* Mime Decoding class
+*
+* This class will parse a raw mime email and return
+* the structure. Returned structure is similar to
+* that returned by imap_fetchstructure().
+*
+* USAGE: (assume $input is your raw email)
+*
+* $decode = new Mail_mimeDecode($input, "\r\n");
+* $structure = $decode->decode();
+* print_r($structure);
+*
+* Or statically:
+*
+* $params['input'] = $input;
+* $structure = Mail_mimeDecode::decode($params);
+* print_r($structure);
+*
+* TODO:
+*  o Implement multipart/appledouble
+*  o UTF8: ???
+
+		> 4. We have also found a solution for decoding the UTF-8 
+		> headers. Therefore I made the following function:
+		> 
+		> function decode_utf8($txt) {
+		> $trans=array("Å&#8216;"=>"Ãµ","Å±"=>"Ã»","Å"=>"Ã&#8226;","Å°"
+		=>"Ã&#8250;");
+		> $txt=strtr($txt,$trans);
+		> return(utf8_decode($txt));
+		> }
+		> 
+		> And I have inserted the following line to the class:
+		> 
+		> if (strtolower($charset)=="utf-8") $text=decode_utf8($text);
+		> 
+		> ... before the following one in the "_decodeHeader" function:
+		> 
+		> $input = str_replace($encoded, $text, $input);
+		> 
+		> This way from now on it can easily decode the UTF-8 headers too.
+
+*
+* @author  Richard Heyes <richard@phpguru.org>
+* @version $Revision: 1.46 $
+* @package Mail
+*/
+class Mail_mimeDecode extends PEAR
+{
+    /**
+     * The raw email to decode
+     * @var    string
+     */
+    var $_input;
+
+    /**
+     * The header part of the input
+     * @var    string
+     */
+    var $_header;
+
+    /**
+     * The body part of the input
+     * @var    string
+     */
+    var $_body;
+
+    /**
+     * If an error occurs, this is used to store the message
+     * @var    string
+     */
+    var $_error;
+
+    /**
+     * Flag to determine whether to include bodies in the
+     * returned object.
+     * @var    boolean
+     */
+    var $_include_bodies;
+
+    /**
+     * Flag to determine whether to decode bodies
+     * @var    boolean
+     */
+    var $_decode_bodies;
+
+    /**
+     * Flag to determine whether to decode headers
+     * @var    boolean
+     */
+    var $_decode_headers;
+
+    /**
+     * Constructor.
+     *
+     * Sets up the object, initialise the variables, and splits and
+     * stores the header and body of the input.
+     *
+     * @param string The input to decode
+     * @access public
+     */
+    function Mail_mimeDecode($input)
+    {
+        list($header, $body)   = $this->_splitBodyHeader($input);
+
+        $this->_input          = $input;
+        $this->_header         = $header;
+        $this->_body           = $body;
+        $this->_decode_bodies  = false;
+        $this->_include_bodies = true;
+    }
+
+    /**
+     * Begins the decoding process. If called statically
+     * it will create an object and call the decode() method
+     * of it.
+     *
+     * @param array An array of various parameters that determine
+     *              various things:
+     *              include_bodies - Whether to include the body in the returned
+     *                               object.
+     *              decode_bodies  - Whether to decode the bodies
+     *                               of the parts. (Transfer encoding)
+     *              decode_headers - Whether to decode headers
+     *              input          - If called statically, this will be treated
+     *                               as the input
+     * @return object Decoded results
+     * @access public
+     */
+    function decode($params = null)
+    {
+        // determine if this method has been called statically
+        $isStatic = !(isset($this) && get_class($this) == __CLASS__);
+
+        // Have we been called statically?
+	// If so, create an object and pass details to that.
+        if ($isStatic AND isset($params['input'])) {
+
+            $obj = new Mail_mimeDecode($params['input']);
+            $structure = $obj->decode($params);
+
+        // Called statically but no input
+        } elseif ($isStatic) {
+            return PEAR::raiseError('Called statically and no input given');
+
+        // Called via an object
+        } else {
+            $this->_include_bodies = isset($params['include_bodies']) ?
+	                             $params['include_bodies'] : false;
+            $this->_decode_bodies  = isset($params['decode_bodies']) ?
+	                             $params['decode_bodies']  : false;
+            $this->_decode_headers = isset($params['decode_headers']) ?
+	                             $params['decode_headers'] : false;
+
+            $structure = $this->_decode($this->_header, $this->_body);
+            if ($structure === false) {
+                $structure = $this->raiseError($this->_error);
+            }
+        }
+
+        return $structure;
+    }
+
+    /**
+     * Performs the decoding. Decodes the body string passed to it
+     * If it finds certain content-types it will call itself in a
+     * recursive fashion
+     *
+     * @param string Header section
+     * @param string Body section
+     * @return object Results of decoding process
+     * @access private
+     */
+    function _decode($headers, $body, $default_ctype = 'text/plain')
+    {
+        $return = new stdClass;
+        $return->headers = array();
+        $headers = $this->_parseHeaders($headers);
+
+        foreach ($headers as $value) {
+            if (isset($return->headers[strtolower($value['name'])]) AND !is_array($return->headers[strtolower($value['name'])])) {
+                $return->headers[strtolower($value['name'])]   = array($return->headers[strtolower($value['name'])]);
+                $return->headers[strtolower($value['name'])][] = $value['value'];
+
+            } elseif (isset($return->headers[strtolower($value['name'])])) {
+                $return->headers[strtolower($value['name'])][] = $value['value'];
+
+            } else {
+                $return->headers[strtolower($value['name'])] = $value['value'];
+            }
+        }
+
+        reset($headers);
+        while (list($key, $value) = each($headers)) {
+            $headers[$key]['name'] = strtolower($headers[$key]['name']);
+            switch ($headers[$key]['name']) {
+
+                case 'content-type':
+                    $content_type = $this->_parseHeaderValue($headers[$key]['value']);
+
+                    if (preg_match('/([0-9a-z+.-]+)\/([0-9a-z+.-]+)/i', $content_type['value'], $regs)) {
+                        $return->ctype_primary   = $regs[1];
+                        $return->ctype_secondary = $regs[2];
+                    }
+
+                    if (isset($content_type['other'])) {
+                        while (list($p_name, $p_value) = each($content_type['other'])) {
+                            $return->ctype_parameters[$p_name] = $p_value;
+                        }
+                    }
+                    break;
+
+                case 'content-disposition':
+                    $content_disposition = $this->_parseHeaderValue($headers[$key]['value']);
+                    $return->disposition   = $content_disposition['value'];
+                    if (isset($content_disposition['other'])) {
+                        while (list($p_name, $p_value) = each($content_disposition['other'])) {
+                            $return->d_parameters[$p_name] = $p_value;
+                        }
+                    }
+                    break;
+
+                case 'content-transfer-encoding':
+                    $content_transfer_encoding = $this->_parseHeaderValue($headers[$key]['value']);
+                    break;
+            }
+        }
+
+        if (isset($content_type)) {
+            switch (strtolower($content_type['value'])) {
+                case 'text/plain':
+                    $encoding = isset($content_transfer_encoding) ? $content_transfer_encoding['value'] : '7bit';
+                    $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body, $encoding) : $body) : null;
+                    break;
+
+                case 'text/html':
+                    $encoding = isset($content_transfer_encoding) ? $content_transfer_encoding['value'] : '7bit';
+                    $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body, $encoding) : $body) : null;
+                    break;
+
+                case 'multipart/parallel':
+                case 'multipart/report': // RFC1892
+                case 'multipart/signed': // PGP
+                case 'multipart/digest':
+                case 'multipart/alternative':
+                case 'multipart/related':
+                case 'multipart/mixed':
+                    if(!isset($content_type['other']['boundary'])){
+                        $this->_error = 'No boundary found for ' . $content_type['value'] . ' part';
+                        return false;
+                    }
+
+                    $default_ctype = (strtolower($content_type['value']) === 'multipart/digest') ? 'message/rfc822' : 'text/plain';
+
+                    $parts = $this->_boundarySplit($body, $content_type['other']['boundary']);
+                    for ($i = 0; $i < count($parts); $i++) {
+                        list($part_header, $part_body) = $this->_splitBodyHeader($parts[$i]);
+                        $part = $this->_decode($part_header, $part_body, $default_ctype);
+                        if($part === false)
+                            $part = $this->raiseError($this->_error);
+                        $return->parts[] = $part;
+                    }
+                    break;
+
+                case 'message/rfc822':
+                    $obj = &new Mail_mimeDecode($body);
+                    $return->parts[] = $obj->decode(array('include_bodies' => $this->_include_bodies,
+					                                      'decode_bodies'  => $this->_decode_bodies,
+														  'decode_headers' => $this->_decode_headers));
+                    unset($obj);
+                    break;
+
+                default:
+                    if(!isset($content_transfer_encoding['value']))
+                        $content_transfer_encoding['value'] = '7bit';
+                    $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body, $content_transfer_encoding['value']) : $body) : null;
+                    break;
+            }
+
+        } else {
+            $ctype = explode('/', $default_ctype);
+            $return->ctype_primary   = $ctype[0];
+            $return->ctype_secondary = $ctype[1];
+            $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body) : $body) : null;
+        }
+
+        return $return;
+    }
+
+    /**
+     * Given the output of the above function, this will return an
+     * array of references to the parts, indexed by mime number.
+     *
+     * @param  object $structure   The structure to go through
+     * @param  string $mime_number Internal use only.
+     * @return array               Mime numbers
+     */
+    function &getMimeNumbers(&$structure, $no_refs = false, $mime_number = '', $prepend = '')
+    {
+        $return = array();
+        if (!empty($structure->parts)) {
+            if ($mime_number != '') {
+                $structure->mime_id = $prepend . $mime_number;
+                $return[$prepend . $mime_number] = &$structure;
+            }
+            for ($i = 0; $i < count($structure->parts); $i++) {
+
+            
+                if (!empty($structure->headers['content-type']) AND substr(strtolower($structure->headers['content-type']), 0, 8) == 'message/') {
+                    $prepend      = $prepend . $mime_number . '.';
+                    $_mime_number = '';
+                } else {
+                    $_mime_number = ($mime_number == '' ? $i + 1 : sprintf('%s.%s', $mime_number, $i + 1));
+                }
+
+                $arr = &Mail_mimeDecode::getMimeNumbers($structure->parts[$i], $no_refs, $_mime_number, $prepend);
+                foreach ($arr as $key => $val) {
+                    $no_refs ? $return[$key] = '' : $return[$key] = &$arr[$key];
+                }
+            }
+        } else {
+            if ($mime_number == '') {
+                $mime_number = '1';
+            }
+            $structure->mime_id = $prepend . $mime_number;
+            $no_refs ? $return[$prepend . $mime_number] = '' : $return[$prepend . $mime_number] = &$structure;
+        }
+        
+        return $return;
+    }
+
+    /**
+     * Given a string containing a header and body
+     * section, this function will split them (at the first
+     * blank line) and return them.
+     *
+     * @param string Input to split apart
+     * @return array Contains header and body section
+     * @access private
+     */
+    function _splitBodyHeader($input)
+    {
+        if (preg_match("/^(.*?)\r?\n\r?\n(.*)/s", $input, $match)) {
+            return array($match[1], $match[2]);
+        }
+        $this->_error = 'Could not split header and body';
+        return false;
+    }
+
+    /**
+     * Parse headers given in $input and return
+     * as assoc array.
+     *
+     * @param string Headers to parse
+     * @return array Contains parsed headers
+     * @access private
+     */
+    function _parseHeaders($input)
+    {
+
+        if ($input !== '') {
+            // Unfold the input
+            $input   = preg_replace("/\r?\n/", "\r\n", $input);
+            $input   = preg_replace("/\r\n(\t| )+/", ' ', $input);
+            $headers = explode("\r\n", trim($input));
+
+            foreach ($headers as $value) {
+                $hdr_name = substr($value, 0, $pos = strpos($value, ':'));
+                $hdr_value = substr($value, $pos+1);
+                if($hdr_value[0] == ' ')
+                    $hdr_value = substr($hdr_value, 1);
+
+                $return[] = array(
+                                  'name'  => $hdr_name,
+                                  'value' => $this->_decode_headers ? $this->_decodeHeader($hdr_value) : $hdr_value
+                                 );
+            }
+        } else {
+            $return = array();
+        }
+
+        return $return;
+    }
+
+    /**
+     * Function to parse a header value,
+     * extract first part, and any secondary
+     * parts (after ;) This function is not as
+     * robust as it could be. Eg. header comments
+     * in the wrong place will probably break it.
+     *
+     * @param string Header value to parse
+     * @return array Contains parsed result
+     * @access private
+     */
+    function _parseHeaderValue($input)
+    {
+
+        if (($pos = strpos($input, ';')) !== false) {
+
+            $return['value'] = trim(substr($input, 0, $pos));
+            $input = trim(substr($input, $pos+1));
+
+            if (strlen($input) > 0) {
+
+                // This splits on a semi-colon, if there's no preceeding backslash
+                // Now works with quoted values; had to glue the \; breaks in PHP
+                // the regex is already bordering on incomprehensible
+                $splitRegex = '/([^;\'"]*[\'"]([^\'"]*([^\'"]*)*)[\'"][^;\'"]*|([^;]+))(;|$)/';
+                preg_match_all($splitRegex, $input, $matches);
+                $parameters = array();
+                for ($i=0; $i<count($matches[0]); $i++) {
+                    $param = $matches[0][$i];
+                    while (substr($param, -2) == '\;') {
+                        $param .= $matches[0][++$i];
+                    }
+                    $parameters[] = $param;
+                }
+
+                for ($i = 0; $i < count($parameters); $i++) {
+                    $param_name  = trim(substr($parameters[$i], 0, $pos = strpos($parameters[$i], '=')), "'\";\t\\ ");
+                    $param_value = trim(str_replace('\;', ';', substr($parameters[$i], $pos + 1)), "'\";\t\\ ");
+                    if ($param_value[0] == '"') {
+                        $param_value = substr($param_value, 1, -1);
+                    }
+                    $return['other'][$param_name] = $param_value;
+                    $return['other'][strtolower($param_name)] = $param_value;
+                }
+            }
+        } else {
+            $return['value'] = trim($input);
+        }
+
+        return $return;
+    }
+
+    /**
+     * This function splits the input based
+     * on the given boundary
+     *
+     * @param string Input to parse
+     * @return array Contains array of resulting mime parts
+     * @access private
+     */
+    function _boundarySplit($input, $boundary)
+    {
+        $parts = array();
+
+        $bs_possible = substr($boundary, 2, -2);
+        $bs_check = '\"' . $bs_possible . '\"';
+
+        if ($boundary == $bs_check) {
+            $boundary = $bs_possible;
+        }
+
+        $tmp = explode('--' . $boundary, $input);
+
+        for ($i = 1; $i < count($tmp) - 1; $i++) {
+            $parts[] = $tmp[$i];
+        }
+
+        return $parts;
+    }
+
+    /**
+     * Given a header, this function will decode it
+     * according to RFC2047. Probably not *exactly*
+     * conformant, but it does pass all the given
+     * examples (in RFC2047).
+     *
+     * @param string Input header value to decode
+     * @return string Decoded header value
+     * @access private
+     */
+    function _decodeHeader($input)
+    {
+        // Remove white space between encoded-words
+        $input = preg_replace('/(=\?[^?]+\?(q|b)\?[^?]*\?=)(\s)+=\?/i', '\1=?', $input);
+
+        // For each encoded-word...
+        while (preg_match('/(=\?([^?]+)\?(q|b)\?([^?]*)\?=)/i', $input, $matches)) {
+
+            $encoded  = $matches[1];
+            $charset  = $matches[2];
+            $encoding = $matches[3];
+            $text     = $matches[4];
+
+            switch (strtolower($encoding)) {
+                case 'b':
+                    $text = base64_decode($text);
+                    break;
+
+                case 'q':
+                    $text = str_replace('_', ' ', $text);
+                    preg_match_all('/=([a-f0-9]{2})/i', $text, $matches);
+                    foreach($matches[1] as $value)
+                        $text = str_replace('='.$value, chr(hexdec($value)), $text);
+                    break;
+            }
+
+            $input = str_replace($encoded, $text, $input);
+        }
+
+        return $input;
+    }
+
+    /**
+     * Given a body string and an encoding type,
+     * this function will decode and return it.
+     *
+     * @param  string Input body to decode
+     * @param  string Encoding type to use.
+     * @return string Decoded body
+     * @access private
+     */
+    function _decodeBody($input, $encoding = '7bit')
+    {
+        switch (strtolower($encoding)) {
+            case '7bit':
+                return $input;
+                break;
+
+            case 'quoted-printable':
+                return $this->_quotedPrintableDecode($input);
+                break;
+
+            case 'base64':
+                return base64_decode($input);
+                break;
+
+            default:
+                return $input;
+        }
+    }
+
+    /**
+     * Given a quoted-printable string, this
+     * function will decode and return it.
+     *
+     * @param  string Input body to decode
+     * @return string Decoded body
+     * @access private
+     */
+    function _quotedPrintableDecode($input)
+    {
+        // Remove soft line breaks
+        $input = preg_replace("/=\r?\n/", '', $input);
+
+        // Replace encoded characters
+		$input = preg_replace('/=([a-f0-9]{2})/ie', "chr(hexdec('\\1'))", $input);
+
+        return $input;
+    }
+
+    /**
+     * Checks the input for uuencoded files and returns
+     * an array of them. Can be called statically, eg:
+     *
+     * $files =& Mail_mimeDecode::uudecode($some_text);
+     *
+     * It will check for the begin 666 ... end syntax
+     * however and won't just blindly decode whatever you
+     * pass it.
+     *
+     * @param  string Input body to look for attahcments in
+     * @return array  Decoded bodies, filenames and permissions
+     * @access public
+     * @author Unknown
+     */
+    function &uudecode($input)
+    {
+        // Find all uuencoded sections
+        preg_match_all("/begin ([0-7]{3}) (.+)\r?\n(.+)\r?\nend/Us", $input, $matches);
+
+        for ($j = 0; $j < count($matches[3]); $j++) {
+
+            $str      = $matches[3][$j];
+            $filename = $matches[2][$j];
+            $fileperm = $matches[1][$j];
+
+            $file = '';
+            $str = preg_split("/\r?\n/", trim($str));
+            $strlen = count($str);
+
+            for ($i = 0; $i < $strlen; $i++) {
+                $pos = 1;
+                $d = 0;
+                $len=(int)(((ord(substr($str[$i],0,1)) -32) - ' ') & 077);
+
+                while (($d + 3 <= $len) AND ($pos + 4 <= strlen($str[$i]))) {
+                    $c0 = (ord(substr($str[$i],$pos,1)) ^ 0x20);
+                    $c1 = (ord(substr($str[$i],$pos+1,1)) ^ 0x20);
+                    $c2 = (ord(substr($str[$i],$pos+2,1)) ^ 0x20);
+                    $c3 = (ord(substr($str[$i],$pos+3,1)) ^ 0x20);
+                    $file .= chr(((($c0 - ' ') & 077) << 2) | ((($c1 - ' ') & 077) >> 4));
+
+                    $file .= chr(((($c1 - ' ') & 077) << 4) | ((($c2 - ' ') & 077) >> 2));
+
+                    $file .= chr(((($c2 - ' ') & 077) << 6) |  (($c3 - ' ') & 077));
+
+                    $pos += 4;
+                    $d += 3;
+                }
+
+                if (($d + 2 <= $len) && ($pos + 3 <= strlen($str[$i]))) {
+                    $c0 = (ord(substr($str[$i],$pos,1)) ^ 0x20);
+                    $c1 = (ord(substr($str[$i],$pos+1,1)) ^ 0x20);
+                    $c2 = (ord(substr($str[$i],$pos+2,1)) ^ 0x20);
+                    $file .= chr(((($c0 - ' ') & 077) << 2) | ((($c1 - ' ') & 077) >> 4));
+
+                    $file .= chr(((($c1 - ' ') & 077) << 4) | ((($c2 - ' ') & 077) >> 2));
+
+                    $pos += 3;
+                    $d += 2;
+                }
+
+                if (($d + 1 <= $len) && ($pos + 2 <= strlen($str[$i]))) {
+                    $c0 = (ord(substr($str[$i],$pos,1)) ^ 0x20);
+                    $c1 = (ord(substr($str[$i],$pos+1,1)) ^ 0x20);
+                    $file .= chr(((($c0 - ' ') & 077) << 2) | ((($c1 - ' ') & 077) >> 4));
+
+                }
+            }
+            $files[] = array('filename' => $filename, 'fileperm' => $fileperm, 'filedata' => $file);
+        }
+
+        return $files;
+    }
+
+    /**
+     * getSendArray() returns the arguments required for Mail::send()
+     * used to build the arguments for a mail::send() call 
+     *
+     * Usage:
+     * $mailtext = Full email (for example generated by a template)
+     * $decoder = new Mail_mimeDecode($mailtext);
+     * $parts =  $decoder->getSendArray();
+     * if (!PEAR::isError($parts) {
+     *     list($recipents,$headers,$body) = $parts;
+     *     $mail = Mail::factory('smtp');
+     *     $mail->send($recipents,$headers,$body);
+     * } else {
+     *     echo $parts->message;
+     * }
+     * @return mixed   array of recipeint, headers,body or Pear_Error
+     * @access public
+     * @author Alan Knowles <alan@akbkhome.com>
+     */
+    function getSendArray()
+    {
+        // prevent warning if this is not set
+        $this->_decode_headers = FALSE;
+        $headerlist =$this->_parseHeaders($this->_header);
+        $to = "";
+        if (!$headerlist) {
+            return $this->raiseError("Message did not contain headers");
+        }
+        foreach($headerlist as $item) {
+            $header[$item['name']] = $item['value'];
+            switch (strtolower($item['name'])) {
+                case "to":
+                case "cc":
+                case "bcc":
+                    $to = ",".$item['value'];
+                default:
+                   break;
+            }
+        }
+        if ($to == "") {
+            return $this->raiseError("Message did not contain any recipents");
+        }
+        $to = substr($to,1);
+        return array($to,$header,$this->_body);
+    } 
+
+    /**
+     * Returns a xml copy of the output of
+     * Mail_mimeDecode::decode. Pass the output in as the
+     * argument. This function can be called statically. Eg:
+     *
+     * $output = $obj->decode();
+     * $xml    = Mail_mimeDecode::getXML($output);
+     *
+     * The DTD used for this should have been in the package. Or
+     * alternatively you can get it from cvs, or here:
+     * http://www.phpguru.org/xmail/xmail.dtd.
+     *
+     * @param  object Input to convert to xml. This should be the
+     *                output of the Mail_mimeDecode::decode function
+     * @return string XML version of input
+     * @access public
+     */
+    function getXML($input)
+    {
+        $crlf    =  "\r\n";
+        $output  = '<?xml version=\'1.0\'?>' . $crlf .
+                   '<!DOCTYPE email SYSTEM "http://www.phpguru.org/xmail/xmail.dtd">' . $crlf .
+                   '<email>' . $crlf .
+                   Mail_mimeDecode::_getXML($input) .
+                   '</email>';
+
+        return $output;
+    }
+
+    /**
+     * Function that does the actual conversion to xml. Does a single
+     * mimepart at a time.
+     *
+     * @param  object  Input to convert to xml. This is a mimepart object.
+     *                 It may or may not contain subparts.
+     * @param  integer Number of tabs to indent
+     * @return string  XML version of input
+     * @access private
+     */
+    function _getXML($input, $indent = 1)
+    {
+        $htab    =  "\t";
+        $crlf    =  "\r\n";
+        $output  =  '';
+        $headers = @(array)$input->headers;
+
+        foreach ($headers as $hdr_name => $hdr_value) {
+
+            // Multiple headers with this name
+            if (is_array($headers[$hdr_name])) {
+                for ($i = 0; $i < count($hdr_value); $i++) {
+                    $output .= Mail_mimeDecode::_getXML_helper($hdr_name, $hdr_value[$i], $indent);
+                }
+
+            // Only one header of this sort
+            } else {
+                $output .= Mail_mimeDecode::_getXML_helper($hdr_name, $hdr_value, $indent);
+            }
+        }
+
+        if (!empty($input->parts)) {
+            for ($i = 0; $i < count($input->parts); $i++) {
+                $output .= $crlf . str_repeat($htab, $indent) . '<mimepart>' . $crlf .
+                           Mail_mimeDecode::_getXML($input->parts[$i], $indent+1) .
+                           str_repeat($htab, $indent) . '</mimepart>' . $crlf;
+            }
+        } elseif (isset($input->body)) {
+            $output .= $crlf . str_repeat($htab, $indent) . '<body><![CDATA[' .
+                       $input->body . ']]></body>' . $crlf;
+        }
+
+        return $output;
+    }
+
+    /**
+     * Helper function to _getXML(). Returns xml of a header.
+     *
+     * @param  string  Name of header
+     * @param  string  Value of header
+     * @param  integer Number of tabs to indent
+     * @return string  XML version of input
+     * @access private
+     */
+    function _getXML_helper($hdr_name, $hdr_value, $indent)
+    {
+        $htab   = "\t";
+        $crlf   = "\r\n";
+        $return = '';
+
+        $new_hdr_value = ($hdr_name != 'received') ? Mail_mimeDecode::_parseHeaderValue($hdr_value) : array('value' => $hdr_value);
+        $new_hdr_name  = str_replace(' ', '-', ucwords(str_replace('-', ' ', $hdr_name)));
+
+        // Sort out any parameters
+        if (!empty($new_hdr_value['other'])) {
+            foreach ($new_hdr_value['other'] as $paramname => $paramvalue) {
+                $params[] = str_repeat($htab, $indent) . $htab . '<parameter>' . $crlf .
+                            str_repeat($htab, $indent) . $htab . $htab . '<paramname>' . htmlspecialchars($paramname) . '</paramname>' . $crlf .
+                            str_repeat($htab, $indent) . $htab . $htab . '<paramvalue>' . htmlspecialchars($paramvalue) . '</paramvalue>' . $crlf .
+                            str_repeat($htab, $indent) . $htab . '</parameter>' . $crlf;
+            }
+
+            $params = implode('', $params);
+        } else {
+            $params = '';
+        }
+
+        $return = str_repeat($htab, $indent) . '<header>' . $crlf .
+                  str_repeat($htab, $indent) . $htab . '<headername>' . htmlspecialchars($new_hdr_name) . '</headername>' . $crlf .
+                  str_repeat($htab, $indent) . $htab . '<headervalue>' . htmlspecialchars($new_hdr_value['value']) . '</headervalue>' . $crlf .
+                  $params .
+                  str_repeat($htab, $indent) . '</header>' . $crlf;
+
+        return $return;
+    }
+
+} // End of class
+?>
diff -Nur mantis-0.19.4.orig/Mail/mimePart.php mantis-0.19.4/Mail/mimePart.php
--- mantis-0.19.4.orig/Mail/mimePart.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/Mail/mimePart.php	2004-12-11 00:08:26.000000000 +0100
@@ -0,0 +1,351 @@
+<?php
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003  Richard Heyes                                     |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// +-----------------------------------------------------------------------+
+
+/**
+*
+*  Raw mime encoding class
+*
+* What is it?
+*   This class enables you to manipulate and build
+*   a mime email from the ground up.
+*
+* Why use this instead of mime.php?
+*   mime.php is a userfriendly api to this class for
+*   people who aren't interested in the internals of
+*   mime mail. This class however allows full control
+*   over the email.
+*
+* Eg.
+*
+* // Since multipart/mixed has no real body, (the body is
+* // the subpart), we set the body argument to blank.
+*
+* $params['content_type'] = 'multipart/mixed';
+* $email = new Mail_mimePart('', $params);
+*
+* // Here we add a text part to the multipart we have
+* // already. Assume $body contains plain text.
+*
+* $params['content_type'] = 'text/plain';
+* $params['encoding']     = '7bit';
+* $text = $email->addSubPart($body, $params);
+*
+* // Now add an attachment. Assume $attach is
+* the contents of the attachment
+*
+* $params['content_type'] = 'application/zip';
+* $params['encoding']     = 'base64';
+* $params['disposition']  = 'attachment';
+* $params['dfilename']    = 'example.zip';
+* $attach =& $email->addSubPart($body, $params);
+*
+* // Now build the email. Note that the encode
+* // function returns an associative array containing two
+* // elements, body and headers. You will need to add extra
+* // headers, (eg. Mime-Version) before sending.
+*
+* $email = $message->encode();
+* $email['headers'][] = 'Mime-Version: 1.0';
+*
+*
+* Further examples are available at http://www.phpguru.org
+*
+* TODO:
+*  - Set encode() to return the $obj->encoded if encode()
+*    has already been run. Unless a flag is passed to specifically
+*    re-build the message.
+*
+* @author  Richard Heyes <richard@phpguru.org>
+* @version $Revision: 1.13 $
+* @package Mail
+*/
+
+class Mail_mimePart {
+
+   /**
+    * The encoding type of this part
+    * @var string
+    */
+    var $_encoding;
+
+   /**
+    * An array of subparts
+    * @var array
+    */
+    var $_subparts;
+
+   /**
+    * The output of this part after being built
+    * @var string
+    */
+    var $_encoded;
+
+   /**
+    * Headers for this part
+    * @var array
+    */
+    var $_headers;
+
+   /**
+    * The body of this part (not encoded)
+    * @var string
+    */
+    var $_body;
+
+    /**
+     * Constructor.
+     *
+     * Sets up the object.
+     *
+     * @param $body   - The body of the mime part if any.
+     * @param $params - An associative array of parameters:
+     *                  content_type - The content type for this part eg multipart/mixed
+     *                  encoding     - The encoding to use, 7bit, 8bit, base64, or quoted-printable
+     *                  cid          - Content ID to apply
+     *                  disposition  - Content disposition, inline or attachment
+     *                  dfilename    - Optional filename parameter for content disposition
+     *                  description  - Content description
+     *                  charset      - Character set to use
+     * @access public
+     */
+    function Mail_mimePart($body = '', $params = array())
+    {
+        if (!defined('MAIL_MIMEPART_CRLF')) {
+            define('MAIL_MIMEPART_CRLF', defined('MAIL_MIME_CRLF') ? MAIL_MIME_CRLF : "\r\n", TRUE);
+        }
+
+        foreach ($params as $key => $value) {
+            switch ($key) {
+                case 'content_type':
+                    $headers['Content-Type'] = $value . (isset($charset) ? '; charset="' . $charset . '"' : '');
+                    break;
+
+                case 'encoding':
+                    $this->_encoding = $value;
+                    $headers['Content-Transfer-Encoding'] = $value;
+                    break;
+
+                case 'cid':
+                    $headers['Content-ID'] = '<' . $value . '>';
+                    break;
+
+                case 'disposition':
+                    $headers['Content-Disposition'] = $value . (isset($dfilename) ? '; filename="' . $dfilename . '"' : '');
+                    break;
+
+                case 'dfilename':
+                    if (isset($headers['Content-Disposition'])) {
+                        $headers['Content-Disposition'] .= '; filename="' . $value . '"';
+                    } else {
+                        $dfilename = $value;
+                    }
+                    break;
+
+                case 'description':
+                    $headers['Content-Description'] = $value;
+                    break;
+
+                case 'charset':
+                    if (isset($headers['Content-Type'])) {
+                        $headers['Content-Type'] .= '; charset="' . $value . '"';
+                    } else {
+                        $charset = $value;
+                    }
+                    break;
+            }
+        }
+
+        // Default content-type
+        if (!isset($headers['Content-Type'])) {
+            $headers['Content-Type'] = 'text/plain';
+        }
+
+        //Default encoding
+        if (!isset($this->_encoding)) {
+            $this->_encoding = '7bit';
+        }
+
+        // Assign stuff to member variables
+        $this->_encoded  = array();
+        $this->_headers  = $headers;
+        $this->_body     = $body;
+    }
+
+    /**
+     * encode()
+     *
+     * Encodes and returns the email. Also stores
+     * it in the encoded member variable
+     *
+     * @return An associative array containing two elements,
+     *         body and headers. The headers element is itself
+     *         an indexed array.
+     * @access public
+     */
+    function encode()
+    {
+        $encoded =& $this->_encoded;
+
+        if (!empty($this->_subparts)) {
+            srand((double)microtime()*1000000);
+            $boundary = '=_' . md5(rand() . microtime());
+            $this->_headers['Content-Type'] .= ';' . MAIL_MIMEPART_CRLF . "\t" . 'boundary="' . $boundary . '"';
+
+            // Add body parts to $subparts
+            for ($i = 0; $i < count($this->_subparts); $i++) {
+                $headers = array();
+                $tmp = $this->_subparts[$i]->encode();
+                foreach ($tmp['headers'] as $key => $value) {
+                    $headers[] = $key . ': ' . $value;
+                }
+                $subparts[] = implode(MAIL_MIMEPART_CRLF, $headers) . MAIL_MIMEPART_CRLF . MAIL_MIMEPART_CRLF . $tmp['body'];
+            }
+
+            $encoded['body'] = '--' . $boundary . MAIL_MIMEPART_CRLF .
+                               implode('--' . $boundary . MAIL_MIMEPART_CRLF, $subparts) .
+                               '--' . $boundary.'--' . MAIL_MIMEPART_CRLF;
+
+        } else {
+            $encoded['body'] = $this->_getEncodedData($this->_body, $this->_encoding) . MAIL_MIMEPART_CRLF;
+        }
+
+        // Add headers to $encoded
+        $encoded['headers'] =& $this->_headers;
+
+        return $encoded;
+    }
+
+    /**
+     * &addSubPart()
+     *
+     * Adds a subpart to current mime part and returns
+     * a reference to it
+     *
+     * @param $body   The body of the subpart, if any.
+     * @param $params The parameters for the subpart, same
+     *                as the $params argument for constructor.
+     * @return A reference to the part you just added. It is
+     *         crucial if using multipart/* in your subparts that
+     *         you use =& in your script when calling this function,
+     *         otherwise you will not be able to add further subparts.
+     * @access public
+     */
+    function &addSubPart($body, $params)
+    {
+        $this->_subparts[] = new Mail_mimePart($body, $params);
+        return $this->_subparts[count($this->_subparts) - 1];
+    }
+
+    /**
+     * _getEncodedData()
+     *
+     * Returns encoded data based upon encoding passed to it
+     *
+     * @param $data     The data to encode.
+     * @param $encoding The encoding type to use, 7bit, base64,
+     *                  or quoted-printable.
+     * @access private
+     */
+    function _getEncodedData($data, $encoding)
+    {
+        switch ($encoding) {
+            case '8bit':
+            case '7bit':
+                return $data;
+                break;
+
+            case 'quoted-printable':
+                return $this->_quotedPrintableEncode($data);
+                break;
+
+            case 'base64':
+                return rtrim(chunk_split(base64_encode($data), 76, MAIL_MIMEPART_CRLF));
+                break;
+
+            default:
+                return $data;
+        }
+    }
+
+    /**
+     * quoteadPrintableEncode()
+     *
+     * Encodes data to quoted-printable standard.
+     *
+     * @param $input    The data to encode
+     * @param $line_max Optional max line length. Should
+     *                  not be more than 76 chars
+     *
+     * @access private
+     */
+    function _quotedPrintableEncode($input , $line_max = 76)
+    {
+        $lines  = preg_split("/\r?\n/", $input);
+        $eol    = MAIL_MIMEPART_CRLF;
+        $escape = '=';
+        $output = '';
+
+        while(list(, $line) = each($lines)){
+
+            $linlen     = strlen($line);
+            $newline = '';
+
+            for ($i = 0; $i < $linlen; $i++) {
+                $char = substr($line, $i, 1);
+                $dec  = ord($char);
+
+                if (($dec == 32) AND ($i == ($linlen - 1))){    // convert space at eol only
+                    $char = '=20';
+
+                } elseif(($dec == 9) AND ($i == ($linlen - 1))) {  // convert tab at eol only
+                    $char = '=09';
+                } elseif($dec == 9) {
+                    ; // Do nothing if a tab.
+                } elseif(($dec == 61) OR ($dec < 32 ) OR ($dec > 126)) {
+                    $char = $escape . strtoupper(sprintf('%02s', dechex($dec)));
+                }
+
+                if ((strlen($newline) + strlen($char)) >= $line_max) {        // MAIL_MIMEPART_CRLF is not counted
+                    $output  .= $newline . $escape . $eol;                    // soft line break; " =\r\n" is okay
+                    $newline  = '';
+                }
+                $newline .= $char;
+            } // end of for
+            $output .= $newline . $eol;
+        }
+        $output = substr($output, 0, -1 * strlen($eol)); // Don't want last crlf
+        return $output;
+    }
+} // End of class
+?>
diff -Nur mantis-0.19.4.orig/Mail/mime.php mantis-0.19.4/Mail/mime.php
--- mantis-0.19.4.orig/Mail/mime.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/Mail/mime.php	2005-07-13 22:49:04.000000000 +0200
@@ -0,0 +1,713 @@
+<?php
+/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003  Richard Heyes                                |
+// | Copyright (c) 2003-2005  The PHP Group                                |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// |         Tomas V.V.Cox <cox@idecnet.com> (port to PEAR)                |
+// +-----------------------------------------------------------------------+
+//
+// $Id: mime.php,v 1.39 2005/06/13 21:24:16 cipri Exp $
+
+require_once('PEAR.php');
+require_once('Mail/mimePart.php');
+
+/**
+ * Mime mail composer class. Can handle: text and html bodies, embedded html
+ * images and attachments.
+ * Documentation and examples of this class are avaible here:
+ * http://pear.php.net/manual/
+ *
+ * @notes This class is based on HTML Mime Mail class from
+ *   Richard Heyes <richard@phpguru.org> which was based also
+ *   in the mime_mail.class by Tobias Ratschiller <tobias@dnet.it> and
+ *   Sascha Schumann <sascha@schumann.cx>
+ *
+ * @author   Richard Heyes <richard.heyes@heyes-computing.net>
+ * @author   Tomas V.V.Cox <cox@idecnet.com>
+ * @package  Mail
+ * @access   public
+ */
+class Mail_mime
+{
+    /**
+     * Contains the plain text part of the email
+     * @var string
+     */
+    var $_txtbody;
+    /**
+     * Contains the html part of the email
+     * @var string
+     */
+    var $_htmlbody;
+    /**
+     * contains the mime encoded text
+     * @var string
+     */
+    var $_mime;
+    /**
+     * contains the multipart content
+     * @var string
+     */
+    var $_multipart;
+    /**
+     * list of the attached images
+     * @var array
+     */
+    var $_html_images = array();
+    /**
+     * list of the attachements
+     * @var array
+     */
+    var $_parts = array();
+    /**
+     * Build parameters
+     * @var array
+     */
+    var $_build_params = array();
+    /**
+     * Headers for the mail
+     * @var array
+     */
+    var $_headers = array();
+    /**
+     * End Of Line sequence (for serialize)
+     * @var string
+     */
+    var $_eol;
+
+
+    /**
+     * Constructor function
+     *
+     * @access public
+     */
+    function Mail_mime($crlf = "\r\n")
+    {
+        $this->_setEOL($crlf);
+        $this->_build_params = array(
+                                     'text_encoding' => '7bit',
+                                     'html_encoding' => 'quoted-printable',
+                                     '7bit_wrap'     => 998,
+                                     'html_charset'  => 'ISO-8859-1',
+                                     'text_charset'  => 'ISO-8859-1',
+                                     'head_charset'  => 'ISO-8859-1'
+                                    );
+    }
+
+    /**
+     * Wakeup (unserialize) - re-sets EOL constant
+     *
+     * @access private
+     */
+    function __wakeup()
+    {
+        $this->_setEOL($this->_eol);
+    }
+
+    /**
+     * Accessor function to set the body text. Body text is used if
+     * it's not an html mail being sent or else is used to fill the
+     * text/plain part that emails clients who don't support
+     * html should show.
+     *
+     * @param  string  $data   Either a string or
+     *                         the file name with the contents
+     * @param  bool    $isfile If true the first param should be treated
+     *                         as a file name, else as a string (default)
+     * @param  bool    $append If true the text or file is appended to
+     *                         the existing body, else the old body is
+     *                         overwritten
+     * @return mixed   true on success or PEAR_Error object
+     * @access public
+     */
+    function setTXTBody($data, $isfile = false, $append = false)
+    {
+        if (!$isfile) {
+            if (!$append) {
+                $this->_txtbody = $data;
+            } else {
+                $this->_txtbody .= $data;
+            }
+        } else {
+            $cont = $this->_file2str($data);
+            if (PEAR::isError($cont)) {
+                return $cont;
+            }
+            if (!$append) {
+                $this->_txtbody = $cont;
+            } else {
+                $this->_txtbody .= $cont;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Adds a html part to the mail
+     *
+     * @param  string  $data   Either a string or the file name with the
+     *                         contents
+     * @param  bool    $isfile If true the first param should be treated
+     *                         as a file name, else as a string (default)
+     * @return mixed   true on success or PEAR_Error object
+     * @access public
+     */
+    function setHTMLBody($data, $isfile = false)
+    {
+        if (!$isfile) {
+            $this->_htmlbody = $data;
+        } else {
+            $cont = $this->_file2str($data);
+            if (PEAR::isError($cont)) {
+                return $cont;
+            }
+            $this->_htmlbody = $cont;
+        }
+
+        return true;
+    }
+
+    /**
+     * Adds an image to the list of embedded images.
+     *
+     * @param  string  $file       The image file name OR image data itself
+     * @param  string  $c_type     The content type
+     * @param  string  $name       The filename of the image.
+     *                             Only use if $file is the image data
+     * @param  bool    $isfilename Whether $file is a filename or not
+     *                             Defaults to true
+     * @return mixed   true on success or PEAR_Error object
+     * @access public
+     */
+    function addHTMLImage($file, $c_type='application/octet-stream',
+                          $name = '', $isfilename = true)
+    {
+        $filedata = ($isfilename === true) ? $this->_file2str($file)
+                                           : $file;
+        if ($isfilename === true) {
+            $filename = ($name == '' ? basename($file) : basename($name));
+        } else {
+            $filename = basename($name);
+        }
+        if (PEAR::isError($filedata)) {
+            return $filedata;
+        }
+        $this->_html_images[] = array(
+                                      'body'   => $filedata,
+                                      'name'   => $filename,
+                                      'c_type' => $c_type,
+                                      'cid'    => md5(uniqid(time()))
+                                     );
+        return true;
+    }
+
+    /**
+     * Adds a file to the list of attachments.
+     *
+     * @param  string  $file       The file name of the file to attach
+     *                             OR the file data itself
+     * @param  string  $c_type     The content type
+     * @param  string  $name       The filename of the attachment
+     *                             Only use if $file is the file data
+     * @param  bool    $isFilename Whether $file is a filename or not
+     *                             Defaults to true
+     * @return mixed true on success or PEAR_Error object
+     * @access public
+     */
+    function addAttachment($file, $c_type = 'application/octet-stream',
+                           $name = '', $isfilename = true,
+                           $encoding = 'base64')
+    {
+        $filedata = ($isfilename === true) ? $this->_file2str($file)
+                                           : $file;
+        if ($isfilename === true) {
+            // Force the name the user supplied, otherwise use $file
+            $filename = (!empty($name)) ? $name : $file;
+        } else {
+            $filename = $name;
+        }
+        if (empty($filename)) {
+            return PEAR::raiseError(
+              'The supplied filename for the attachment can\'t be empty'
+            );
+        }
+        $filename = basename($filename);
+        if (PEAR::isError($filedata)) {
+            return $filedata;
+        }
+
+        $this->_parts[] = array(
+                                'body'     => $filedata,
+                                'name'     => $filename,
+                                'c_type'   => $c_type,
+                                'encoding' => $encoding
+                               );
+        return true;
+    }
+
+    /**
+     * Get the contents of the given file name as string
+     *
+     * @param  string  $file_name  path of file to process
+     * @return string  contents of $file_name
+     * @access private
+     */
+    function &_file2str($file_name)
+    {
+        if (!is_readable($file_name)) {
+            return PEAR::raiseError('File is not readable ' . $file_name);
+        }
+        if (!$fd = fopen($file_name, 'rb')) {
+            return PEAR::raiseError('Could not open ' . $file_name);
+        }
+        $filesize = filesize($file_name);
+        if ($filesize == 0){
+            $cont =  "";
+        }else{
+            $cont = fread($fd, $filesize);
+        }
+        fclose($fd);
+        return $cont;
+    }
+
+    /**
+     * Adds a text subpart to the mimePart object and
+     * returns it during the build process.
+     *
+     * @param mixed    The object to add the part to, or
+     *                 null if a new object is to be created.
+     * @param string   The text to add.
+     * @return object  The text mimePart object
+     * @access private
+     */
+    function &_addTextPart(&$obj, $text)
+    {
+        $params['content_type'] = 'text/plain';
+        $params['encoding']     = $this->_build_params['text_encoding'];
+        $params['charset']      = $this->_build_params['text_charset'];
+        if (is_object($obj)) {
+            return $obj->addSubpart($text, $params);
+        } else {
+            return new Mail_mimePart($text, $params);
+        }
+    }
+
+    /**
+     * Adds a html subpart to the mimePart object and
+     * returns it during the build process.
+     *
+     * @param  mixed   The object to add the part to, or
+     *                 null if a new object is to be created.
+     * @return object  The html mimePart object
+     * @access private
+     */
+    function &_addHtmlPart(&$obj)
+    {
+        $params['content_type'] = 'text/html';
+        $params['encoding']     = $this->_build_params['html_encoding'];
+        $params['charset']      = $this->_build_params['html_charset'];
+        if (is_object($obj)) {
+            return $obj->addSubpart($this->_htmlbody, $params);
+        } else {
+            return new Mail_mimePart($this->_htmlbody, $params);
+        }
+    }
+
+    /**
+     * Creates a new mimePart object, using multipart/mixed as
+     * the initial content-type and returns it during the
+     * build process.
+     *
+     * @return object  The multipart/mixed mimePart object
+     * @access private
+     */
+    function &_addMixedPart()
+    {
+        $params['content_type'] = 'multipart/mixed';
+        return new Mail_mimePart('', $params);
+    }
+
+    /**
+     * Adds a multipart/alternative part to a mimePart
+     * object (or creates one), and returns it during
+     * the build process.
+     *
+     * @param  mixed   The object to add the part to, or
+     *                 null if a new object is to be created.
+     * @return object  The multipart/mixed mimePart object
+     * @access private
+     */
+    function &_addAlternativePart(&$obj)
+    {
+        $params['content_type'] = 'multipart/alternative';
+        if (is_object($obj)) {
+            return $obj->addSubpart('', $params);
+        } else {
+            return new Mail_mimePart('', $params);
+        }
+    }
+
+    /**
+     * Adds a multipart/related part to a mimePart
+     * object (or creates one), and returns it during
+     * the build process.
+     *
+     * @param mixed    The object to add the part to, or
+     *                 null if a new object is to be created
+     * @return object  The multipart/mixed mimePart object
+     * @access private
+     */
+    function &_addRelatedPart(&$obj)
+    {
+        $params['content_type'] = 'multipart/related';
+        if (is_object($obj)) {
+            return $obj->addSubpart('', $params);
+        } else {
+            return new Mail_mimePart('', $params);
+        }
+    }
+
+    /**
+     * Adds an html image subpart to a mimePart object
+     * and returns it during the build process.
+     *
+     * @param  object  The mimePart to add the image to
+     * @param  array   The image information
+     * @return object  The image mimePart object
+     * @access private
+     */
+    function &_addHtmlImagePart(&$obj, $value)
+    {
+        $params['content_type'] = $value['c_type'];
+        $params['encoding']     = 'base64';
+        $params['disposition']  = 'inline';
+        $params['dfilename']    = $value['name'];
+        $params['cid']          = $value['cid'];
+        $obj->addSubpart($value['body'], $params);
+    }
+
+    /**
+     * Adds an attachment subpart to a mimePart object
+     * and returns it during the build process.
+     *
+     * @param  object  The mimePart to add the image to
+     * @param  array   The attachment information
+     * @return object  The image mimePart object
+     * @access private
+     */
+    function &_addAttachmentPart(&$obj, $value)
+    {
+        $params['content_type'] = $value['c_type'];
+        $params['encoding']     = $value['encoding'];
+        $params['disposition']  = 'attachment';
+        $params['dfilename']    = $value['name'];
+        $obj->addSubpart($value['body'], $params);
+    }
+
+    /**
+     * Builds the multipart message from the list ($this->_parts) and
+     * returns the mime content.
+     *
+     * @param  array  Build parameters that change the way the email
+     *                is built. Should be associative. Can contain:
+     *                text_encoding  -  What encoding to use for plain text
+     *                                  Default is 7bit
+     *                html_encoding  -  What encoding to use for html
+     *                                  Default is quoted-printable
+     *                7bit_wrap      -  Number of characters before text is
+     *                                  wrapped in 7bit encoding
+     *                                  Default is 998
+     *                html_charset   -  The character set to use for html.
+     *                                  Default is iso-8859-1
+     *                text_charset   -  The character set to use for text.
+     *                                  Default is iso-8859-1
+     *                head_charset   -  The character set to use for headers.
+     *                                  Default is iso-8859-1
+     * @return string The mime content
+     * @access public
+     */
+    function &get($build_params = null)
+    {
+        if (isset($build_params)) {
+            while (list($key, $value) = each($build_params)) {
+                $this->_build_params[$key] = $value;
+            }
+        }
+
+        if (!empty($this->_html_images) AND isset($this->_htmlbody)) {
+            foreach ($this->_html_images as $value) {
+                $regex = '#(\s)((?i)src|background|href(?-i))\s*=\s*(["\']?)' . preg_quote($value['name'], '#') .
+                         '\3#';
+                $rep = '\1\2=\3cid:' . $value['cid'] .'\3';
+                $this->_htmlbody = preg_replace($regex, $rep,
+                                       $this->_htmlbody
+                                   );
+            }
+        }
+
+        $null        = null;
+        $attachments = !empty($this->_parts)                ? true : false;
+        $html_images = !empty($this->_html_images)          ? true : false;
+        $html        = !empty($this->_htmlbody)             ? true : false;
+        $text        = (!$html AND !empty($this->_txtbody)) ? true : false;
+
+        switch (true) {
+        case $text AND !$attachments:
+            $message =& $this->_addTextPart($null, $this->_txtbody);
+            break;
+
+        case !$text AND !$html AND $attachments:
+            $message =& $this->_addMixedPart();
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        case $text AND $attachments:
+            $message =& $this->_addMixedPart();
+            $this->_addTextPart($message, $this->_txtbody);
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        case $html AND !$attachments AND !$html_images:
+            if (isset($this->_txtbody)) {
+                $message =& $this->_addAlternativePart($null);
+                $this->_addTextPart($message, $this->_txtbody);
+                $this->_addHtmlPart($message);
+            } else {
+                $message =& $this->_addHtmlPart($null);
+            }
+            break;
+
+        case $html AND !$attachments AND $html_images:
+            if (isset($this->_txtbody)) {
+                $message =& $this->_addAlternativePart($null);
+                $this->_addTextPart($message, $this->_txtbody);
+                $related =& $this->_addRelatedPart($message);
+            } else {
+                $message =& $this->_addRelatedPart($null);
+                $related =& $message;
+            }
+            $this->_addHtmlPart($related);
+            for ($i = 0; $i < count($this->_html_images); $i++) {
+                $this->_addHtmlImagePart($related, $this->_html_images[$i]);
+            }
+            break;
+
+        case $html AND $attachments AND !$html_images:
+            $message =& $this->_addMixedPart();
+            if (isset($this->_txtbody)) {
+                $alt =& $this->_addAlternativePart($message);
+                $this->_addTextPart($alt, $this->_txtbody);
+                $this->_addHtmlPart($alt);
+            } else {
+                $this->_addHtmlPart($message);
+            }
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        case $html AND $attachments AND $html_images:
+            $message =& $this->_addMixedPart();
+            if (isset($this->_txtbody)) {
+                $alt =& $this->_addAlternativePart($message);
+                $this->_addTextPart($alt, $this->_txtbody);
+                $rel =& $this->_addRelatedPart($alt);
+            } else {
+                $rel =& $this->_addRelatedPart($message);
+            }
+            $this->_addHtmlPart($rel);
+            for ($i = 0; $i < count($this->_html_images); $i++) {
+                $this->_addHtmlImagePart($rel, $this->_html_images[$i]);
+            }
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        }
+
+        if (isset($message)) {
+            $output = $message->encode();
+            $this->_headers = array_merge($this->_headers,
+                                          $output['headers']);
+            return $output['body'];
+
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Returns an array with the headers needed to prepend to the email
+     * (MIME-Version and Content-Type). Format of argument is:
+     * $array['header-name'] = 'header-value';
+     *
+     * @param  array $xtra_headers Assoc array with any extra headers.
+     *                             Optional.
+     * @return array Assoc array with the mime headers
+     * @access public
+     */
+    function &headers($xtra_headers = null)
+    {
+        // Content-Type header should already be present,
+        // So just add mime version header
+        $headers['MIME-Version'] = '1.0';
+        if (isset($xtra_headers)) {
+            $headers = array_merge($headers, $xtra_headers);
+        }
+        $this->_headers = array_merge($headers, $this->_headers);
+
+        return $this->_encodeHeaders($this->_headers);
+    }
+
+    /**
+     * Get the text version of the headers
+     * (usefull if you want to use the PHP mail() function)
+     *
+     * @param  array   $xtra_headers Assoc array with any extra headers.
+     *                               Optional.
+     * @return string  Plain text headers
+     * @access public
+     */
+    function txtHeaders($xtra_headers = null)
+    {
+        $headers = $this->headers($xtra_headers);
+        $ret = '';
+        foreach ($headers as $key => $val) {
+            $ret .= "$key: $val" . MAIL_MIME_CRLF;
+        }
+        return $ret;
+    }
+
+    /**
+     * Sets the Subject header
+     *
+     * @param  string $subject String to set the subject to
+     * access  public
+     */
+    function setSubject($subject)
+    {
+        $this->_headers['Subject'] = $subject;
+    }
+
+    /**
+     * Set an email to the From (the sender) header
+     *
+     * @param  string $email The email direction to add
+     * @access public
+     */
+    function setFrom($email)
+    {
+        $this->_headers['From'] = $email;
+    }
+
+    /**
+     * Add an email to the Cc (carbon copy) header
+     * (multiple calls to this method are allowed)
+     *
+     * @param  string $email The email direction to add
+     * @access public
+     */
+    function addCc($email)
+    {
+        if (isset($this->_headers['Cc'])) {
+            $this->_headers['Cc'] .= ", $email";
+        } else {
+            $this->_headers['Cc'] = $email;
+        }
+    }
+
+    /**
+     * Add an email to the Bcc (blank carbon copy) header
+     * (multiple calls to this method are allowed)
+     *
+     * @param  string $email The email direction to add
+     * @access public
+     */
+    function addBcc($email)
+    {
+        if (isset($this->_headers['Bcc'])) {
+            $this->_headers['Bcc'] .= ", $email";
+        } else {
+            $this->_headers['Bcc'] = $email;
+        }
+    }
+
+    /**
+     * Encodes a header as per RFC2047
+     *
+     * @param  string  $input The header data to encode
+     * @return string  Encoded data
+     * @access private
+     */
+    function _encodeHeaders($input)
+    {
+        foreach ($input as $hdr_name => $hdr_value) {
+            preg_match_all('/(\w*[\x80-\xFF]+\w*)/', $hdr_value, $matches);
+            foreach ($matches[1] as $value) {
+                $replacement = preg_replace('/([\x80-\xFF])/e',
+                                            '"=" .
+                                            strtoupper(dechex(ord("\1")))',
+                                            $value);
+                $hdr_value = str_replace($value, '=?' .
+                                         $this->_build_params['head_charset'] .
+                                         '?Q?' . $replacement . '?=',
+                                         $hdr_value);
+            }
+            $input[$hdr_name] = $hdr_value;
+        }
+
+        return $input;
+    }
+
+    /**
+     * Set the object's end-of-line and define the constant if applicable
+     *
+     * @param string $eol End Of Line sequence
+     * @access private
+     */
+    function _setEOL($eol)
+    {
+        $this->_eol = $eol;
+        if (!defined('MAIL_MIME_CRLF')) {
+            define('MAIL_MIME_CRLF', $this->_eol, true);
+        }
+    }
+
+    
+
+} // End of class
+?>
diff -Nur mantis-0.19.4.orig/manage_proj_cat_edit_page.php mantis-0.19.4/manage_proj_cat_edit_page.php
--- mantis-0.19.4.orig/manage_proj_cat_edit_page.php	2004-04-12 23:04:35.000000000 +0200
+++ mantis-0.19.4/manage_proj_cat_edit_page.php	2005-12-23 13:56:09.000000000 +0100
@@ -15,6 +15,7 @@
 	$t_core_path = config_get( 'core_path' );
 	
 	require_once( $t_core_path.'category_api.php' );
+	require_once( $t_core_path.'mail_api.php' );
 ?>
 <?php
 	$f_project_id	= gpc_get_int( 'project_id' );
@@ -24,6 +25,10 @@
 
 	$t_row = category_get_row( $f_project_id, $f_category );
 	$t_assigned_to = $t_row['user_id'];
+	$t_mail = mail_get_account_data( $f_project_id );
+	if ( $t_mail['pop3_categories'] ) {
+		$t_category_mail = mail_category_get_account_data( $f_project_id, $f_category );
+	}
 ?>
 <?php html_page_top1() ?>
 <?php html_page_top2() ?>
@@ -84,4 +89,59 @@
 	</form>
 </div>
 
+<?php  if ( $t_mail['pop3_categories'] ) { ?>
+<!-- MAIL ACCOUNT CHANGE -->
+<br />
+<div align="center">
+	<form method="post" action="manage_proj_cat_mail_update.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="category" value="<?php echo string_attribute( $f_category ) ?>" />
+		<table class="width75" cellspacing="1">
+			<tr>
+				<td class="form-title" colspan="4">
+					<?php echo 'Category Mail Account Settings' ?>
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Host"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_host" size="64" maxlength="255" value="<?php echo string_attribute( $t_category_mail['pop3_host'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 User"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_user" size="64" maxlength="255" value="<?php echo string_attribute( $t_category_mail['pop3_user'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Password"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_pass" size="64" maxlength="255" value="<?php echo string_attribute( $t_category_mail['pop3_pass'] ) ?>" />
+				</td>
+			</tr>
+			<tr>
+			<td colspan="2">
+				<input type="submit" value="<?php echo 'Set Mail Account Data' ?>" />
+				</td>
+			</tr>
+		</table>
+	</form>
+</div>
+<!-- MAIL ACCOUNT RESET -->
+<div class="border-center">
+	<form method="post" action="manage_proj_cat_mail_delete.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="category" value="<?php echo string_attribute( $f_category ) ?>" />
+		<input type="submit" value="<?php echo 'Delete Mail Account Data' ?>" />
+	</form>
+</div>
+<?php } ?>
+ 
 <?php html_page_bottom1( __FILE__ ) ?>
diff -Nur mantis-0.19.4.orig/manage_proj_cat_mail_delete.php mantis-0.19.4/manage_proj_cat_mail_delete.php
--- mantis-0.19.4.orig/manage_proj_cat_mail_delete.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/manage_proj_cat_mail_delete.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,44 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_category	= gpc_get_string( 'category' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	mail_category_delete( $f_project_id, $f_category );
+
+	$t_redirect_url = 'manage_proj_cat_edit_page.php?project_id=' . $f_project_id . '&category=' . $f_category;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff -Nur mantis-0.19.4.orig/manage_proj_cat_mail_update.php mantis-0.19.4/manage_proj_cat_mail_update.php
--- mantis-0.19.4.orig/manage_proj_cat_mail_update.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/manage_proj_cat_mail_update.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,59 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_pop3_host	= gpc_get_string( 'pop3_host' );
+	$f_pop3_user	= gpc_get_string( 'pop3_user' );
+	$f_pop3_pass	= gpc_get_string( 'pop3_pass' );
+	$f_category	= gpc_get_string( 'category' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	if ( is_blank( $f_pop3_host ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+	else {
+		if ( is_blank( $f_pop3_user ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+		if ( is_blank( $f_pop3_pass ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+		}
+	}
+
+	mail_category_update( $f_project_id, $f_category, $f_pop3_host, $f_pop3_user, $f_pop3_pass );
+
+	$t_redirect_url = 'manage_proj_cat_edit_page.php?project_id=' . $f_project_id . '&category=' . $f_category;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff -Nur mantis-0.19.4.orig/manage_proj_edit_page.php mantis-0.19.4/manage_proj_edit_page.php
--- mantis-0.19.4.orig/manage_proj_edit_page.php	2004-09-22 12:15:33.000000000 +0200
+++ mantis-0.19.4/manage_proj_edit_page.php	2005-12-23 13:56:09.000000000 +0100
@@ -18,6 +18,7 @@
 	require_once( $t_core_path . 'version_api.php' );
 	require_once( $t_core_path . 'custom_field_api.php' );
 	require_once( $t_core_path . 'icon_api.php' );
+	require_once( $t_core_path . 'mail_api.php' );
 ?>
 <?php
 	$f_project_id = gpc_get_int( 'project_id' );
@@ -25,6 +26,7 @@
 	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
 
 	$row = project_get_row( $f_project_id );
+	$mail = mail_get_account_data( $f_project_id );
 ?>
 <?php html_page_top1() ?>
 <?php html_page_top2() ?>
@@ -551,4 +553,76 @@
 	</table>
 </div>
 
+<?php  if ( ! $mail['pop3_categories'] ) { ?>
+<!-- MAIL ACCOUNT CHANGE -->
+<br />
+<div align="center">
+	<form method="post" action="manage_proj_mail_update.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<table class="width75" cellspacing="1">
+			<tr>
+				<td class="form-title" colspan="4">
+					<?php echo 'Mail Account Settings' ?>
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Host"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_host" size="64" maxlength="255" value="<?php echo string_attribute( $mail['pop3_host'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 User"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_user" size="64" maxlength="255" value="<?php echo string_attribute( $mail['pop3_user'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Password"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_pass" size="64" maxlength="255" value="<?php echo string_attribute( $mail['pop3_pass'] ) ?>" />
+				</td>
+			</tr>
+			<tr>
+				<td colspan="2">
+					<input type="submit" value="<?php echo 'Set Mail Account Data' ?>" />
+				</td>
+			</tr>
+		</table>
+	</form>
+</div>
+<!-- MAIL ACCOUNT RESET -->
+<div class="border-center">
+	<form method="post" action="manage_proj_mail_delete.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="submit" value="<?php echo 'Delete Mail Account Data' ?>" />
+	</form>
+</div>
+<br />
+<!-- MAIL ACCOUNT CATEGORIES -->
+<div class="border-center">
+	<form method="post" action="manage_proj_mail_categories.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="categories" value="On" />
+		<input type="submit" value="<?php echo 'Activate Mail Account per Category' ?>" />
+	</form>
+</div>
+<?php } else { ?>
+<!-- MAIL ACCOUNT CATEGORIES -->
+<div class="border-center">
+	<form method="post" action="manage_proj_mail_categories.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="categories" value="Off" />
+		<input type="submit" value="<?php echo 'Deactivate Mail Account per Category' ?>" />
+	</form>
+</div>
+<?php } ?>
+
+
 <?php html_page_bottom1( __FILE__ ) ?>
diff -Nur mantis-0.19.4.orig/manage_proj_mail_categories.php mantis-0.19.4/manage_proj_mail_categories.php
--- mantis-0.19.4.orig/manage_proj_mail_categories.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/manage_proj_mail_categories.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,43 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_activate	= gpc_get_string( 'categories' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	mail_categories( $f_project_id, $f_activate );
+
+	$t_redirect_url = 'manage_proj_edit_page.php?project_id=' . $f_project_id;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff -Nur mantis-0.19.4.orig/manage_proj_mail_delete.php mantis-0.19.4/manage_proj_mail_delete.php
--- mantis-0.19.4.orig/manage_proj_mail_delete.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/manage_proj_mail_delete.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,43 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	mail_delete( $f_project_id );
+
+	$t_redirect_url = 'manage_proj_edit_page.php?project_id=' . $f_project_id;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff -Nur mantis-0.19.4.orig/manage_proj_mail_update.php mantis-0.19.4/manage_proj_mail_update.php
--- mantis-0.19.4.orig/manage_proj_mail_update.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/manage_proj_mail_update.php	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,58 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_pop3_host	= gpc_get_string( 'pop3_host' );
+	$f_pop3_user	= gpc_get_string( 'pop3_user' );
+	$f_pop3_pass	= gpc_get_string( 'pop3_pass' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	if ( is_blank( $f_pop3_host ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+	else {
+		if ( is_blank( $f_pop3_user ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+		if ( is_blank( $f_pop3_pass ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+		}
+	}
+
+	mail_update( $f_project_id, $f_pop3_host, $f_pop3_user, $f_pop3_pass );
+
+	$t_redirect_url = 'manage_proj_edit_page.php?project_id=' . $f_project_id;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff -Nur mantis-0.19.4.orig/Net/POP3.php mantis-0.19.4/Net/POP3.php
--- mantis-0.19.4.orig/Net/POP3.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/Net/POP3.php	2005-04-05 04:17:41.000000000 +0200
@@ -0,0 +1,1226 @@
+<?php
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002, Richard Heyes                                     |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// | Co-Author: Damian Fernandez Sosa <damlists@cnba.uba.ar>               |
+// +-----------------------------------------------------------------------+
+//
+// $Id: POP3.php,v 1.2 2004/12/05 16:34:39 damian Exp $
+
+require_once('Net/Socket.php');
+
+
+
+/**
+*  +----------------------------- IMPORTANT ------------------------------+
+*  | Usage of this class compared to native php extensions such as IMAP   |
+*  | is slow and may be feature deficient. If available you are STRONGLY  |
+*  | recommended to use the php extensions.                               |
+*  +----------------------------------------------------------------------+
+*
+* POP3 Access Class
+*
+* For usage see the example script
+*/
+
+define('NET_POP3_STATE_DISCONNECTED',  1, true);
+define('NET_POP3_STATE_AUTHORISATION', 2, true);
+define('NET_POP3_STATE_TRANSACTION',   4, true);
+
+class Net_POP3 {
+
+    /*
+    * Some basic information about the mail drop
+    * garnered from the STAT command
+    *
+    * @var array
+    */
+    var $_maildrop;
+
+    /*
+    * Used for APOP to store the timestamp
+    *
+    * @var string
+    */
+    var $_timestamp;
+
+    /*
+    * Timeout that is passed to the socket object
+    *
+    * @var integer
+    */
+    var $_timeout;
+
+    /*
+    * Socket object
+    *
+    * @var object
+    */
+    var $_socket;
+
+    /*
+    * Current state of the connection. Used with the
+    * constants defined above.
+    *
+    * @var integer
+    */
+    var $_state;
+
+    /*
+    * Hostname to connect to
+    *
+    * @var string
+    */
+    var $_host;
+
+    /*
+    * Port to connect to
+    *
+    * @var integer
+    */
+    var $_port;
+
+    /**
+    * To allow class debuging
+    * @var boolean
+    */
+    var $_debug = false;
+
+
+    /**
+    * The auth methods this class support
+    * @var array
+    */
+    //var $supportedAuthMethods=array('DIGEST-MD5', 'CRAM-MD5', 'APOP' , 'PLAIN' , 'LOGIN', 'USER');
+    //Disabling DIGEST-MD5 for now
+    var $supportedAuthMethods=array( 'CRAM-MD5', 'APOP' , 'PLAIN' , 'LOGIN', 'USER');
+    //var $supportedAuthMethods=array( 'CRAM-MD5', 'PLAIN' , 'LOGIN');
+    //var $supportedAuthMethods=array( 'PLAIN' , 'LOGIN');
+
+
+    /**
+    * The auth methods this class support
+    * @var array
+    */
+    var $supportedSASLAuthMethods=array('DIGEST-MD5', 'CRAM-MD5');
+
+
+    /**
+    * The capability response
+    * @var array
+    */
+    var $_capability;
+
+   /*
+    * Constructor. Sets up the object variables, and instantiates
+    * the socket object.
+    *
+    */
+
+
+    function Net_POP3()
+    {
+        $this->_timestamp =  ''; // Used for APOP
+        $this->_maildrop  =  array();
+        $this->_timeout   =  3;
+        $this->_state     =  NET_POP3_STATE_DISCONNECTED;
+        $this->_socket    =& new Net_Socket();
+        /*
+        * Include the Auth_SASL package.  If the package is not available,
+        * we disable the authentication methods that depend upon it.
+        */
+        if ((@include_once 'Auth/SASL.php') == false) {
+            if($this->_debug){
+                echo "AUTH_SASL NOT PRESENT!\n";
+            }
+            foreach($this->supportedSASLAuthMethods as $SASLMethod){
+                $pos = array_search( $SASLMethod, $this->supportedAuthMethods );
+                if($this->_debug){
+                    echo "DISABLING METHOD $SASLMethod\n";
+                }
+                unset($this->supportedAuthMethods[$pos]);
+            }
+        }
+
+
+
+    }
+
+
+    /**
+    * Handles the errors the class can find
+    * on the server
+    *
+    * @access private
+    * @return PEAR_Error
+    */
+
+    function _raiseError($msg, $code =-1)
+    {
+    include_once 'PEAR.php';
+    return PEAR::raiseError($msg, $code);
+    }
+
+
+    
+    /*
+    * Connects to the given host on the given port.
+    * Also looks for the timestamp in the greeting
+    * needed for APOP authentication
+    *
+    * @param  string $host Hostname/IP address to connect to
+    * @param  string $port Port to use to connect to on host
+    * @return bool  Success/Failure
+    */
+    function connect($host = 'localhost', $port = 110)
+    {
+        $this->_host = $host;
+        $this->_port = $port;
+
+        $result = $this->_socket->connect($host, $port, false, $this->_timeout);
+        if ($result === true) {
+            $data = $this->_recvLn();
+
+            if( $this->_checkResponse($data) ){
+            // if the response begins with '+OK' ...
+//            if (@substr(strtoupper($data), 0, 3) == '+OK') {
+                // Check for string matching apop timestamp
+                if (preg_match('/<.+@.+>/U', $data, $matches)) {
+                    $this->_timestamp = $matches[0];
+                }
+                $this->_maildrop = array();
+                $this->_state    = NET_POP3_STATE_AUTHORISATION;
+
+                return true;
+            }
+        }
+
+        $this->_socket->disconnect();
+        return false;
+    }
+
+    /*
+    * Disconnect function. Sends the QUIT command
+    * and closes the socket.
+    *
+    * @return bool Success/Failure
+    */
+    function disconnect()
+    {
+        return $this->_cmdQuit();
+    }
+
+    /*
+    * Performs the login procedure. If there is a timestamp
+    * stored, APOP will be tried first, then basic USER/PASS.
+    *
+    * @param  string $user Username to use
+    * @param  string $pass Password to use
+    * @param  mixed $apop Whether to try APOP first, if used as string you can select the auth methd to use ( $pop3->login('validlogin', 'validpass', "CRAM-MD5");
+    *          Valid methods are: 'DIGEST-MD5','CRAM-MD5','LOGIN','PLAIN','APOP','USER' 
+    * @return mixed  true on Success/ PEAR_ERROR on error
+    */
+    function login($user, $pass, $apop = true)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+
+            if(PEAR::isError($ret= $this->_cmdAuthenticate($user , $pass , $apop ) ) ){
+                return $ret;
+            }
+            if( ! PEAR::isError($ret)){
+                $this->_state = NET_POP3_STATE_TRANSACTION;
+                return true;
+            }
+
+        }
+        return $this->_raiseError('Generic login error' , 1);
+    }
+
+
+
+    /**
+    * Parses the response from the capability command. Stores
+    * the result in $this->_capability
+    *
+    * @access private
+    */
+    function _parseCapability()
+    {
+
+        if(!PEAR::isError($data = $this->_sendCmd('CAPA'))){
+            $data = $this->_getMultiline();
+        }else {
+            // CAPA command not supported, reset data var
+            //  to avoid Notice errors of preg_split on an object
+            $data = '';
+        }
+        $data = preg_split('/\r?\n/', $data, -1, PREG_SPLIT_NO_EMPTY);
+
+        for ($i = 0; $i < count($data); $i++) {
+
+            $capa='';
+            if (preg_match('/^([a-z,\-]+)( ((.*))|$)$/i', $data[$i], $matches)) {
+
+                $capa=strtolower($matches[1]);
+                switch ($capa) {
+                    case 'implementation':
+                        $this->_capability['implementation'] = $matches[3];
+                        break;
+                    case 'sasl':
+                        $this->_capability['sasl'] = preg_split('/\s+/', $matches[3]);
+                        break;
+                    default :
+                        $this->_capability[$capa] = $matches[2];
+                        break;
+                }
+            }
+        }
+    }
+
+
+
+
+    /**
+     * Returns the name of the best authentication method that the server
+     * has advertised.
+     *
+     * @param string if !=null,authenticate with this method ($userMethod).
+     *
+     * @return mixed    Returns a string containing the name of the best
+     *                  supported authentication method or a PEAR_Error object
+     *                  if a failure condition is encountered.
+     * @access private
+     * @since  1.0
+     */
+    function _getBestAuthMethod($userMethod = null)
+    {
+
+/*
+       return 'USER';
+       return 'APOP';
+       return 'DIGEST-MD5';
+       return 'CRAM-MD5';
+*/
+
+
+        $this->_parseCapability();
+
+        //unset($this->_capability['sasl']);
+
+       if( isset($this->_capability['sasl']) ){
+           $serverMethods=$this->_capability['sasl'];
+       }else{
+            $serverMethods=array('USER');
+            // Check for timestamp before attempting APOP
+            if ($this->_timestamp != null)
+            {
+                $serverMethods[] = 'APOP';
+            }
+       }
+
+        if($userMethod !== null && $userMethod !== true ){
+            $methods = array();
+            $methods[] = $userMethod;
+            return $userMethod;
+        }else{
+            $methods = $this->supportedAuthMethods;
+        }
+
+        if( ($methods != null) && ($serverMethods != null)){
+
+            foreach ( $methods as $method ) {
+
+                if ( in_array( $method , $serverMethods ) ) {
+                    return $method;
+                }
+            }
+            $serverMethods=implode(',' , $serverMethods );
+            $myMethods=implode(',' ,$this->supportedAuthMethods);
+            return $this->_raiseError("$method NOT supported authentication method!. This server " .
+                "supports these methods: $serverMethods, but I support $myMethods");
+        }else{
+            return $this->_raiseError("This server don't support any Auth methods");
+        }
+    }
+
+
+
+
+
+
+    /* Handles the authentication using any known method
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     * @param string The method to use ( if $usermethod == '' then the class chooses the best method (the stronger is the best ) )
+     *
+     * @return mixed  string or PEAR_Error
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _cmdAuthenticate($uid , $pwd , $userMethod = null )
+    {
+
+
+        if ( PEAR::isError( $method = $this->_getBestAuthMethod($userMethod) ) ) {
+            return $method;
+        }
+
+        switch ($method) {
+            case 'DIGEST-MD5':
+                $result = $this->_authDigest_MD5( $uid , $pwd );
+                break;
+            case 'CRAM-MD5':
+                $result = $this->_authCRAM_MD5( $uid , $pwd );
+                break;
+            case 'LOGIN':
+                $result = $this->_authLOGIN( $uid , $pwd );
+                break;
+            case 'PLAIN':
+                $result = $this->_authPLAIN( $uid , $pwd );
+                break;
+            case 'APOP':
+                $result = $this->_cmdApop( $uid , $pwd );
+                // if APOP fails fallback to USER auth
+                if( PEAR::isError( $result ) ){
+                    //echo "APOP FAILED!!!\n";
+                    $result=$this->_authUSER( $uid , $pwd );
+                }
+                break;
+            case 'USER':
+                $result = $this->_authUSER( $uid , $pwd );
+            break;
+
+
+            default :
+                $result = $this->_raiseError( "$method is not a supported authentication method" );
+                break;
+        }
+        return $result;
+    }
+
+
+
+
+     /* Authenticates the user using the USER-PASS method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return mixed    true on success or PEAR_Error on failure
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authUSER($user, $pass  )
+    {
+        if ( PEAR::isError($ret=$this->_cmdUser($user) ) ){
+            return $ret;
+        }
+        if ( PEAR::isError($ret=$this->_cmdPass($pass) ) ){
+            return $ret;
+        }
+        return true;
+    }
+
+
+
+
+
+
+
+
+     /* Authenticates the user using the PLAIN method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authPLAIN($user, $pass  )
+    {
+        $cmd=sprintf('AUTH PLAIN %s', base64_encode( chr(0) . $user . chr(0) . $pass ) );
+
+        if ( PEAR::isError( $ret = $this->_send($cmd) ) ) {
+            return $ret;
+        }
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ){
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+        
+        return true;
+    }
+
+
+
+     /* Authenticates the user using the PLAIN method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authLOGIN($user, $pass  )
+    {
+        $this->_send('AUTH LOGIN');
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+
+        if ( PEAR::isError( $ret = $this->_send(sprintf('%s', base64_encode($user))) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+        if ( PEAR::isError( $ret = $this->_send(sprintf('%s', base64_encode($pass))) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        return $this->_checkResponse($challenge);
+    }
+
+
+
+
+
+     /* Authenticates the user using the CRAM-MD5 method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authCRAM_MD5($uid, $pwd )
+    {
+        if ( PEAR::isError( $ret = $this->_send( 'AUTH CRAM-MD5' ) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+        // remove '+ '
+        
+        $challenge=substr($challenge,2);
+        
+        $challenge = base64_decode( $challenge );
+
+        $cram = &Auth_SASL::factory('crammd5');
+        $auth_str = base64_encode( $cram->getResponse( $uid , $pwd , $challenge ) );
+
+
+        if ( PEAR::isError($error = $this->_send( $auth_str ) ) ) {
+            return $error;
+        }
+        if ( PEAR::isError( $ret = $this->_recvLn() ) ) {
+            return $ret;
+        }
+        //echo "RET:$ret\n";
+        return $this->_checkResponse($ret);
+    }
+
+
+
+     /* Authenticates the user using the DIGEST-MD5 method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     * @param string The efective user
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authDigest_MD5($uid, $pwd)
+    {
+        if ( PEAR::isError( $ret = $this->_send( 'AUTH DIGEST-MD5' ) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+        // remove '+ '
+        $challenge=substr($challenge,2);
+
+        $challenge = base64_decode( $challenge );
+        $digest = &Auth_SASL::factory('digestmd5');
+        $auth_str = base64_encode($digest->getResponse($uid, $pwd, $challenge, "localhost", "pop3" ));
+
+        if ( PEAR::isError($error = $this->_send( $auth_str ) ) ) {
+            return $error;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+         /*
+         * We don't use the protocol's third step because POP3 doesn't allow
+         * subsequent authentication, so we just silently ignore it.
+         */
+
+        if ( PEAR::isError( $challenge = $this->_send("\r\n") ) ) {
+            return $challenge ;
+        }
+        
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        
+        return $this->_checkResponse($challenge);
+        
+
+    }
+
+
+
+
+
+
+
+
+
+
+    /*
+    * Sends the APOP command
+    *
+    * @param  $user Username to send
+    * @param  $pass Password to send
+    * @return bool Success/Failure
+    */
+    function _cmdApop($user, $pass)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+
+            if (!empty($this->_timestamp)) {
+                if(PEAR::isError($data = $this->_sendCmd('APOP ' . $user . ' ' . md5($this->_timestamp . $pass)) ) ){
+                    return $data;
+                }
+                $this->_state = NET_POP3_STATE_TRANSACTION;
+                return true;
+            }
+        }
+        return $this->_raiseError('Not In NET_POP3_STATE_AUTHORISATION State1');
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /*
+    * Returns the raw headers of the specified message.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either raw headers or false on error
+    */
+    function getRawHeaders($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_cmdTop($msg_id, 0);
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the  headers of the specified message in an
+    * associative array. Array keys are the header names, array
+    * values are the header values. In the case of multiple headers
+    * having the same names, eg Received:, the array value will be
+    * an indexed array of all the header values.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either array of headers or false on error
+    */
+    function getParsedHeaders($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+
+            $raw_headers = rtrim($this->getRawHeaders($msg_id));
+
+            $raw_headers = preg_replace("/\r\n[ \t]+/", ' ', $raw_headers); // Unfold headers
+            $raw_headers = explode("\r\n", $raw_headers);
+            foreach ($raw_headers as $value) {
+                $name  = substr($value, 0, $pos = strpos($value, ':'));
+                $value = ltrim(substr($value, $pos + 1));
+                if (isset($headers[$name]) AND is_array($headers[$name])) {
+                    $headers[$name][] = $value;
+                } elseif (isset($headers[$name])) {
+                    $headers[$name] = array($headers[$name], $value);
+                } else {
+                    $headers[$name] = $value;
+                }
+            }
+
+            return $headers;
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the body of the message with given message number.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either message body or false on error
+    */
+    function getBody($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            $msg = $this->_cmdRetr($msg_id);
+            return substr($msg, strpos($msg, "\r\n\r\n")+4);
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the entire message with given message number.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either entire message or false on error
+    */
+    function getMsg($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_cmdRetr($msg_id);
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the size of the maildrop
+    *
+    * @return mixed Either size of maildrop or false on error
+    */
+    function getSize()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (isset($this->_maildrop['size'])) {
+                return $this->_maildrop['size'];
+            } else {
+                list(, $size) = $this->_cmdStat();
+                return $size;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns number of messages in this maildrop
+    *
+    * @return mixed Either number of messages or false on error
+    */
+    function numMsg()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (isset($this->_maildrop['num_msg'])) {
+                return $this->_maildrop['num_msg'];
+            } else {
+                list($num_msg, ) = $this->_cmdStat();
+                return $num_msg;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Marks a message for deletion. Only will be deleted if the
+    * disconnect() method is called.
+    *
+    * @param  integer $msg_id Message to delete
+    * @return bool Success/Failure
+    */
+    function deleteMsg($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_cmdDele($msg_id);
+        }
+
+        return false;
+    }
+
+    /*
+    * Combination of LIST/UIDL commands, returns an array
+    * of data
+    *
+    * @param  integer $msg_id Optional message number
+    * @return mixed Array of data or false on error
+    */
+    function getListing($msg_id = null)
+    {
+    
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (!isset($msg_id)){
+            
+                $list=array();
+                if ($list = $this->_cmdList()) {
+                    if ($uidl = $this->_cmdUidl()) {
+                        foreach ($uidl as $i => $value) {
+                            $list[$i]['uidl'] = $value['uidl'];
+                        }
+                    }
+                    return $list;
+                }else{
+                    return array();
+                }
+            } else {
+                if ($list = $this->_cmdList($msg_id) AND $uidl = $this->_cmdUidl($msg_id)) {
+                    return array_merge($list, $uidl);
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the USER command
+    *
+    * @param  string $user Username to send
+    * @return bool  Success/Failure
+    */
+    function _cmdUser($user)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+            return $this->_sendCmd('USER ' . $user);
+        }
+        return $this->_raiseError('Not In NET_POP3_STATE_AUTHORISATION State');
+    }
+
+
+    /*
+    * Sends the PASS command
+    *
+    * @param  string $pass Password to send
+    * @return bool  Success/Failure
+    */
+    function _cmdPass($pass)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+            return $this->_sendCmd('PASS ' . $pass);
+        }
+        return $this->_raiseError('Not In NET_POP3_STATE_AUTHORISATION State');
+    }
+
+
+    /*
+    * Sends the STAT command
+    *
+    * @return mixed Indexed array of number of messages and
+    *               maildrop size, or false on error.
+    */
+    function _cmdStat()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('STAT'))){
+                sscanf($data, '+OK %d %d', $msg_num, $size);
+                $this->_maildrop['num_msg'] = $msg_num;
+                $this->_maildrop['size']    = $size;
+
+                return array($msg_num, $size);
+            }
+        }
+        return false;
+    }
+
+
+    /*
+    * Sends the LIST command
+    *
+    * @param  integer $msg_id Optional message number
+    * @return mixed   Indexed array of msg_id/msg size or
+    *                 false on error
+    */
+    function _cmdList($msg_id = null)
+    {
+        $return=array();
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (!isset($msg_id)) {
+                if(!PEAR::isError($data = $this->_sendCmd('LIST') )){
+                    $data = $this->_getMultiline();
+                    $data = explode("\r\n", $data);                    
+                    foreach ($data as $line) {
+                        if($line !=''){
+                            sscanf($line, '%s %s', $msg_id, $size);
+                            $return[] = array('msg_id' => $msg_id, 'size' => $size);
+                        }
+                    }
+                    return $return;
+                }
+            } else {
+                if(!PEAR::isError($data = $this->_sendCmd('LIST ' . $msg_id))){
+                    if($data!=''){
+                        sscanf($data, '+OK %d %d', $msg_id, $size);
+                        return array('msg_id' => $msg_id, 'size' => $size);
+                    }
+                    return array();
+                }
+            }
+        }
+        
+
+        return false;
+    }
+
+
+    /*
+    * Sends the RETR command
+    *
+    * @param  integer $msg_id The message number to retrieve
+    * @return mixed   The message or false on error
+    */
+    function _cmdRetr($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('RETR ' . $msg_id) )){
+                $data = $this->_getMultiline();
+                return $data;
+            }
+        }
+
+        return false;
+    }
+
+
+    /*
+    * Sends the DELE command
+    *
+    * @param  integer $msg_id Message number to mark as deleted
+    * @return bool Success/Failure
+    */
+    function _cmdDele($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_sendCmd('DELE ' . $msg_id);
+        }
+
+        return false;
+    }
+
+
+    /*
+    * Sends the NOOP command
+    *
+    * @return bool Success/Failure
+    */
+    function _cmdNoop()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('NOOP'))){
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the RSET command
+    *
+    * @return bool Success/Failure
+    */
+    function _cmdRset()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('RSET'))){
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the QUIT command
+    *
+    * @return bool Success/Failure
+    */
+    function _cmdQuit()
+    {
+        $data = $this->_sendCmd('QUIT');
+        $this->_state = NET_POP3_STATE_DISCONNECTED;
+        $this->_socket->disconnect();
+
+        return (bool)$data;
+    }
+
+
+    /*
+    * Sends the TOP command
+    *
+    * @param  integer  $msg_id    Message number
+    * @param  integer  $num_lines Number of lines to retrieve
+    * @return mixed Message data or false on error
+    */
+    function _cmdTop($msg_id, $num_lines)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+
+            if(!PEAR::isError($data = $this->_sendCmd('TOP ' . $msg_id . ' ' . $num_lines))){
+                return $this->_getMultiline();
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the UIDL command
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed indexed array of msg_id/uidl or false on error
+    */
+    function _cmdUidl($msg_id = null)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+
+            if (!isset($msg_id)) {
+                if(!PEAR::isError($data = $this->_sendCmd('UIDL') )){
+                    $data = $this->_getMultiline();
+                    $data = explode("\r\n", $data);
+                    foreach ($data as $line) {
+                        sscanf($line, '%d %s', $msg_id, $uidl);
+                        $return[] = array('msg_id' => $msg_id, 'uidl' => $uidl);
+                    }
+
+                    return $return;
+                }
+            } else {
+
+                $data = $this->_sendCmd('UIDL ' . $msg_id);
+                sscanf($data, '+OK %d %s', $msg_id, $uidl);
+                return array('msg_id' => $msg_id, 'uidl' => $uidl);
+            }
+        }
+
+        return false;
+    }
+
+
+
+
+
+
+
+
+
+    /*
+    * Sends a command, checks the reponse, and
+    * if good returns the reponse, other wise
+    * returns false.
+    *
+    * @param  string $cmd  Command to send (\r\n will be appended)
+    * @return mixed First line of response if successful, otherwise false
+    */
+    function _sendCmd($cmd)
+    {
+        if (PEAR::isError($result = $this->_send($cmd) )){
+            return $result ;
+        }
+
+        if (PEAR::isError($data = $this->_recvLn() )){
+            return $data;
+        }
+        
+        if ( strtoupper(substr($data, 0, 3)) == '+OK') {
+            return $data;
+        }
+        
+        
+        return $this->_raiseError($data);
+    }
+
+    /*
+    * Reads a multiline reponse and returns the data
+    *
+    * @return string The reponse.
+    */
+    function _getMultiline()
+    {
+        $data = '';
+        while(!PEAR::isError($tmp = $this->_recvLn() ) ) {
+            if($tmp == '.'){
+                return substr($data, 0, -2);
+            }
+            if (substr($tmp, 0, 2) == '..') {
+                $tmp = substr($tmp, 1);
+            }
+            $data .= $tmp . "\r\n";
+        }
+        return substr($data, 0, -2);
+    }
+
+
+   /**
+    * Sets the bebug state
+    *
+    * @param  bool $debug 
+    * @access public
+    * @return void
+    */
+    function setDebug($debug=true)
+    {
+        $this->_debug=$debug;
+    }
+
+
+
+
+
+   /**
+     * Send the given string of data to the server.
+     *
+     * @param   string  $data       The string of data to send.
+     *
+     * @return  mixed   True on success or a PEAR_Error object on failure.
+     *
+     * @access  private
+     * @since   1.0
+     */
+    function _send($data)
+    {
+        if ($this->_debug) {
+            echo "C: $data\n";
+        }
+
+        if (PEAR::isError($error = $this->_socket->writeLine($data))) {
+            return $this->_raiseError('Failed to write to socket: ' . $error->getMessage());
+        }
+        return true;
+    }
+
+
+
+     /**
+     * Receive the given string of data from the server.
+     *
+     * @return  mixed   a line of response on success or a PEAR_Error object on failure.
+     *
+     * @access  private
+     * @since  1.0
+     */
+    function _recvLn()
+    {
+        if (PEAR::isError( $lastline = $this->_socket->readLine( 8192 ) ) ) {
+            return $this->_raiseError('Failed to write to socket: ' . $this->lastline->getMessage() );
+        }
+        if($this->_debug){
+            // S: means this data was sent by  the POP3 Server
+            echo "S:$lastline\n" ;
+        }
+        return $lastline;
+    }
+
+     /**
+     * Checks de server Response
+     *
+     * @param  string $response the response
+     * @return  mixed   true on success or a PEAR_Error object on failure.
+     *
+     * @access  private
+     * @since  1.3.3
+     */
+
+    function _checkResponse($response)
+    {
+        if (@substr(strtoupper($response), 0, 3) == '+OK') {
+            return true;
+        }else{
+            if (@substr(strtoupper($response), 0, 4) == '-ERR') {
+                return $this->_raiseError($response);
+            }else{
+                if (@substr(strtoupper($response), 0, 2) == '+ ') {
+                    return true;
+                }
+            }
+    
+        }
+        return $this->_raiseError("Unknown Response ($response)");
+    }
+    
+
+
+}
+
+?>
diff -Nur mantis-0.19.4.orig/Net/Socket.php mantis-0.19.4/Net/Socket.php
--- mantis-0.19.4.orig/Net/Socket.php	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/Net/Socket.php	2005-02-26 06:06:51.000000000 +0100
@@ -0,0 +1,528 @@
+<?php
+//
+// +----------------------------------------------------------------------+
+// | PHP Version 4                                                        |
+// +----------------------------------------------------------------------+
+// | Copyright (c) 1997-2003 The PHP Group                                |
+// +----------------------------------------------------------------------+
+// | This source file is subject to version 2.0 of the PHP license,       |
+// | that is bundled with this package in the file LICENSE, and is        |
+// | available at through the world-wide-web at                           |
+// | http://www.php.net/license/2_02.txt.                                 |
+// | If you did not receive a copy of the PHP license and are unable to   |
+// | obtain it through the world-wide-web, please send a note to          |
+// | license@php.net so we can mail you a copy immediately.               |
+// +----------------------------------------------------------------------+
+// | Authors: Stig Bakken <ssb@php.net>                                   |
+// |          Chuck Hagenbuch <chuck@horde.org>                           |
+// +----------------------------------------------------------------------+
+//
+// $Id: Socket.php,v 1.24 2005/02/03 20:40:16 chagenbu Exp $
+
+require_once 'PEAR.php';
+
+define('NET_SOCKET_READ',  1);
+define('NET_SOCKET_WRITE', 2);
+define('NET_SOCKET_ERROR', 3);
+
+/**
+ * Generalized Socket class.
+ *
+ * @version 1.1
+ * @author Stig Bakken <ssb@php.net>
+ * @author Chuck Hagenbuch <chuck@horde.org>
+ */
+class Net_Socket extends PEAR {
+
+    /**
+     * Socket file pointer.
+     * @var resource $fp
+     */
+    var $fp = null;
+
+    /**
+     * Whether the socket is blocking. Defaults to true.
+     * @var boolean $blocking
+     */
+    var $blocking = true;
+
+    /**
+     * Whether the socket is persistent. Defaults to false.
+     * @var boolean $persistent
+     */
+    var $persistent = false;
+
+    /**
+     * The IP address to connect to.
+     * @var string $addr
+     */
+    var $addr = '';
+
+    /**
+     * The port number to connect to.
+     * @var integer $port
+     */
+    var $port = 0;
+
+    /**
+     * Number of seconds to wait on socket connections before assuming
+     * there's no more data. Defaults to no timeout.
+     * @var integer $timeout
+     */
+    var $timeout = false;
+
+    /**
+     * Number of bytes to read at a time in readLine() and
+     * readAll(). Defaults to 2048.
+     * @var integer $lineLength
+     */
+    var $lineLength = 2048;
+
+    /**
+     * Connect to the specified port. If called when the socket is
+     * already connected, it disconnects and connects again.
+     *
+     * @param string  $addr        IP address or host name.
+     * @param integer $port        TCP port number.
+     * @param boolean $persistent  (optional) Whether the connection is
+     *                             persistent (kept open between requests
+     *                             by the web server).
+     * @param integer $timeout     (optional) How long to wait for data.
+     * @param array   $options     See options for stream_context_create.
+     *
+     * @access public
+     *
+     * @return boolean | PEAR_Error  True on success or a PEAR_Error on failure.
+     */
+    function connect($addr, $port = 0, $persistent = null, $timeout = null, $options = null)
+    {
+        if (is_resource($this->fp)) {
+            @fclose($this->fp);
+            $this->fp = null;
+        }
+
+        if (!$addr) {
+            return $this->raiseError('$addr cannot be empty');
+        } elseif (strspn($addr, '.0123456789') == strlen($addr) ||
+                  strstr($addr, '/') !== false) {
+            $this->addr = $addr;
+        } else {
+            $this->addr = @gethostbyname($addr);
+        }
+
+        $this->port = $port % 65536;
+
+        if ($persistent !== null) {
+            $this->persistent = $persistent;
+        }
+
+        if ($timeout !== null) {
+            $this->timeout = $timeout;
+        }
+
+        $openfunc = $this->persistent ? 'pfsockopen' : 'fsockopen';
+        $errno = 0;
+        $errstr = '';
+        if ($options && function_exists('stream_context_create')) {
+            if ($this->timeout) {
+                $timeout = $this->timeout;
+            } else {
+                $timeout = 0;
+            }
+            $context = stream_context_create($options);
+            $fp = @$openfunc($this->addr, $this->port, $errno, $errstr, $timeout, $context);
+        } else {
+            if ($this->timeout) {
+                $fp = @$openfunc($this->addr, $this->port, $errno, $errstr, $this->timeout);
+            } else {
+                $fp = @$openfunc($this->addr, $this->port, $errno, $errstr);
+            }
+        }
+
+        if (!$fp) {
+            return $this->raiseError($errstr, $errno);
+        }
+
+        $this->fp = $fp;
+
+        return $this->setBlocking($this->blocking);
+    }
+
+    /**
+     * Disconnects from the peer, closes the socket.
+     *
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function disconnect()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        @fclose($this->fp);
+        $this->fp = null;
+        return true;
+    }
+
+    /**
+     * Find out if the socket is in blocking mode.
+     *
+     * @access public
+     * @return boolean  The current blocking mode.
+     */
+    function isBlocking()
+    {
+        return $this->blocking;
+    }
+
+    /**
+     * Sets whether the socket connection should be blocking or
+     * not. A read call to a non-blocking socket will return immediately
+     * if there is no data available, whereas it will block until there
+     * is data for blocking sockets.
+     *
+     * @param boolean $mode  True for blocking sockets, false for nonblocking.
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function setBlocking($mode)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $this->blocking = $mode;
+        socket_set_blocking($this->fp, $this->blocking);
+        return true;
+    }
+
+    /**
+     * Sets the timeout value on socket descriptor,
+     * expressed in the sum of seconds and microseconds
+     *
+     * @param integer $seconds  Seconds.
+     * @param integer $microseconds  Microseconds.
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function setTimeout($seconds, $microseconds)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return socket_set_timeout($this->fp, $seconds, $microseconds);
+    }
+
+    /**
+     * Returns information about an existing socket resource.
+     * Currently returns four entries in the result array:
+     *
+     * <p>
+     * timed_out (bool) - The socket timed out waiting for data<br>
+     * blocked (bool) - The socket was blocked<br>
+     * eof (bool) - Indicates EOF event<br>
+     * unread_bytes (int) - Number of bytes left in the socket buffer<br>
+     * </p>
+     *
+     * @access public
+     * @return mixed Array containing information about existing socket resource or an error object otherwise
+     */
+    function getStatus()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return socket_get_status($this->fp);
+    }
+
+    /**
+     * Get a specified line of data
+     *
+     * @access public
+     * @return $size bytes of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function gets($size)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return @fgets($this->fp, $size);
+    }
+
+    /**
+     * Read a specified amount of data. This is guaranteed to return,
+     * and has the added benefit of getting everything in one fread()
+     * chunk; if you know the size of the data you're getting
+     * beforehand, this is definitely the way to go.
+     *
+     * @param integer $size  The number of bytes to read from the socket.
+     * @access public
+     * @return $size bytes of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function read($size)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return @fread($this->fp, $size);
+    }
+
+    /**
+     * Write a specified amount of data.
+     *
+     * @param string  $data       Data to write.
+     * @param integer $blocksize  Amount of data to write at once.
+     *                            NULL means all at once.
+     *
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function write($data, $blocksize = null)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        if (is_null($blocksize) && !OS_WINDOWS) {
+            return fwrite($this->fp, $data);
+        } else {
+            if (is_null($blocksize)) {
+                $blocksize = 1024;
+            }
+
+            $pos = 0;
+            $size = strlen($data);
+            while ($pos < $size) {
+                $written = @fwrite($this->fp, substr($data, $pos, $blocksize));
+                if ($written === false) {
+                    return false;
+                }
+                $pos += $written;
+            }
+
+            return $pos;
+        }
+    }
+
+    /**
+     * Write a line of data to the socket, followed by a trailing "\r\n".
+     *
+     * @access public
+     * @return mixed fputs result, or an error
+     */
+    function writeLine($data)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return fwrite($this->fp, $data . "\r\n");
+    }
+
+    /**
+     * Tests for end-of-file on a socket descriptor.
+     *
+     * @access public
+     * @return bool
+     */
+    function eof()
+    {
+        return (is_resource($this->fp) && feof($this->fp));
+    }
+
+    /**
+     * Reads a byte of data
+     *
+     * @access public
+     * @return 1 byte of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readByte()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return ord(@fread($this->fp, 1));
+    }
+
+    /**
+     * Reads a word of data
+     *
+     * @access public
+     * @return 1 word of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readWord()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $buf = @fread($this->fp, 2);
+        return (ord($buf[0]) + (ord($buf[1]) << 8));
+    }
+
+    /**
+     * Reads an int of data
+     *
+     * @access public
+     * @return integer  1 int of data from the socket, or a PEAR_Error if
+     *                  not connected.
+     */
+    function readInt()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $buf = @fread($this->fp, 4);
+        return (ord($buf[0]) + (ord($buf[1]) << 8) +
+                (ord($buf[2]) << 16) + (ord($buf[3]) << 24));
+    }
+
+    /**
+     * Reads a zero-terminated string of data
+     *
+     * @access public
+     * @return string, or a PEAR_Error if
+     *         not connected.
+     */
+    function readString()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $string = '';
+        while (($char = @fread($this->fp, 1)) != "\x00")  {
+            $string .= $char;
+        }
+        return $string;
+    }
+
+    /**
+     * Reads an IP Address and returns it in a dot formated string
+     *
+     * @access public
+     * @return Dot formated string, or a PEAR_Error if
+     *         not connected.
+     */
+    function readIPAddress()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $buf = @fread($this->fp, 4);
+        return sprintf("%s.%s.%s.%s", ord($buf[0]), ord($buf[1]),
+                       ord($buf[2]), ord($buf[3]));
+    }
+
+    /**
+     * Read until either the end of the socket or a newline, whichever
+     * comes first. Strips the trailing newline from the returned data.
+     *
+     * @access public
+     * @return All available data up to a newline, without that
+     *         newline, or until the end of the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readLine()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $line = '';
+        $timeout = time() + $this->timeout;
+        while (!feof($this->fp) && (!$this->timeout || time() < $timeout)) {
+            $line .= @fgets($this->fp, $this->lineLength);
+            if (substr($line, -1) == "\n") {
+                return rtrim($line, "\r\n");
+            }
+        }
+        return $line;
+    }
+
+    /**
+     * Read until the socket closes, or until there is no more data in
+     * the inner PHP buffer. If the inner buffer is empty, in blocking
+     * mode we wait for at least 1 byte of data. Therefore, in
+     * blocking mode, if there is no data at all to be read, this
+     * function will never exit (unless the socket is closed on the
+     * remote end).
+     *
+     * @access public
+     *
+     * @return string  All data until the socket closes, or a PEAR_Error if
+     *                 not connected.
+     */
+    function readAll()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $data = '';
+        while (!feof($this->fp)) {
+            $data .= @fread($this->fp, $this->lineLength);
+        }
+        return $data;
+    }
+
+    /**
+     * Runs the equivalent of the select() system call on the socket
+     * with a timeout specified by tv_sec and tv_usec.
+     *
+     * @param integer $state    Which of read/write/error to check for.
+     * @param integer $tv_sec   Number of seconds for timeout.
+     * @param integer $tv_usec  Number of microseconds for timeout.
+     *
+     * @access public
+     * @return False if select fails, integer describing which of read/write/error
+     *         are ready, or PEAR_Error if not connected.
+     */
+    function select($state, $tv_sec, $tv_usec = 0)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $read = null;
+        $write = null;
+        $except = null;
+        if ($state & NET_SOCKET_READ) {
+            $read[] = $this->fp;
+        }
+        if ($state & NET_SOCKET_WRITE) {
+            $write[] = $this->fp;
+        }
+        if ($state & NET_SOCKET_ERROR) {
+            $except[] = $this->fp;
+        }
+        if (false === ($sr = stream_select($read, $write, $except, $tv_sec, $tv_usec))) {
+            return false;
+        }
+
+        $result = 0;
+        if (count($read)) {
+            $result |= NET_SOCKET_READ;
+        }
+        if (count($write)) {
+            $result |= NET_SOCKET_WRITE;
+        }
+        if (count($except)) {
+            $result |= NET_SOCKET_ERROR;
+        }
+        return $result;
+    }
+
+}
diff -Nur mantis-0.19.4.orig/sql/bug_report_mail.sql mantis-0.19.4/sql/bug_report_mail.sql
--- mantis-0.19.4.orig/sql/bug_report_mail.sql	1970-01-01 01:00:00.000000000 +0100
+++ mantis-0.19.4/sql/bug_report_mail.sql	2005-12-23 13:56:09.000000000 +0100
@@ -0,0 +1,12 @@
+ALTER TABLE `mantis_project_table`
+ADD `pop3_host` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_user` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_pass` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_categories` ENUM( '0', '1' ) DEFAULT '0' NOT NULL ;
+
+ALTER TABLE `mantis_project_category_table`
+ADD `pop3_host` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_user` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_pass` VARCHAR( 255 ) DEFAULT NULL ;
+
+INSERT INTO mantis_user_table (username, realname, email, password, date_created, last_visit, enabled, protected, access_level, login_count, lost_password_in_progress_count, failed_login_count, cookie_string) VALUES ('Mail', 'Mail Reporter', 'nomail', 'a268462c3c679a9027658c5aa723f97c', '2004-12-25 15:41:49', '2004-12-25 15:41:49', 1, 0, 25, 0, 0, 0, CONCAT(MD5(RAND()),MD5(NOW())));
diff -Nur mantis-0.19.4.orig/sql/db_generate.sql mantis-0.19.4/sql/db_generate.sql
--- mantis-0.19.4.orig/sql/db_generate.sql	2004-11-06 12:07:30.000000000 +0100
+++ mantis-0.19.4/sql/db_generate.sql	2005-12-23 13:56:09.000000000 +0100
@@ -330,6 +330,9 @@
   project_id int(7) unsigned NOT NULL default '0',
   category varchar(64) NOT NULL default '',
   user_id int(7) unsigned NOT NULL default '0',
+  pop3_host varchar( 255 ) default NULL,
+  pop3_user varchar( 255 ) default NULL,
+  pop3_pass varchar( 255 ) default NULL,
   PRIMARY KEY  (project_id,category)
 ) TYPE=MyISAM;
 
@@ -379,6 +382,10 @@
   access_min int(2) NOT NULL default '10',
   file_path varchar(250) NOT NULL default '',
   description text NOT NULL,
+  pop3_host varchar( 255 ) default NULL,
+  pop3_user varchar( 255 ) default NULL,
+  pop3_pass varchar( 255 ) default NULL,
+  pop3_categories enum( '0', '1' ) NOT NULL default '0',
   PRIMARY KEY  (id),
   UNIQUE KEY name (name),
   KEY id (id)
@@ -881,3 +888,5 @@
 #
 
 INSERT INTO mantis_user_table VALUES (1, 'administrator', '', 'admin', '63a9f0ea7bb98050796b649e85481845', '2003-02-16 02:03:48', '2004-07-08 23:59:22', 1, 1, 90, 3, 0, 0, CONCAT(MD5(RAND()),MD5(NOW())));
+INSERT INTO mantis_user_table VALUES (2, 'Mail', 'Mail Reporter', 'nomail', 'a268462c3c679a9027658c5aa723f97c', '2004-12-25 15:41:49', '2004-12-25 15:41:49', 1, 0, 25, 0, 0, 0, CONCAT(MD5(RAND()),MD5(NOW())));
+
