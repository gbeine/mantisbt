From 8613b7c6160752443cf88593e86b971a7bafe7d7 Mon Sep 17 00:00:00 2001
From: Gerrit Beine <gerrit.beine@gmx.de>
Date: Thu, 5 Sep 2013 07:33:21 +0200
Subject: [PATCH] Applied mail import patch to MantisBT 1.0.5

---
 Mail/Parser.php                 |  166 ++++++
 Mail/mime.php                   |  713 +++++++++++++++++++++++
 Mail/mimeDecode.php             |  837 ++++++++++++++++++++++++++
 Mail/mimePart.php               |  351 +++++++++++
 Net/POP3.php                    | 1226 +++++++++++++++++++++++++++++++++++++++
 Net/Socket.php                  |  528 +++++++++++++++++
 PEAR.php                        | 1101 +++++++++++++++++++++++++++++++++++
 admin/schema.php                |   17 +-
 bug_report_mail.php             |   31 +
 config_defaults_inc.php         |   82 ++-
 core/category_api.php           |    6 +-
 core/file_api.php               |    6 +-
 core/mail_api.php               |  468 +++++++++++++++
 core/user_api.php               |   20 +-
 doc/README.bug_report_mail      |  176 ++++++
 doc/bug_report_mail.sql         |   12 +
 manage_proj_cat_edit_page.php   |   62 +-
 manage_proj_cat_mail_delete.php |   44 ++
 manage_proj_cat_mail_update.php |   59 ++
 manage_proj_edit_page.php       |   75 ++-
 manage_proj_mail_categories.php |   43 ++
 manage_proj_mail_delete.php     |   43 ++
 manage_proj_mail_update.php     |   58 ++
 23 files changed, 6111 insertions(+), 13 deletions(-)
 create mode 100644 Mail/Parser.php
 create mode 100644 Mail/mime.php
 create mode 100644 Mail/mimeDecode.php
 create mode 100644 Mail/mimePart.php
 create mode 100644 Net/POP3.php
 create mode 100644 Net/Socket.php
 create mode 100644 PEAR.php
 create mode 100644 bug_report_mail.php
 create mode 100644 core/mail_api.php
 create mode 100644 doc/README.bug_report_mail
 create mode 100644 doc/bug_report_mail.sql
 create mode 100644 manage_proj_cat_mail_delete.php
 create mode 100644 manage_proj_cat_mail_update.php
 create mode 100644 manage_proj_mail_categories.php
 create mode 100644 manage_proj_mail_delete.php
 create mode 100644 manage_proj_mail_update.php

diff --git a/Mail/Parser.php b/Mail/Parser.php
new file mode 100644
index 0000000..ec02328
--- /dev/null
+++ b/Mail/Parser.php
@@ -0,0 +1,166 @@
+<?php
+
+require_once( 'Mail/mimeDecode.php' );
+
+class Mail_Parser
+{
+    private $_parse_html = false;
+    private $_parse_mime = false;
+    private $_htmlparser = "/usr/bin/w3m -T text/html -dump";
+    private $_htmltmpdir = "/tmp";
+
+    private $_file;
+    private $_content;
+    
+    private $_from;
+    private $_subject;
+    private $_transferencoding;
+    private $_body;
+    private $_parts = array ( );
+    private $_ctype = array ( );
+
+    function __construct( $options = array() ) {
+	$this->_parse_mime = $options['parse_mime'];
+	$this->_parse_html = $options['parse_html'];
+	$this->_htmlparser = $options['htmlparser'];
+	$this->_htmltmpdir = $options['htmltmpdir'];
+    }
+    
+    public function setInputString ( $content ) {
+        $this->_content = $content;
+    }
+    
+    public function setInputFile( $file ) {
+        $this->_file = $file;
+        $this->_content = file_get_contents( $this->_file );
+    }
+
+    public function parse() {
+        $decoder = new Mail_mimeDecode( $this->_content );
+        $params['include_bodies'] = true;
+        $params['decode_bodies'] = true;
+        $params['decode_headers'] = true;
+        $structure = $decoder->decode( $params );
+	$this->parseStructure( $structure );
+	unset( $this->_content );
+    }
+    
+    public function from() {
+	return $this->_from;
+    }
+
+    public function subject() {
+	return $this->_subject;
+    }
+
+    public function priority() {
+	return $this->_priority;
+    }
+
+    public function body() {
+	return $this->_body;
+    }
+
+    public function parts() {
+	return $this->_parts;
+    }
+    
+    private function parseStructure( $structure ) {
+	$this->setFrom( $structure->headers['from'] );
+	$this->setSubject( $structure->headers['subject'] );
+	$this->setContentType( $structure->ctype_primary, $structure->ctype_secondary );
+	if ( isset( $structure->headers['x-priority'] ) ) {
+	    $this->setPriority( $structure->headers['x-priority'] );
+	}
+	if ( isset( $structure->headers['content-transfer-encoding'] ) ) {
+	    $this->setTransferEncoding( $structure->headers['content-transfer-encoding'] );
+	}
+	if ( isset( $structure->body ) ) {
+	    $this->setBody( $structure->body );
+	}
+	if ( $this->_parse_mime && isset( $structure->parts ) ) {
+	    $this->setParts( $structure->parts );
+	}
+    }
+
+    private function setFrom( $from ) {
+	$this->_from = quoted_printable_decode( $from );
+    }
+
+    private function setSubject( $subject ) {
+	$this->_subject = quoted_printable_decode( $subject );
+    }
+
+    private function setPriority( $priority ) {
+	$this->_priority = $priority;
+    }
+
+    private function setTransferEncoding( $transferencoding ) {
+	$this->_transferencoding = $transferencoding;
+    }
+    
+    private function setContentType( $primary, $secondary ) {
+        $this->_ctype['primary'] = $primary;
+	$this->_ctype['secondary'] = $secondary;
+    }
+
+    private function setBody( $body ) {
+        if ( 0 == strlen( $body ) || 0 != strlen( $this->_body ) ) {
+	    return;
+	}
+	if ( 'text' == $this->_ctype['primary'] &&
+	     'plain' == $this->_ctype['secondary'] ) {
+	    switch ( $this->_transferencoding ) {
+	        case 'base64':
+	        case '8bit':
+	        case 'quoted-printable':
+		    $this->_body = quoted_printable_decode( $body );
+		    break;
+		default:
+		    $this->_body = $body;
+		    break;
+	    }
+	} elseif ( $this->_parse_html &&
+	           'text' == $this->_ctype['primary'] &&
+	           'html' == $this->_ctype['secondary'] ) {
+            $file = $this->_htmltmpdir . "/" . md5 ( $body );
+            file_put_contents( $file, $body );
+            $this->_body = shell_exec("cat " . $file . " | " . $this->_htmlparser);
+            unlink($file);
+	}
+    }
+    
+    private function setParts( &$parts ) {
+	$i = 0;
+	if ( 'multipart' == $parts[$i]->ctype_primary ) {
+	    $this->setParts( $parts[$i]->parts );
+	    $i++;
+	}
+        if ( 'text' == $parts[$i]->ctype_primary &&
+	    in_array( $parts[$i]->ctype_secondary, array( 'plain', 'html' ) ) ) {
+	    $this->setContentType( $parts[$i]->ctype_primary, $parts[$i]->ctype_secondary );
+	    $this->setTransferEncoding( $parts[$i]->headers['content-transfer-encoding'] );
+	    $this->setBody( $parts[$i]->body );
+	    $i++;
+	}
+        if ( isset( $parts[$i] ) &&
+	    'text' == $parts[$i]->ctype_primary &&
+	    'html' == $parts[$i]->ctype_secondary ) {
+	    $i++;
+	}
+	for ( $i; $i < count( $parts ); $i++ ) {
+	    $this->addPart( $parts[$i] );
+	}
+    }
+    
+    private function addPart( &$part ) {
+	$p['ctype'] = $part->ctype_primary . "/" . $part->ctype_secondary;
+	if ( isset( $part->ctype_parameters['name'] ) ) {
+	    $p['name'] = $part->ctype_parameters['name'];
+	}
+	$p['body'] = $part->body;
+	$this->_parts[] = $p;
+    }
+}
+
+?>
\ No newline at end of file
diff --git a/Mail/mime.php b/Mail/mime.php
new file mode 100644
index 0000000..302a212
--- /dev/null
+++ b/Mail/mime.php
@@ -0,0 +1,713 @@
+<?php
+/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003  Richard Heyes                                |
+// | Copyright (c) 2003-2005  The PHP Group                                |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// |         Tomas V.V.Cox <cox@idecnet.com> (port to PEAR)                |
+// +-----------------------------------------------------------------------+
+//
+// $Id: mime.php,v 1.39 2005/06/13 21:24:16 cipri Exp $
+
+require_once('PEAR.php');
+require_once('Mail/mimePart.php');
+
+/**
+ * Mime mail composer class. Can handle: text and html bodies, embedded html
+ * images and attachments.
+ * Documentation and examples of this class are avaible here:
+ * http://pear.php.net/manual/
+ *
+ * @notes This class is based on HTML Mime Mail class from
+ *   Richard Heyes <richard@phpguru.org> which was based also
+ *   in the mime_mail.class by Tobias Ratschiller <tobias@dnet.it> and
+ *   Sascha Schumann <sascha@schumann.cx>
+ *
+ * @author   Richard Heyes <richard.heyes@heyes-computing.net>
+ * @author   Tomas V.V.Cox <cox@idecnet.com>
+ * @package  Mail
+ * @access   public
+ */
+class Mail_mime
+{
+    /**
+     * Contains the plain text part of the email
+     * @var string
+     */
+    var $_txtbody;
+    /**
+     * Contains the html part of the email
+     * @var string
+     */
+    var $_htmlbody;
+    /**
+     * contains the mime encoded text
+     * @var string
+     */
+    var $_mime;
+    /**
+     * contains the multipart content
+     * @var string
+     */
+    var $_multipart;
+    /**
+     * list of the attached images
+     * @var array
+     */
+    var $_html_images = array();
+    /**
+     * list of the attachements
+     * @var array
+     */
+    var $_parts = array();
+    /**
+     * Build parameters
+     * @var array
+     */
+    var $_build_params = array();
+    /**
+     * Headers for the mail
+     * @var array
+     */
+    var $_headers = array();
+    /**
+     * End Of Line sequence (for serialize)
+     * @var string
+     */
+    var $_eol;
+
+
+    /**
+     * Constructor function
+     *
+     * @access public
+     */
+    function Mail_mime($crlf = "\r\n")
+    {
+        $this->_setEOL($crlf);
+        $this->_build_params = array(
+                                     'text_encoding' => '7bit',
+                                     'html_encoding' => 'quoted-printable',
+                                     '7bit_wrap'     => 998,
+                                     'html_charset'  => 'ISO-8859-1',
+                                     'text_charset'  => 'ISO-8859-1',
+                                     'head_charset'  => 'ISO-8859-1'
+                                    );
+    }
+
+    /**
+     * Wakeup (unserialize) - re-sets EOL constant
+     *
+     * @access private
+     */
+    function __wakeup()
+    {
+        $this->_setEOL($this->_eol);
+    }
+
+    /**
+     * Accessor function to set the body text. Body text is used if
+     * it's not an html mail being sent or else is used to fill the
+     * text/plain part that emails clients who don't support
+     * html should show.
+     *
+     * @param  string  $data   Either a string or
+     *                         the file name with the contents
+     * @param  bool    $isfile If true the first param should be treated
+     *                         as a file name, else as a string (default)
+     * @param  bool    $append If true the text or file is appended to
+     *                         the existing body, else the old body is
+     *                         overwritten
+     * @return mixed   true on success or PEAR_Error object
+     * @access public
+     */
+    function setTXTBody($data, $isfile = false, $append = false)
+    {
+        if (!$isfile) {
+            if (!$append) {
+                $this->_txtbody = $data;
+            } else {
+                $this->_txtbody .= $data;
+            }
+        } else {
+            $cont = $this->_file2str($data);
+            if (PEAR::isError($cont)) {
+                return $cont;
+            }
+            if (!$append) {
+                $this->_txtbody = $cont;
+            } else {
+                $this->_txtbody .= $cont;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Adds a html part to the mail
+     *
+     * @param  string  $data   Either a string or the file name with the
+     *                         contents
+     * @param  bool    $isfile If true the first param should be treated
+     *                         as a file name, else as a string (default)
+     * @return mixed   true on success or PEAR_Error object
+     * @access public
+     */
+    function setHTMLBody($data, $isfile = false)
+    {
+        if (!$isfile) {
+            $this->_htmlbody = $data;
+        } else {
+            $cont = $this->_file2str($data);
+            if (PEAR::isError($cont)) {
+                return $cont;
+            }
+            $this->_htmlbody = $cont;
+        }
+
+        return true;
+    }
+
+    /**
+     * Adds an image to the list of embedded images.
+     *
+     * @param  string  $file       The image file name OR image data itself
+     * @param  string  $c_type     The content type
+     * @param  string  $name       The filename of the image.
+     *                             Only use if $file is the image data
+     * @param  bool    $isfilename Whether $file is a filename or not
+     *                             Defaults to true
+     * @return mixed   true on success or PEAR_Error object
+     * @access public
+     */
+    function addHTMLImage($file, $c_type='application/octet-stream',
+                          $name = '', $isfilename = true)
+    {
+        $filedata = ($isfilename === true) ? $this->_file2str($file)
+                                           : $file;
+        if ($isfilename === true) {
+            $filename = ($name == '' ? basename($file) : basename($name));
+        } else {
+            $filename = basename($name);
+        }
+        if (PEAR::isError($filedata)) {
+            return $filedata;
+        }
+        $this->_html_images[] = array(
+                                      'body'   => $filedata,
+                                      'name'   => $filename,
+                                      'c_type' => $c_type,
+                                      'cid'    => md5(uniqid(time()))
+                                     );
+        return true;
+    }
+
+    /**
+     * Adds a file to the list of attachments.
+     *
+     * @param  string  $file       The file name of the file to attach
+     *                             OR the file data itself
+     * @param  string  $c_type     The content type
+     * @param  string  $name       The filename of the attachment
+     *                             Only use if $file is the file data
+     * @param  bool    $isFilename Whether $file is a filename or not
+     *                             Defaults to true
+     * @return mixed true on success or PEAR_Error object
+     * @access public
+     */
+    function addAttachment($file, $c_type = 'application/octet-stream',
+                           $name = '', $isfilename = true,
+                           $encoding = 'base64')
+    {
+        $filedata = ($isfilename === true) ? $this->_file2str($file)
+                                           : $file;
+        if ($isfilename === true) {
+            // Force the name the user supplied, otherwise use $file
+            $filename = (!empty($name)) ? $name : $file;
+        } else {
+            $filename = $name;
+        }
+        if (empty($filename)) {
+            return PEAR::raiseError(
+              'The supplied filename for the attachment can\'t be empty'
+            );
+        }
+        $filename = basename($filename);
+        if (PEAR::isError($filedata)) {
+            return $filedata;
+        }
+
+        $this->_parts[] = array(
+                                'body'     => $filedata,
+                                'name'     => $filename,
+                                'c_type'   => $c_type,
+                                'encoding' => $encoding
+                               );
+        return true;
+    }
+
+    /**
+     * Get the contents of the given file name as string
+     *
+     * @param  string  $file_name  path of file to process
+     * @return string  contents of $file_name
+     * @access private
+     */
+    function &_file2str($file_name)
+    {
+        if (!is_readable($file_name)) {
+            return PEAR::raiseError('File is not readable ' . $file_name);
+        }
+        if (!$fd = fopen($file_name, 'rb')) {
+            return PEAR::raiseError('Could not open ' . $file_name);
+        }
+        $filesize = filesize($file_name);
+        if ($filesize == 0){
+            $cont =  "";
+        }else{
+            $cont = fread($fd, $filesize);
+        }
+        fclose($fd);
+        return $cont;
+    }
+
+    /**
+     * Adds a text subpart to the mimePart object and
+     * returns it during the build process.
+     *
+     * @param mixed    The object to add the part to, or
+     *                 null if a new object is to be created.
+     * @param string   The text to add.
+     * @return object  The text mimePart object
+     * @access private
+     */
+    function &_addTextPart(&$obj, $text)
+    {
+        $params['content_type'] = 'text/plain';
+        $params['encoding']     = $this->_build_params['text_encoding'];
+        $params['charset']      = $this->_build_params['text_charset'];
+        if (is_object($obj)) {
+            return $obj->addSubpart($text, $params);
+        } else {
+            return new Mail_mimePart($text, $params);
+        }
+    }
+
+    /**
+     * Adds a html subpart to the mimePart object and
+     * returns it during the build process.
+     *
+     * @param  mixed   The object to add the part to, or
+     *                 null if a new object is to be created.
+     * @return object  The html mimePart object
+     * @access private
+     */
+    function &_addHtmlPart(&$obj)
+    {
+        $params['content_type'] = 'text/html';
+        $params['encoding']     = $this->_build_params['html_encoding'];
+        $params['charset']      = $this->_build_params['html_charset'];
+        if (is_object($obj)) {
+            return $obj->addSubpart($this->_htmlbody, $params);
+        } else {
+            return new Mail_mimePart($this->_htmlbody, $params);
+        }
+    }
+
+    /**
+     * Creates a new mimePart object, using multipart/mixed as
+     * the initial content-type and returns it during the
+     * build process.
+     *
+     * @return object  The multipart/mixed mimePart object
+     * @access private
+     */
+    function &_addMixedPart()
+    {
+        $params['content_type'] = 'multipart/mixed';
+        return new Mail_mimePart('', $params);
+    }
+
+    /**
+     * Adds a multipart/alternative part to a mimePart
+     * object (or creates one), and returns it during
+     * the build process.
+     *
+     * @param  mixed   The object to add the part to, or
+     *                 null if a new object is to be created.
+     * @return object  The multipart/mixed mimePart object
+     * @access private
+     */
+    function &_addAlternativePart(&$obj)
+    {
+        $params['content_type'] = 'multipart/alternative';
+        if (is_object($obj)) {
+            return $obj->addSubpart('', $params);
+        } else {
+            return new Mail_mimePart('', $params);
+        }
+    }
+
+    /**
+     * Adds a multipart/related part to a mimePart
+     * object (or creates one), and returns it during
+     * the build process.
+     *
+     * @param mixed    The object to add the part to, or
+     *                 null if a new object is to be created
+     * @return object  The multipart/mixed mimePart object
+     * @access private
+     */
+    function &_addRelatedPart(&$obj)
+    {
+        $params['content_type'] = 'multipart/related';
+        if (is_object($obj)) {
+            return $obj->addSubpart('', $params);
+        } else {
+            return new Mail_mimePart('', $params);
+        }
+    }
+
+    /**
+     * Adds an html image subpart to a mimePart object
+     * and returns it during the build process.
+     *
+     * @param  object  The mimePart to add the image to
+     * @param  array   The image information
+     * @return object  The image mimePart object
+     * @access private
+     */
+    function &_addHtmlImagePart(&$obj, $value)
+    {
+        $params['content_type'] = $value['c_type'];
+        $params['encoding']     = 'base64';
+        $params['disposition']  = 'inline';
+        $params['dfilename']    = $value['name'];
+        $params['cid']          = $value['cid'];
+        $obj->addSubpart($value['body'], $params);
+    }
+
+    /**
+     * Adds an attachment subpart to a mimePart object
+     * and returns it during the build process.
+     *
+     * @param  object  The mimePart to add the image to
+     * @param  array   The attachment information
+     * @return object  The image mimePart object
+     * @access private
+     */
+    function &_addAttachmentPart(&$obj, $value)
+    {
+        $params['content_type'] = $value['c_type'];
+        $params['encoding']     = $value['encoding'];
+        $params['disposition']  = 'attachment';
+        $params['dfilename']    = $value['name'];
+        $obj->addSubpart($value['body'], $params);
+    }
+
+    /**
+     * Builds the multipart message from the list ($this->_parts) and
+     * returns the mime content.
+     *
+     * @param  array  Build parameters that change the way the email
+     *                is built. Should be associative. Can contain:
+     *                text_encoding  -  What encoding to use for plain text
+     *                                  Default is 7bit
+     *                html_encoding  -  What encoding to use for html
+     *                                  Default is quoted-printable
+     *                7bit_wrap      -  Number of characters before text is
+     *                                  wrapped in 7bit encoding
+     *                                  Default is 998
+     *                html_charset   -  The character set to use for html.
+     *                                  Default is iso-8859-1
+     *                text_charset   -  The character set to use for text.
+     *                                  Default is iso-8859-1
+     *                head_charset   -  The character set to use for headers.
+     *                                  Default is iso-8859-1
+     * @return string The mime content
+     * @access public
+     */
+    function &get($build_params = null)
+    {
+        if (isset($build_params)) {
+            while (list($key, $value) = each($build_params)) {
+                $this->_build_params[$key] = $value;
+            }
+        }
+
+        if (!empty($this->_html_images) AND isset($this->_htmlbody)) {
+            foreach ($this->_html_images as $value) {
+                $regex = '#(\s)((?i)src|background|href(?-i))\s*=\s*(["\']?)' . preg_quote($value['name'], '#') .
+                         '\3#';
+                $rep = '\1\2=\3cid:' . $value['cid'] .'\3';
+                $this->_htmlbody = preg_replace($regex, $rep,
+                                       $this->_htmlbody
+                                   );
+            }
+        }
+
+        $null        = null;
+        $attachments = !empty($this->_parts)                ? true : false;
+        $html_images = !empty($this->_html_images)          ? true : false;
+        $html        = !empty($this->_htmlbody)             ? true : false;
+        $text        = (!$html AND !empty($this->_txtbody)) ? true : false;
+
+        switch (true) {
+        case $text AND !$attachments:
+            $message =& $this->_addTextPart($null, $this->_txtbody);
+            break;
+
+        case !$text AND !$html AND $attachments:
+            $message =& $this->_addMixedPart();
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        case $text AND $attachments:
+            $message =& $this->_addMixedPart();
+            $this->_addTextPart($message, $this->_txtbody);
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        case $html AND !$attachments AND !$html_images:
+            if (isset($this->_txtbody)) {
+                $message =& $this->_addAlternativePart($null);
+                $this->_addTextPart($message, $this->_txtbody);
+                $this->_addHtmlPart($message);
+            } else {
+                $message =& $this->_addHtmlPart($null);
+            }
+            break;
+
+        case $html AND !$attachments AND $html_images:
+            if (isset($this->_txtbody)) {
+                $message =& $this->_addAlternativePart($null);
+                $this->_addTextPart($message, $this->_txtbody);
+                $related =& $this->_addRelatedPart($message);
+            } else {
+                $message =& $this->_addRelatedPart($null);
+                $related =& $message;
+            }
+            $this->_addHtmlPart($related);
+            for ($i = 0; $i < count($this->_html_images); $i++) {
+                $this->_addHtmlImagePart($related, $this->_html_images[$i]);
+            }
+            break;
+
+        case $html AND $attachments AND !$html_images:
+            $message =& $this->_addMixedPart();
+            if (isset($this->_txtbody)) {
+                $alt =& $this->_addAlternativePart($message);
+                $this->_addTextPart($alt, $this->_txtbody);
+                $this->_addHtmlPart($alt);
+            } else {
+                $this->_addHtmlPart($message);
+            }
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        case $html AND $attachments AND $html_images:
+            $message =& $this->_addMixedPart();
+            if (isset($this->_txtbody)) {
+                $alt =& $this->_addAlternativePart($message);
+                $this->_addTextPart($alt, $this->_txtbody);
+                $rel =& $this->_addRelatedPart($alt);
+            } else {
+                $rel =& $this->_addRelatedPart($message);
+            }
+            $this->_addHtmlPart($rel);
+            for ($i = 0; $i < count($this->_html_images); $i++) {
+                $this->_addHtmlImagePart($rel, $this->_html_images[$i]);
+            }
+            for ($i = 0; $i < count($this->_parts); $i++) {
+                $this->_addAttachmentPart($message, $this->_parts[$i]);
+            }
+            break;
+
+        }
+
+        if (isset($message)) {
+            $output = $message->encode();
+            $this->_headers = array_merge($this->_headers,
+                                          $output['headers']);
+            return $output['body'];
+
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Returns an array with the headers needed to prepend to the email
+     * (MIME-Version and Content-Type). Format of argument is:
+     * $array['header-name'] = 'header-value';
+     *
+     * @param  array $xtra_headers Assoc array with any extra headers.
+     *                             Optional.
+     * @return array Assoc array with the mime headers
+     * @access public
+     */
+    function &headers($xtra_headers = null)
+    {
+        // Content-Type header should already be present,
+        // So just add mime version header
+        $headers['MIME-Version'] = '1.0';
+        if (isset($xtra_headers)) {
+            $headers = array_merge($headers, $xtra_headers);
+        }
+        $this->_headers = array_merge($headers, $this->_headers);
+
+        return $this->_encodeHeaders($this->_headers);
+    }
+
+    /**
+     * Get the text version of the headers
+     * (usefull if you want to use the PHP mail() function)
+     *
+     * @param  array   $xtra_headers Assoc array with any extra headers.
+     *                               Optional.
+     * @return string  Plain text headers
+     * @access public
+     */
+    function txtHeaders($xtra_headers = null)
+    {
+        $headers = $this->headers($xtra_headers);
+        $ret = '';
+        foreach ($headers as $key => $val) {
+            $ret .= "$key: $val" . MAIL_MIME_CRLF;
+        }
+        return $ret;
+    }
+
+    /**
+     * Sets the Subject header
+     *
+     * @param  string $subject String to set the subject to
+     * access  public
+     */
+    function setSubject($subject)
+    {
+        $this->_headers['Subject'] = $subject;
+    }
+
+    /**
+     * Set an email to the From (the sender) header
+     *
+     * @param  string $email The email direction to add
+     * @access public
+     */
+    function setFrom($email)
+    {
+        $this->_headers['From'] = $email;
+    }
+
+    /**
+     * Add an email to the Cc (carbon copy) header
+     * (multiple calls to this method are allowed)
+     *
+     * @param  string $email The email direction to add
+     * @access public
+     */
+    function addCc($email)
+    {
+        if (isset($this->_headers['Cc'])) {
+            $this->_headers['Cc'] .= ", $email";
+        } else {
+            $this->_headers['Cc'] = $email;
+        }
+    }
+
+    /**
+     * Add an email to the Bcc (blank carbon copy) header
+     * (multiple calls to this method are allowed)
+     *
+     * @param  string $email The email direction to add
+     * @access public
+     */
+    function addBcc($email)
+    {
+        if (isset($this->_headers['Bcc'])) {
+            $this->_headers['Bcc'] .= ", $email";
+        } else {
+            $this->_headers['Bcc'] = $email;
+        }
+    }
+
+    /**
+     * Encodes a header as per RFC2047
+     *
+     * @param  string  $input The header data to encode
+     * @return string  Encoded data
+     * @access private
+     */
+    function _encodeHeaders($input)
+    {
+        foreach ($input as $hdr_name => $hdr_value) {
+            preg_match_all('/(\w*[\x80-\xFF]+\w*)/', $hdr_value, $matches);
+            foreach ($matches[1] as $value) {
+                $replacement = preg_replace('/([\x80-\xFF])/e',
+                                            '"=" .
+                                            strtoupper(dechex(ord("\1")))',
+                                            $value);
+                $hdr_value = str_replace($value, '=?' .
+                                         $this->_build_params['head_charset'] .
+                                         '?Q?' . $replacement . '?=',
+                                         $hdr_value);
+            }
+            $input[$hdr_name] = $hdr_value;
+        }
+
+        return $input;
+    }
+
+    /**
+     * Set the object's end-of-line and define the constant if applicable
+     *
+     * @param string $eol End Of Line sequence
+     * @access private
+     */
+    function _setEOL($eol)
+    {
+        $this->_eol = $eol;
+        if (!defined('MAIL_MIME_CRLF')) {
+            define('MAIL_MIME_CRLF', $this->_eol, true);
+        }
+    }
+
+    
+
+} // End of class
+?>
diff --git a/Mail/mimeDecode.php b/Mail/mimeDecode.php
new file mode 100644
index 0000000..3ddcf0f
--- /dev/null
+++ b/Mail/mimeDecode.php
@@ -0,0 +1,837 @@
+<?php
+/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003  Richard Heyes                                |
+// | Copyright (c) 2003-2005  The PHP Group                                |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// +-----------------------------------------------------------------------+
+
+require_once 'PEAR.php';
+
+/**
+*  +----------------------------- IMPORTANT ------------------------------+
+*  | Usage of this class compared to native php extensions such as        |
+*  | mailparse or imap, is slow and may be feature deficient. If available|
+*  | you are STRONGLY recommended to use the php extensions.              |
+*  +----------------------------------------------------------------------+
+*
+* Mime Decoding class
+*
+* This class will parse a raw mime email and return
+* the structure. Returned structure is similar to
+* that returned by imap_fetchstructure().
+*
+* USAGE: (assume $input is your raw email)
+*
+* $decode = new Mail_mimeDecode($input, "\r\n");
+* $structure = $decode->decode();
+* print_r($structure);
+*
+* Or statically:
+*
+* $params['input'] = $input;
+* $structure = Mail_mimeDecode::decode($params);
+* print_r($structure);
+*
+* TODO:
+*  o Implement multipart/appledouble
+*  o UTF8: ???
+
+		> 4. We have also found a solution for decoding the UTF-8 
+		> headers. Therefore I made the following function:
+		> 
+		> function decode_utf8($txt) {
+		> $trans=array("Å&#8216;"=>"Ãµ","Å±"=>"Ã»","Å?"=>"Ã&#8226;","Å°"
+		=>"Ã&#8250;");
+		> $txt=strtr($txt,$trans);
+		> return(utf8_decode($txt));
+		> }
+		> 
+		> And I have inserted the following line to the class:
+		> 
+		> if (strtolower($charset)=="utf-8") $text=decode_utf8($text);
+		> 
+		> ... before the following one in the "_decodeHeader" function:
+		> 
+		> $input = str_replace($encoded, $text, $input);
+		> 
+		> This way from now on it can easily decode the UTF-8 headers too.
+
+*
+* @author  Richard Heyes <richard@phpguru.org>
+* @version $Revision: 1.46 $
+* @package Mail
+*/
+class Mail_mimeDecode extends PEAR
+{
+    /**
+     * The raw email to decode
+     * @var    string
+     */
+    var $_input;
+
+    /**
+     * The header part of the input
+     * @var    string
+     */
+    var $_header;
+
+    /**
+     * The body part of the input
+     * @var    string
+     */
+    var $_body;
+
+    /**
+     * If an error occurs, this is used to store the message
+     * @var    string
+     */
+    var $_error;
+
+    /**
+     * Flag to determine whether to include bodies in the
+     * returned object.
+     * @var    boolean
+     */
+    var $_include_bodies;
+
+    /**
+     * Flag to determine whether to decode bodies
+     * @var    boolean
+     */
+    var $_decode_bodies;
+
+    /**
+     * Flag to determine whether to decode headers
+     * @var    boolean
+     */
+    var $_decode_headers;
+
+    /**
+     * Constructor.
+     *
+     * Sets up the object, initialise the variables, and splits and
+     * stores the header and body of the input.
+     *
+     * @param string The input to decode
+     * @access public
+     */
+    function Mail_mimeDecode($input)
+    {
+        list($header, $body)   = $this->_splitBodyHeader($input);
+
+        $this->_input          = $input;
+        $this->_header         = $header;
+        $this->_body           = $body;
+        $this->_decode_bodies  = false;
+        $this->_include_bodies = true;
+    }
+
+    /**
+     * Begins the decoding process. If called statically
+     * it will create an object and call the decode() method
+     * of it.
+     *
+     * @param array An array of various parameters that determine
+     *              various things:
+     *              include_bodies - Whether to include the body in the returned
+     *                               object.
+     *              decode_bodies  - Whether to decode the bodies
+     *                               of the parts. (Transfer encoding)
+     *              decode_headers - Whether to decode headers
+     *              input          - If called statically, this will be treated
+     *                               as the input
+     * @return object Decoded results
+     * @access public
+     */
+    function decode($params = null)
+    {
+        // determine if this method has been called statically
+        $isStatic = !(isset($this) && get_class($this) == __CLASS__);
+
+        // Have we been called statically?
+	// If so, create an object and pass details to that.
+        if ($isStatic AND isset($params['input'])) {
+
+            $obj = new Mail_mimeDecode($params['input']);
+            $structure = $obj->decode($params);
+
+        // Called statically but no input
+        } elseif ($isStatic) {
+            return PEAR::raiseError('Called statically and no input given');
+
+        // Called via an object
+        } else {
+            $this->_include_bodies = isset($params['include_bodies']) ?
+	                             $params['include_bodies'] : false;
+            $this->_decode_bodies  = isset($params['decode_bodies']) ?
+	                             $params['decode_bodies']  : false;
+            $this->_decode_headers = isset($params['decode_headers']) ?
+	                             $params['decode_headers'] : false;
+
+            $structure = $this->_decode($this->_header, $this->_body);
+            if ($structure === false) {
+                $structure = $this->raiseError($this->_error);
+            }
+        }
+
+        return $structure;
+    }
+
+    /**
+     * Performs the decoding. Decodes the body string passed to it
+     * If it finds certain content-types it will call itself in a
+     * recursive fashion
+     *
+     * @param string Header section
+     * @param string Body section
+     * @return object Results of decoding process
+     * @access private
+     */
+    function _decode($headers, $body, $default_ctype = 'text/plain')
+    {
+        $return = new stdClass;
+        $return->headers = array();
+        $headers = $this->_parseHeaders($headers);
+
+        foreach ($headers as $value) {
+            if (isset($return->headers[strtolower($value['name'])]) AND !is_array($return->headers[strtolower($value['name'])])) {
+                $return->headers[strtolower($value['name'])]   = array($return->headers[strtolower($value['name'])]);
+                $return->headers[strtolower($value['name'])][] = $value['value'];
+
+            } elseif (isset($return->headers[strtolower($value['name'])])) {
+                $return->headers[strtolower($value['name'])][] = $value['value'];
+
+            } else {
+                $return->headers[strtolower($value['name'])] = $value['value'];
+            }
+        }
+
+        reset($headers);
+        while (list($key, $value) = each($headers)) {
+            $headers[$key]['name'] = strtolower($headers[$key]['name']);
+            switch ($headers[$key]['name']) {
+
+                case 'content-type':
+                    $content_type = $this->_parseHeaderValue($headers[$key]['value']);
+
+                    if (preg_match('/([0-9a-z+.-]+)\/([0-9a-z+.-]+)/i', $content_type['value'], $regs)) {
+                        $return->ctype_primary   = $regs[1];
+                        $return->ctype_secondary = $regs[2];
+                    }
+
+                    if (isset($content_type['other'])) {
+                        while (list($p_name, $p_value) = each($content_type['other'])) {
+                            $return->ctype_parameters[$p_name] = $p_value;
+                        }
+                    }
+                    break;
+
+                case 'content-disposition':
+                    $content_disposition = $this->_parseHeaderValue($headers[$key]['value']);
+                    $return->disposition   = $content_disposition['value'];
+                    if (isset($content_disposition['other'])) {
+                        while (list($p_name, $p_value) = each($content_disposition['other'])) {
+                            $return->d_parameters[$p_name] = $p_value;
+                        }
+                    }
+                    break;
+
+                case 'content-transfer-encoding':
+                    $content_transfer_encoding = $this->_parseHeaderValue($headers[$key]['value']);
+                    break;
+            }
+        }
+
+        if (isset($content_type)) {
+            switch (strtolower($content_type['value'])) {
+                case 'text/plain':
+                    $encoding = isset($content_transfer_encoding) ? $content_transfer_encoding['value'] : '7bit';
+                    $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body, $encoding) : $body) : null;
+                    break;
+
+                case 'text/html':
+                    $encoding = isset($content_transfer_encoding) ? $content_transfer_encoding['value'] : '7bit';
+                    $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body, $encoding) : $body) : null;
+                    break;
+
+                case 'multipart/parallel':
+                case 'multipart/report': // RFC1892
+                case 'multipart/signed': // PGP
+                case 'multipart/digest':
+                case 'multipart/alternative':
+                case 'multipart/related':
+                case 'multipart/mixed':
+                    if(!isset($content_type['other']['boundary'])){
+                        $this->_error = 'No boundary found for ' . $content_type['value'] . ' part';
+                        return false;
+                    }
+
+                    $default_ctype = (strtolower($content_type['value']) === 'multipart/digest') ? 'message/rfc822' : 'text/plain';
+
+                    $parts = $this->_boundarySplit($body, $content_type['other']['boundary']);
+                    for ($i = 0; $i < count($parts); $i++) {
+                        list($part_header, $part_body) = $this->_splitBodyHeader($parts[$i]);
+                        $part = $this->_decode($part_header, $part_body, $default_ctype);
+                        if($part === false)
+                            $part = $this->raiseError($this->_error);
+                        $return->parts[] = $part;
+                    }
+                    break;
+
+                case 'message/rfc822':
+                    $obj = &new Mail_mimeDecode($body);
+                    $return->parts[] = $obj->decode(array('include_bodies' => $this->_include_bodies,
+					                                      'decode_bodies'  => $this->_decode_bodies,
+														  'decode_headers' => $this->_decode_headers));
+                    unset($obj);
+                    break;
+
+                default:
+                    if(!isset($content_transfer_encoding['value']))
+                        $content_transfer_encoding['value'] = '7bit';
+                    $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body, $content_transfer_encoding['value']) : $body) : null;
+                    break;
+            }
+
+        } else {
+            $ctype = explode('/', $default_ctype);
+            $return->ctype_primary   = $ctype[0];
+            $return->ctype_secondary = $ctype[1];
+            $this->_include_bodies ? $return->body = ($this->_decode_bodies ? $this->_decodeBody($body) : $body) : null;
+        }
+
+        return $return;
+    }
+
+    /**
+     * Given the output of the above function, this will return an
+     * array of references to the parts, indexed by mime number.
+     *
+     * @param  object $structure   The structure to go through
+     * @param  string $mime_number Internal use only.
+     * @return array               Mime numbers
+     */
+    function &getMimeNumbers(&$structure, $no_refs = false, $mime_number = '', $prepend = '')
+    {
+        $return = array();
+        if (!empty($structure->parts)) {
+            if ($mime_number != '') {
+                $structure->mime_id = $prepend . $mime_number;
+                $return[$prepend . $mime_number] = &$structure;
+            }
+            for ($i = 0; $i < count($structure->parts); $i++) {
+
+            
+                if (!empty($structure->headers['content-type']) AND substr(strtolower($structure->headers['content-type']), 0, 8) == 'message/') {
+                    $prepend      = $prepend . $mime_number . '.';
+                    $_mime_number = '';
+                } else {
+                    $_mime_number = ($mime_number == '' ? $i + 1 : sprintf('%s.%s', $mime_number, $i + 1));
+                }
+
+                $arr = &Mail_mimeDecode::getMimeNumbers($structure->parts[$i], $no_refs, $_mime_number, $prepend);
+                foreach ($arr as $key => $val) {
+                    $no_refs ? $return[$key] = '' : $return[$key] = &$arr[$key];
+                }
+            }
+        } else {
+            if ($mime_number == '') {
+                $mime_number = '1';
+            }
+            $structure->mime_id = $prepend . $mime_number;
+            $no_refs ? $return[$prepend . $mime_number] = '' : $return[$prepend . $mime_number] = &$structure;
+        }
+        
+        return $return;
+    }
+
+    /**
+     * Given a string containing a header and body
+     * section, this function will split them (at the first
+     * blank line) and return them.
+     *
+     * @param string Input to split apart
+     * @return array Contains header and body section
+     * @access private
+     */
+    function _splitBodyHeader($input)
+    {
+        if (preg_match("/^(.*?)\r?\n\r?\n(.*)/s", $input, $match)) {
+            return array($match[1], $match[2]);
+        }
+        $this->_error = 'Could not split header and body';
+        return false;
+    }
+
+    /**
+     * Parse headers given in $input and return
+     * as assoc array.
+     *
+     * @param string Headers to parse
+     * @return array Contains parsed headers
+     * @access private
+     */
+    function _parseHeaders($input)
+    {
+
+        if ($input !== '') {
+            // Unfold the input
+            $input   = preg_replace("/\r?\n/", "\r\n", $input);
+            $input   = preg_replace("/\r\n(\t| )+/", ' ', $input);
+            $headers = explode("\r\n", trim($input));
+
+            foreach ($headers as $value) {
+                $hdr_name = substr($value, 0, $pos = strpos($value, ':'));
+                $hdr_value = substr($value, $pos+1);
+                if($hdr_value[0] == ' ')
+                    $hdr_value = substr($hdr_value, 1);
+
+                $return[] = array(
+                                  'name'  => $hdr_name,
+                                  'value' => $this->_decode_headers ? $this->_decodeHeader($hdr_value) : $hdr_value
+                                 );
+            }
+        } else {
+            $return = array();
+        }
+
+        return $return;
+    }
+
+    /**
+     * Function to parse a header value,
+     * extract first part, and any secondary
+     * parts (after ;) This function is not as
+     * robust as it could be. Eg. header comments
+     * in the wrong place will probably break it.
+     *
+     * @param string Header value to parse
+     * @return array Contains parsed result
+     * @access private
+     */
+    function _parseHeaderValue($input)
+    {
+
+        if (($pos = strpos($input, ';')) !== false) {
+
+            $return['value'] = trim(substr($input, 0, $pos));
+            $input = trim(substr($input, $pos+1));
+
+            if (strlen($input) > 0) {
+
+                // This splits on a semi-colon, if there's no preceeding backslash
+                // Now works with quoted values; had to glue the \; breaks in PHP
+                // the regex is already bordering on incomprehensible
+                $splitRegex = '/([^;\'"]*[\'"]([^\'"]*([^\'"]*)*)[\'"][^;\'"]*|([^;]+))(;|$)/';
+                preg_match_all($splitRegex, $input, $matches);
+                $parameters = array();
+                for ($i=0; $i<count($matches[0]); $i++) {
+                    $param = $matches[0][$i];
+                    while (substr($param, -2) == '\;') {
+                        $param .= $matches[0][++$i];
+                    }
+                    $parameters[] = $param;
+                }
+
+                for ($i = 0; $i < count($parameters); $i++) {
+                    $param_name  = trim(substr($parameters[$i], 0, $pos = strpos($parameters[$i], '=')), "'\";\t\\ ");
+                    $param_value = trim(str_replace('\;', ';', substr($parameters[$i], $pos + 1)), "'\";\t\\ ");
+                    if ($param_value[0] == '"') {
+                        $param_value = substr($param_value, 1, -1);
+                    }
+                    $return['other'][$param_name] = $param_value;
+                    $return['other'][strtolower($param_name)] = $param_value;
+                }
+            }
+        } else {
+            $return['value'] = trim($input);
+        }
+
+        return $return;
+    }
+
+    /**
+     * This function splits the input based
+     * on the given boundary
+     *
+     * @param string Input to parse
+     * @return array Contains array of resulting mime parts
+     * @access private
+     */
+    function _boundarySplit($input, $boundary)
+    {
+        $parts = array();
+
+        $bs_possible = substr($boundary, 2, -2);
+        $bs_check = '\"' . $bs_possible . '\"';
+
+        if ($boundary == $bs_check) {
+            $boundary = $bs_possible;
+        }
+
+        $tmp = explode('--' . $boundary, $input);
+
+        for ($i = 1; $i < count($tmp) - 1; $i++) {
+            $parts[] = $tmp[$i];
+        }
+
+        return $parts;
+    }
+
+    /**
+     * Given a header, this function will decode it
+     * according to RFC2047. Probably not *exactly*
+     * conformant, but it does pass all the given
+     * examples (in RFC2047).
+     *
+     * @param string Input header value to decode
+     * @return string Decoded header value
+     * @access private
+     */
+    function _decodeHeader($input)
+    {
+        // Remove white space between encoded-words
+        $input = preg_replace('/(=\?[^?]+\?(q|b)\?[^?]*\?=)(\s)+=\?/i', '\1=?', $input);
+
+        // For each encoded-word...
+        while (preg_match('/(=\?([^?]+)\?(q|b)\?([^?]*)\?=)/i', $input, $matches)) {
+
+            $encoded  = $matches[1];
+            $charset  = $matches[2];
+            $encoding = $matches[3];
+            $text     = $matches[4];
+
+            switch (strtolower($encoding)) {
+                case 'b':
+                    $text = base64_decode($text);
+                    break;
+
+                case 'q':
+                    $text = str_replace('_', ' ', $text);
+                    preg_match_all('/=([a-f0-9]{2})/i', $text, $matches);
+                    foreach($matches[1] as $value)
+                        $text = str_replace('='.$value, chr(hexdec($value)), $text);
+                    break;
+            }
+
+            $input = str_replace($encoded, $text, $input);
+        }
+
+        return $input;
+    }
+
+    /**
+     * Given a body string and an encoding type,
+     * this function will decode and return it.
+     *
+     * @param  string Input body to decode
+     * @param  string Encoding type to use.
+     * @return string Decoded body
+     * @access private
+     */
+    function _decodeBody($input, $encoding = '7bit')
+    {
+        switch (strtolower($encoding)) {
+            case '7bit':
+                return $input;
+                break;
+
+            case 'quoted-printable':
+                return $this->_quotedPrintableDecode($input);
+                break;
+
+            case 'base64':
+                return base64_decode($input);
+                break;
+
+            default:
+                return $input;
+        }
+    }
+
+    /**
+     * Given a quoted-printable string, this
+     * function will decode and return it.
+     *
+     * @param  string Input body to decode
+     * @return string Decoded body
+     * @access private
+     */
+    function _quotedPrintableDecode($input)
+    {
+        // Remove soft line breaks
+        $input = preg_replace("/=\r?\n/", '', $input);
+
+        // Replace encoded characters
+		$input = preg_replace('/=([a-f0-9]{2})/ie', "chr(hexdec('\\1'))", $input);
+
+        return $input;
+    }
+
+    /**
+     * Checks the input for uuencoded files and returns
+     * an array of them. Can be called statically, eg:
+     *
+     * $files =& Mail_mimeDecode::uudecode($some_text);
+     *
+     * It will check for the begin 666 ... end syntax
+     * however and won't just blindly decode whatever you
+     * pass it.
+     *
+     * @param  string Input body to look for attahcments in
+     * @return array  Decoded bodies, filenames and permissions
+     * @access public
+     * @author Unknown
+     */
+    function &uudecode($input)
+    {
+        // Find all uuencoded sections
+        preg_match_all("/begin ([0-7]{3}) (.+)\r?\n(.+)\r?\nend/Us", $input, $matches);
+
+        for ($j = 0; $j < count($matches[3]); $j++) {
+
+            $str      = $matches[3][$j];
+            $filename = $matches[2][$j];
+            $fileperm = $matches[1][$j];
+
+            $file = '';
+            $str = preg_split("/\r?\n/", trim($str));
+            $strlen = count($str);
+
+            for ($i = 0; $i < $strlen; $i++) {
+                $pos = 1;
+                $d = 0;
+                $len=(int)(((ord(substr($str[$i],0,1)) -32) - ' ') & 077);
+
+                while (($d + 3 <= $len) AND ($pos + 4 <= strlen($str[$i]))) {
+                    $c0 = (ord(substr($str[$i],$pos,1)) ^ 0x20);
+                    $c1 = (ord(substr($str[$i],$pos+1,1)) ^ 0x20);
+                    $c2 = (ord(substr($str[$i],$pos+2,1)) ^ 0x20);
+                    $c3 = (ord(substr($str[$i],$pos+3,1)) ^ 0x20);
+                    $file .= chr(((($c0 - ' ') & 077) << 2) | ((($c1 - ' ') & 077) >> 4));
+
+                    $file .= chr(((($c1 - ' ') & 077) << 4) | ((($c2 - ' ') & 077) >> 2));
+
+                    $file .= chr(((($c2 - ' ') & 077) << 6) |  (($c3 - ' ') & 077));
+
+                    $pos += 4;
+                    $d += 3;
+                }
+
+                if (($d + 2 <= $len) && ($pos + 3 <= strlen($str[$i]))) {
+                    $c0 = (ord(substr($str[$i],$pos,1)) ^ 0x20);
+                    $c1 = (ord(substr($str[$i],$pos+1,1)) ^ 0x20);
+                    $c2 = (ord(substr($str[$i],$pos+2,1)) ^ 0x20);
+                    $file .= chr(((($c0 - ' ') & 077) << 2) | ((($c1 - ' ') & 077) >> 4));
+
+                    $file .= chr(((($c1 - ' ') & 077) << 4) | ((($c2 - ' ') & 077) >> 2));
+
+                    $pos += 3;
+                    $d += 2;
+                }
+
+                if (($d + 1 <= $len) && ($pos + 2 <= strlen($str[$i]))) {
+                    $c0 = (ord(substr($str[$i],$pos,1)) ^ 0x20);
+                    $c1 = (ord(substr($str[$i],$pos+1,1)) ^ 0x20);
+                    $file .= chr(((($c0 - ' ') & 077) << 2) | ((($c1 - ' ') & 077) >> 4));
+
+                }
+            }
+            $files[] = array('filename' => $filename, 'fileperm' => $fileperm, 'filedata' => $file);
+        }
+
+        return $files;
+    }
+
+    /**
+     * getSendArray() returns the arguments required for Mail::send()
+     * used to build the arguments for a mail::send() call 
+     *
+     * Usage:
+     * $mailtext = Full email (for example generated by a template)
+     * $decoder = new Mail_mimeDecode($mailtext);
+     * $parts =  $decoder->getSendArray();
+     * if (!PEAR::isError($parts) {
+     *     list($recipents,$headers,$body) = $parts;
+     *     $mail = Mail::factory('smtp');
+     *     $mail->send($recipents,$headers,$body);
+     * } else {
+     *     echo $parts->message;
+     * }
+     * @return mixed   array of recipeint, headers,body or Pear_Error
+     * @access public
+     * @author Alan Knowles <alan@akbkhome.com>
+     */
+    function getSendArray()
+    {
+        // prevent warning if this is not set
+        $this->_decode_headers = FALSE;
+        $headerlist =$this->_parseHeaders($this->_header);
+        $to = "";
+        if (!$headerlist) {
+            return $this->raiseError("Message did not contain headers");
+        }
+        foreach($headerlist as $item) {
+            $header[$item['name']] = $item['value'];
+            switch (strtolower($item['name'])) {
+                case "to":
+                case "cc":
+                case "bcc":
+                    $to = ",".$item['value'];
+                default:
+                   break;
+            }
+        }
+        if ($to == "") {
+            return $this->raiseError("Message did not contain any recipents");
+        }
+        $to = substr($to,1);
+        return array($to,$header,$this->_body);
+    } 
+
+    /**
+     * Returns a xml copy of the output of
+     * Mail_mimeDecode::decode. Pass the output in as the
+     * argument. This function can be called statically. Eg:
+     *
+     * $output = $obj->decode();
+     * $xml    = Mail_mimeDecode::getXML($output);
+     *
+     * The DTD used for this should have been in the package. Or
+     * alternatively you can get it from cvs, or here:
+     * http://www.phpguru.org/xmail/xmail.dtd.
+     *
+     * @param  object Input to convert to xml. This should be the
+     *                output of the Mail_mimeDecode::decode function
+     * @return string XML version of input
+     * @access public
+     */
+    function getXML($input)
+    {
+        $crlf    =  "\r\n";
+        $output  = '<?xml version=\'1.0\'?>' . $crlf .
+                   '<!DOCTYPE email SYSTEM "http://www.phpguru.org/xmail/xmail.dtd">' . $crlf .
+                   '<email>' . $crlf .
+                   Mail_mimeDecode::_getXML($input) .
+                   '</email>';
+
+        return $output;
+    }
+
+    /**
+     * Function that does the actual conversion to xml. Does a single
+     * mimepart at a time.
+     *
+     * @param  object  Input to convert to xml. This is a mimepart object.
+     *                 It may or may not contain subparts.
+     * @param  integer Number of tabs to indent
+     * @return string  XML version of input
+     * @access private
+     */
+    function _getXML($input, $indent = 1)
+    {
+        $htab    =  "\t";
+        $crlf    =  "\r\n";
+        $output  =  '';
+        $headers = @(array)$input->headers;
+
+        foreach ($headers as $hdr_name => $hdr_value) {
+
+            // Multiple headers with this name
+            if (is_array($headers[$hdr_name])) {
+                for ($i = 0; $i < count($hdr_value); $i++) {
+                    $output .= Mail_mimeDecode::_getXML_helper($hdr_name, $hdr_value[$i], $indent);
+                }
+
+            // Only one header of this sort
+            } else {
+                $output .= Mail_mimeDecode::_getXML_helper($hdr_name, $hdr_value, $indent);
+            }
+        }
+
+        if (!empty($input->parts)) {
+            for ($i = 0; $i < count($input->parts); $i++) {
+                $output .= $crlf . str_repeat($htab, $indent) . '<mimepart>' . $crlf .
+                           Mail_mimeDecode::_getXML($input->parts[$i], $indent+1) .
+                           str_repeat($htab, $indent) . '</mimepart>' . $crlf;
+            }
+        } elseif (isset($input->body)) {
+            $output .= $crlf . str_repeat($htab, $indent) . '<body><![CDATA[' .
+                       $input->body . ']]></body>' . $crlf;
+        }
+
+        return $output;
+    }
+
+    /**
+     * Helper function to _getXML(). Returns xml of a header.
+     *
+     * @param  string  Name of header
+     * @param  string  Value of header
+     * @param  integer Number of tabs to indent
+     * @return string  XML version of input
+     * @access private
+     */
+    function _getXML_helper($hdr_name, $hdr_value, $indent)
+    {
+        $htab   = "\t";
+        $crlf   = "\r\n";
+        $return = '';
+
+        $new_hdr_value = ($hdr_name != 'received') ? Mail_mimeDecode::_parseHeaderValue($hdr_value) : array('value' => $hdr_value);
+        $new_hdr_name  = str_replace(' ', '-', ucwords(str_replace('-', ' ', $hdr_name)));
+
+        // Sort out any parameters
+        if (!empty($new_hdr_value['other'])) {
+            foreach ($new_hdr_value['other'] as $paramname => $paramvalue) {
+                $params[] = str_repeat($htab, $indent) . $htab . '<parameter>' . $crlf .
+                            str_repeat($htab, $indent) . $htab . $htab . '<paramname>' . htmlspecialchars($paramname) . '</paramname>' . $crlf .
+                            str_repeat($htab, $indent) . $htab . $htab . '<paramvalue>' . htmlspecialchars($paramvalue) . '</paramvalue>' . $crlf .
+                            str_repeat($htab, $indent) . $htab . '</parameter>' . $crlf;
+            }
+
+            $params = implode('', $params);
+        } else {
+            $params = '';
+        }
+
+        $return = str_repeat($htab, $indent) . '<header>' . $crlf .
+                  str_repeat($htab, $indent) . $htab . '<headername>' . htmlspecialchars($new_hdr_name) . '</headername>' . $crlf .
+                  str_repeat($htab, $indent) . $htab . '<headervalue>' . htmlspecialchars($new_hdr_value['value']) . '</headervalue>' . $crlf .
+                  $params .
+                  str_repeat($htab, $indent) . '</header>' . $crlf;
+
+        return $return;
+    }
+
+} // End of class
+?>
diff --git a/Mail/mimePart.php b/Mail/mimePart.php
new file mode 100644
index 0000000..c0050d4
--- /dev/null
+++ b/Mail/mimePart.php
@@ -0,0 +1,351 @@
+<?php
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003  Richard Heyes                                     |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// +-----------------------------------------------------------------------+
+
+/**
+*
+*  Raw mime encoding class
+*
+* What is it?
+*   This class enables you to manipulate and build
+*   a mime email from the ground up.
+*
+* Why use this instead of mime.php?
+*   mime.php is a userfriendly api to this class for
+*   people who aren't interested in the internals of
+*   mime mail. This class however allows full control
+*   over the email.
+*
+* Eg.
+*
+* // Since multipart/mixed has no real body, (the body is
+* // the subpart), we set the body argument to blank.
+*
+* $params['content_type'] = 'multipart/mixed';
+* $email = new Mail_mimePart('', $params);
+*
+* // Here we add a text part to the multipart we have
+* // already. Assume $body contains plain text.
+*
+* $params['content_type'] = 'text/plain';
+* $params['encoding']     = '7bit';
+* $text = $email->addSubPart($body, $params);
+*
+* // Now add an attachment. Assume $attach is
+* the contents of the attachment
+*
+* $params['content_type'] = 'application/zip';
+* $params['encoding']     = 'base64';
+* $params['disposition']  = 'attachment';
+* $params['dfilename']    = 'example.zip';
+* $attach =& $email->addSubPart($body, $params);
+*
+* // Now build the email. Note that the encode
+* // function returns an associative array containing two
+* // elements, body and headers. You will need to add extra
+* // headers, (eg. Mime-Version) before sending.
+*
+* $email = $message->encode();
+* $email['headers'][] = 'Mime-Version: 1.0';
+*
+*
+* Further examples are available at http://www.phpguru.org
+*
+* TODO:
+*  - Set encode() to return the $obj->encoded if encode()
+*    has already been run. Unless a flag is passed to specifically
+*    re-build the message.
+*
+* @author  Richard Heyes <richard@phpguru.org>
+* @version $Revision: 1.13 $
+* @package Mail
+*/
+
+class Mail_mimePart {
+
+   /**
+    * The encoding type of this part
+    * @var string
+    */
+    var $_encoding;
+
+   /**
+    * An array of subparts
+    * @var array
+    */
+    var $_subparts;
+
+   /**
+    * The output of this part after being built
+    * @var string
+    */
+    var $_encoded;
+
+   /**
+    * Headers for this part
+    * @var array
+    */
+    var $_headers;
+
+   /**
+    * The body of this part (not encoded)
+    * @var string
+    */
+    var $_body;
+
+    /**
+     * Constructor.
+     *
+     * Sets up the object.
+     *
+     * @param $body   - The body of the mime part if any.
+     * @param $params - An associative array of parameters:
+     *                  content_type - The content type for this part eg multipart/mixed
+     *                  encoding     - The encoding to use, 7bit, 8bit, base64, or quoted-printable
+     *                  cid          - Content ID to apply
+     *                  disposition  - Content disposition, inline or attachment
+     *                  dfilename    - Optional filename parameter for content disposition
+     *                  description  - Content description
+     *                  charset      - Character set to use
+     * @access public
+     */
+    function Mail_mimePart($body = '', $params = array())
+    {
+        if (!defined('MAIL_MIMEPART_CRLF')) {
+            define('MAIL_MIMEPART_CRLF', defined('MAIL_MIME_CRLF') ? MAIL_MIME_CRLF : "\r\n", TRUE);
+        }
+
+        foreach ($params as $key => $value) {
+            switch ($key) {
+                case 'content_type':
+                    $headers['Content-Type'] = $value . (isset($charset) ? '; charset="' . $charset . '"' : '');
+                    break;
+
+                case 'encoding':
+                    $this->_encoding = $value;
+                    $headers['Content-Transfer-Encoding'] = $value;
+                    break;
+
+                case 'cid':
+                    $headers['Content-ID'] = '<' . $value . '>';
+                    break;
+
+                case 'disposition':
+                    $headers['Content-Disposition'] = $value . (isset($dfilename) ? '; filename="' . $dfilename . '"' : '');
+                    break;
+
+                case 'dfilename':
+                    if (isset($headers['Content-Disposition'])) {
+                        $headers['Content-Disposition'] .= '; filename="' . $value . '"';
+                    } else {
+                        $dfilename = $value;
+                    }
+                    break;
+
+                case 'description':
+                    $headers['Content-Description'] = $value;
+                    break;
+
+                case 'charset':
+                    if (isset($headers['Content-Type'])) {
+                        $headers['Content-Type'] .= '; charset="' . $value . '"';
+                    } else {
+                        $charset = $value;
+                    }
+                    break;
+            }
+        }
+
+        // Default content-type
+        if (!isset($headers['Content-Type'])) {
+            $headers['Content-Type'] = 'text/plain';
+        }
+
+        //Default encoding
+        if (!isset($this->_encoding)) {
+            $this->_encoding = '7bit';
+        }
+
+        // Assign stuff to member variables
+        $this->_encoded  = array();
+        $this->_headers  = $headers;
+        $this->_body     = $body;
+    }
+
+    /**
+     * encode()
+     *
+     * Encodes and returns the email. Also stores
+     * it in the encoded member variable
+     *
+     * @return An associative array containing two elements,
+     *         body and headers. The headers element is itself
+     *         an indexed array.
+     * @access public
+     */
+    function encode()
+    {
+        $encoded =& $this->_encoded;
+
+        if (!empty($this->_subparts)) {
+            srand((double)microtime()*1000000);
+            $boundary = '=_' . md5(rand() . microtime());
+            $this->_headers['Content-Type'] .= ';' . MAIL_MIMEPART_CRLF . "\t" . 'boundary="' . $boundary . '"';
+
+            // Add body parts to $subparts
+            for ($i = 0; $i < count($this->_subparts); $i++) {
+                $headers = array();
+                $tmp = $this->_subparts[$i]->encode();
+                foreach ($tmp['headers'] as $key => $value) {
+                    $headers[] = $key . ': ' . $value;
+                }
+                $subparts[] = implode(MAIL_MIMEPART_CRLF, $headers) . MAIL_MIMEPART_CRLF . MAIL_MIMEPART_CRLF . $tmp['body'];
+            }
+
+            $encoded['body'] = '--' . $boundary . MAIL_MIMEPART_CRLF .
+                               implode('--' . $boundary . MAIL_MIMEPART_CRLF, $subparts) .
+                               '--' . $boundary.'--' . MAIL_MIMEPART_CRLF;
+
+        } else {
+            $encoded['body'] = $this->_getEncodedData($this->_body, $this->_encoding) . MAIL_MIMEPART_CRLF;
+        }
+
+        // Add headers to $encoded
+        $encoded['headers'] =& $this->_headers;
+
+        return $encoded;
+    }
+
+    /**
+     * &addSubPart()
+     *
+     * Adds a subpart to current mime part and returns
+     * a reference to it
+     *
+     * @param $body   The body of the subpart, if any.
+     * @param $params The parameters for the subpart, same
+     *                as the $params argument for constructor.
+     * @return A reference to the part you just added. It is
+     *         crucial if using multipart/* in your subparts that
+     *         you use =& in your script when calling this function,
+     *         otherwise you will not be able to add further subparts.
+     * @access public
+     */
+    function &addSubPart($body, $params)
+    {
+        $this->_subparts[] = new Mail_mimePart($body, $params);
+        return $this->_subparts[count($this->_subparts) - 1];
+    }
+
+    /**
+     * _getEncodedData()
+     *
+     * Returns encoded data based upon encoding passed to it
+     *
+     * @param $data     The data to encode.
+     * @param $encoding The encoding type to use, 7bit, base64,
+     *                  or quoted-printable.
+     * @access private
+     */
+    function _getEncodedData($data, $encoding)
+    {
+        switch ($encoding) {
+            case '8bit':
+            case '7bit':
+                return $data;
+                break;
+
+            case 'quoted-printable':
+                return $this->_quotedPrintableEncode($data);
+                break;
+
+            case 'base64':
+                return rtrim(chunk_split(base64_encode($data), 76, MAIL_MIMEPART_CRLF));
+                break;
+
+            default:
+                return $data;
+        }
+    }
+
+    /**
+     * quoteadPrintableEncode()
+     *
+     * Encodes data to quoted-printable standard.
+     *
+     * @param $input    The data to encode
+     * @param $line_max Optional max line length. Should
+     *                  not be more than 76 chars
+     *
+     * @access private
+     */
+    function _quotedPrintableEncode($input , $line_max = 76)
+    {
+        $lines  = preg_split("/\r?\n/", $input);
+        $eol    = MAIL_MIMEPART_CRLF;
+        $escape = '=';
+        $output = '';
+
+        while(list(, $line) = each($lines)){
+
+            $linlen     = strlen($line);
+            $newline = '';
+
+            for ($i = 0; $i < $linlen; $i++) {
+                $char = substr($line, $i, 1);
+                $dec  = ord($char);
+
+                if (($dec == 32) AND ($i == ($linlen - 1))){    // convert space at eol only
+                    $char = '=20';
+
+                } elseif(($dec == 9) AND ($i == ($linlen - 1))) {  // convert tab at eol only
+                    $char = '=09';
+                } elseif($dec == 9) {
+                    ; // Do nothing if a tab.
+                } elseif(($dec == 61) OR ($dec < 32 ) OR ($dec > 126)) {
+                    $char = $escape . strtoupper(sprintf('%02s', dechex($dec)));
+                }
+
+                if ((strlen($newline) + strlen($char)) >= $line_max) {        // MAIL_MIMEPART_CRLF is not counted
+                    $output  .= $newline . $escape . $eol;                    // soft line break; " =\r\n" is okay
+                    $newline  = '';
+                }
+                $newline .= $char;
+            } // end of for
+            $output .= $newline . $eol;
+        }
+        $output = substr($output, 0, -1 * strlen($eol)); // Don't want last crlf
+        return $output;
+    }
+} // End of class
+?>
diff --git a/Net/POP3.php b/Net/POP3.php
new file mode 100644
index 0000000..316a142
--- /dev/null
+++ b/Net/POP3.php
@@ -0,0 +1,1226 @@
+<?php
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002, Richard Heyes                                     |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes <richard@phpguru.org>                           |
+// | Co-Author: Damian Fernandez Sosa <damlists@cnba.uba.ar>               |
+// +-----------------------------------------------------------------------+
+//
+// $Id: POP3.php,v 1.2 2004/12/05 16:34:39 damian Exp $
+
+require_once('Net/Socket.php');
+
+
+
+/**
+*  +----------------------------- IMPORTANT ------------------------------+
+*  | Usage of this class compared to native php extensions such as IMAP   |
+*  | is slow and may be feature deficient. If available you are STRONGLY  |
+*  | recommended to use the php extensions.                               |
+*  +----------------------------------------------------------------------+
+*
+* POP3 Access Class
+*
+* For usage see the example script
+*/
+
+define('NET_POP3_STATE_DISCONNECTED',  1, true);
+define('NET_POP3_STATE_AUTHORISATION', 2, true);
+define('NET_POP3_STATE_TRANSACTION',   4, true);
+
+class Net_POP3 {
+
+    /*
+    * Some basic information about the mail drop
+    * garnered from the STAT command
+    *
+    * @var array
+    */
+    var $_maildrop;
+
+    /*
+    * Used for APOP to store the timestamp
+    *
+    * @var string
+    */
+    var $_timestamp;
+
+    /*
+    * Timeout that is passed to the socket object
+    *
+    * @var integer
+    */
+    var $_timeout;
+
+    /*
+    * Socket object
+    *
+    * @var object
+    */
+    var $_socket;
+
+    /*
+    * Current state of the connection. Used with the
+    * constants defined above.
+    *
+    * @var integer
+    */
+    var $_state;
+
+    /*
+    * Hostname to connect to
+    *
+    * @var string
+    */
+    var $_host;
+
+    /*
+    * Port to connect to
+    *
+    * @var integer
+    */
+    var $_port;
+
+    /**
+    * To allow class debuging
+    * @var boolean
+    */
+    var $_debug = false;
+
+
+    /**
+    * The auth methods this class support
+    * @var array
+    */
+    //var $supportedAuthMethods=array('DIGEST-MD5', 'CRAM-MD5', 'APOP' , 'PLAIN' , 'LOGIN', 'USER');
+    //Disabling DIGEST-MD5 for now
+    var $supportedAuthMethods=array( 'CRAM-MD5', 'APOP' , 'PLAIN' , 'LOGIN', 'USER');
+    //var $supportedAuthMethods=array( 'CRAM-MD5', 'PLAIN' , 'LOGIN');
+    //var $supportedAuthMethods=array( 'PLAIN' , 'LOGIN');
+
+
+    /**
+    * The auth methods this class support
+    * @var array
+    */
+    var $supportedSASLAuthMethods=array('DIGEST-MD5', 'CRAM-MD5');
+
+
+    /**
+    * The capability response
+    * @var array
+    */
+    var $_capability;
+
+   /*
+    * Constructor. Sets up the object variables, and instantiates
+    * the socket object.
+    *
+    */
+
+
+    function Net_POP3()
+    {
+        $this->_timestamp =  ''; // Used for APOP
+        $this->_maildrop  =  array();
+        $this->_timeout   =  3;
+        $this->_state     =  NET_POP3_STATE_DISCONNECTED;
+        $this->_socket    =& new Net_Socket();
+        /*
+        * Include the Auth_SASL package.  If the package is not available,
+        * we disable the authentication methods that depend upon it.
+        */
+        if ((@include_once 'Auth/SASL.php') == false) {
+            if($this->_debug){
+                echo "AUTH_SASL NOT PRESENT!\n";
+            }
+            foreach($this->supportedSASLAuthMethods as $SASLMethod){
+                $pos = array_search( $SASLMethod, $this->supportedAuthMethods );
+                if($this->_debug){
+                    echo "DISABLING METHOD $SASLMethod\n";
+                }
+                unset($this->supportedAuthMethods[$pos]);
+            }
+        }
+
+
+
+    }
+
+
+    /**
+    * Handles the errors the class can find
+    * on the server
+    *
+    * @access private
+    * @return PEAR_Error
+    */
+
+    function _raiseError($msg, $code =-1)
+    {
+    include_once 'PEAR.php';
+    return PEAR::raiseError($msg, $code);
+    }
+
+
+    
+    /*
+    * Connects to the given host on the given port.
+    * Also looks for the timestamp in the greeting
+    * needed for APOP authentication
+    *
+    * @param  string $host Hostname/IP address to connect to
+    * @param  string $port Port to use to connect to on host
+    * @return bool  Success/Failure
+    */
+    function connect($host = 'localhost', $port = 110)
+    {
+        $this->_host = $host;
+        $this->_port = $port;
+
+        $result = $this->_socket->connect($host, $port, false, $this->_timeout);
+        if ($result === true) {
+            $data = $this->_recvLn();
+
+            if( $this->_checkResponse($data) ){
+            // if the response begins with '+OK' ...
+//            if (@substr(strtoupper($data), 0, 3) == '+OK') {
+                // Check for string matching apop timestamp
+                if (preg_match('/<.+@.+>/U', $data, $matches)) {
+                    $this->_timestamp = $matches[0];
+                }
+                $this->_maildrop = array();
+                $this->_state    = NET_POP3_STATE_AUTHORISATION;
+
+                return true;
+            }
+        }
+
+        $this->_socket->disconnect();
+        return false;
+    }
+
+    /*
+    * Disconnect function. Sends the QUIT command
+    * and closes the socket.
+    *
+    * @return bool Success/Failure
+    */
+    function disconnect()
+    {
+        return $this->_cmdQuit();
+    }
+
+    /*
+    * Performs the login procedure. If there is a timestamp
+    * stored, APOP will be tried first, then basic USER/PASS.
+    *
+    * @param  string $user Username to use
+    * @param  string $pass Password to use
+    * @param  mixed $apop Whether to try APOP first, if used as string you can select the auth methd to use ( $pop3->login('validlogin', 'validpass', "CRAM-MD5");
+    *          Valid methods are: 'DIGEST-MD5','CRAM-MD5','LOGIN','PLAIN','APOP','USER' 
+    * @return mixed  true on Success/ PEAR_ERROR on error
+    */
+    function login($user, $pass, $apop = true)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+
+            if(PEAR::isError($ret= $this->_cmdAuthenticate($user , $pass , $apop ) ) ){
+                return $ret;
+            }
+            if( ! PEAR::isError($ret)){
+                $this->_state = NET_POP3_STATE_TRANSACTION;
+                return true;
+            }
+
+        }
+        return $this->_raiseError('Generic login error' , 1);
+    }
+
+
+
+    /**
+    * Parses the response from the capability command. Stores
+    * the result in $this->_capability
+    *
+    * @access private
+    */
+    function _parseCapability()
+    {
+
+        if(!PEAR::isError($data = $this->_sendCmd('CAPA'))){
+            $data = $this->_getMultiline();
+        }else {
+            // CAPA command not supported, reset data var
+            //  to avoid Notice errors of preg_split on an object
+            $data = '';
+        }
+        $data = preg_split('/\r?\n/', $data, -1, PREG_SPLIT_NO_EMPTY);
+
+        for ($i = 0; $i < count($data); $i++) {
+
+            $capa='';
+            if (preg_match('/^([a-z,\-]+)( ((.*))|$)$/i', $data[$i], $matches)) {
+
+                $capa=strtolower($matches[1]);
+                switch ($capa) {
+                    case 'implementation':
+                        $this->_capability['implementation'] = $matches[3];
+                        break;
+                    case 'sasl':
+                        $this->_capability['sasl'] = preg_split('/\s+/', $matches[3]);
+                        break;
+                    default :
+                        $this->_capability[$capa] = $matches[2];
+                        break;
+                }
+            }
+        }
+    }
+
+
+
+
+    /**
+     * Returns the name of the best authentication method that the server
+     * has advertised.
+     *
+     * @param string if !=null,authenticate with this method ($userMethod).
+     *
+     * @return mixed    Returns a string containing the name of the best
+     *                  supported authentication method or a PEAR_Error object
+     *                  if a failure condition is encountered.
+     * @access private
+     * @since  1.0
+     */
+    function _getBestAuthMethod($userMethod = null)
+    {
+
+/*
+       return 'USER';
+       return 'APOP';
+       return 'DIGEST-MD5';
+       return 'CRAM-MD5';
+*/
+
+
+        $this->_parseCapability();
+
+        //unset($this->_capability['sasl']);
+
+       if( isset($this->_capability['sasl']) ){
+           $serverMethods=$this->_capability['sasl'];
+       }else{
+            $serverMethods=array('USER');
+            // Check for timestamp before attempting APOP
+            if ($this->_timestamp != null)
+            {
+                $serverMethods[] = 'APOP';
+            }
+       }
+
+        if($userMethod !== null && $userMethod !== true ){
+            $methods = array();
+            $methods[] = $userMethod;
+            return $userMethod;
+        }else{
+            $methods = $this->supportedAuthMethods;
+        }
+
+        if( ($methods != null) && ($serverMethods != null)){
+
+            foreach ( $methods as $method ) {
+
+                if ( in_array( $method , $serverMethods ) ) {
+                    return $method;
+                }
+            }
+            $serverMethods=implode(',' , $serverMethods );
+            $myMethods=implode(',' ,$this->supportedAuthMethods);
+            return $this->_raiseError("$method NOT supported authentication method!. This server " .
+                "supports these methods: $serverMethods, but I support $myMethods");
+        }else{
+            return $this->_raiseError("This server don't support any Auth methods");
+        }
+    }
+
+
+
+
+
+
+    /* Handles the authentication using any known method
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     * @param string The method to use ( if $usermethod == '' then the class chooses the best method (the stronger is the best ) )
+     *
+     * @return mixed  string or PEAR_Error
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _cmdAuthenticate($uid , $pwd , $userMethod = null )
+    {
+
+
+        if ( PEAR::isError( $method = $this->_getBestAuthMethod($userMethod) ) ) {
+            return $method;
+        }
+
+        switch ($method) {
+            case 'DIGEST-MD5':
+                $result = $this->_authDigest_MD5( $uid , $pwd );
+                break;
+            case 'CRAM-MD5':
+                $result = $this->_authCRAM_MD5( $uid , $pwd );
+                break;
+            case 'LOGIN':
+                $result = $this->_authLOGIN( $uid , $pwd );
+                break;
+            case 'PLAIN':
+                $result = $this->_authPLAIN( $uid , $pwd );
+                break;
+            case 'APOP':
+                $result = $this->_cmdApop( $uid , $pwd );
+                // if APOP fails fallback to USER auth
+                if( PEAR::isError( $result ) ){
+                    //echo "APOP FAILED!!!\n";
+                    $result=$this->_authUSER( $uid , $pwd );
+                }
+                break;
+            case 'USER':
+                $result = $this->_authUSER( $uid , $pwd );
+            break;
+
+
+            default :
+                $result = $this->_raiseError( "$method is not a supported authentication method" );
+                break;
+        }
+        return $result;
+    }
+
+
+
+
+     /* Authenticates the user using the USER-PASS method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return mixed    true on success or PEAR_Error on failure
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authUSER($user, $pass  )
+    {
+        if ( PEAR::isError($ret=$this->_cmdUser($user) ) ){
+            return $ret;
+        }
+        if ( PEAR::isError($ret=$this->_cmdPass($pass) ) ){
+            return $ret;
+        }
+        return true;
+    }
+
+
+
+
+
+
+
+
+     /* Authenticates the user using the PLAIN method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authPLAIN($user, $pass  )
+    {
+        $cmd=sprintf('AUTH PLAIN %s', base64_encode( chr(0) . $user . chr(0) . $pass ) );
+
+        if ( PEAR::isError( $ret = $this->_send($cmd) ) ) {
+            return $ret;
+        }
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ){
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+        
+        return true;
+    }
+
+
+
+     /* Authenticates the user using the PLAIN method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authLOGIN($user, $pass  )
+    {
+        $this->_send('AUTH LOGIN');
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+
+        if ( PEAR::isError( $ret = $this->_send(sprintf('%s', base64_encode($user))) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+        if ( PEAR::isError( $ret = $this->_send(sprintf('%s', base64_encode($pass))) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        return $this->_checkResponse($challenge);
+    }
+
+
+
+
+
+     /* Authenticates the user using the CRAM-MD5 method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authCRAM_MD5($uid, $pwd )
+    {
+        if ( PEAR::isError( $ret = $this->_send( 'AUTH CRAM-MD5' ) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+        // remove '+ '
+        
+        $challenge=substr($challenge,2);
+        
+        $challenge = base64_decode( $challenge );
+
+        $cram = &Auth_SASL::factory('crammd5');
+        $auth_str = base64_encode( $cram->getResponse( $uid , $pwd , $challenge ) );
+
+
+        if ( PEAR::isError($error = $this->_send( $auth_str ) ) ) {
+            return $error;
+        }
+        if ( PEAR::isError( $ret = $this->_recvLn() ) ) {
+            return $ret;
+        }
+        //echo "RET:$ret\n";
+        return $this->_checkResponse($ret);
+    }
+
+
+
+     /* Authenticates the user using the DIGEST-MD5 method.
+     *
+     * @param string The userid to authenticate as.
+     * @param string The password to authenticate with.
+     * @param string The efective user
+     *
+     * @return array Returns an array containing the response
+     *
+     * @access private
+     * @since  1.0
+     */
+    function _authDigest_MD5($uid, $pwd)
+    {
+        if ( PEAR::isError( $ret = $this->_send( 'AUTH DIGEST-MD5' ) ) ) {
+            return $ret;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+
+        // remove '+ '
+        $challenge=substr($challenge,2);
+
+        $challenge = base64_decode( $challenge );
+        $digest = &Auth_SASL::factory('digestmd5');
+        $auth_str = base64_encode($digest->getResponse($uid, $pwd, $challenge, "localhost", "pop3" ));
+
+        if ( PEAR::isError($error = $this->_send( $auth_str ) ) ) {
+            return $error;
+        }
+
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        if( PEAR::isError($ret=$this->_checkResponse($challenge) )){
+            return $ret;
+        }
+         /*
+         * We don't use the protocol's third step because POP3 doesn't allow
+         * subsequent authentication, so we just silently ignore it.
+         */
+
+        if ( PEAR::isError( $challenge = $this->_send("\r\n") ) ) {
+            return $challenge ;
+        }
+        
+        if ( PEAR::isError( $challenge = $this->_recvLn() ) ) {
+            return $challenge;
+        }
+        
+        return $this->_checkResponse($challenge);
+        
+
+    }
+
+
+
+
+
+
+
+
+
+
+    /*
+    * Sends the APOP command
+    *
+    * @param  $user Username to send
+    * @param  $pass Password to send
+    * @return bool Success/Failure
+    */
+    function _cmdApop($user, $pass)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+
+            if (!empty($this->_timestamp)) {
+                if(PEAR::isError($data = $this->_sendCmd('APOP ' . $user . ' ' . md5($this->_timestamp . $pass)) ) ){
+                    return $data;
+                }
+                $this->_state = NET_POP3_STATE_TRANSACTION;
+                return true;
+            }
+        }
+        return $this->_raiseError('Not In NET_POP3_STATE_AUTHORISATION State1');
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /*
+    * Returns the raw headers of the specified message.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either raw headers or false on error
+    */
+    function getRawHeaders($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_cmdTop($msg_id, 0);
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the  headers of the specified message in an
+    * associative array. Array keys are the header names, array
+    * values are the header values. In the case of multiple headers
+    * having the same names, eg Received:, the array value will be
+    * an indexed array of all the header values.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either array of headers or false on error
+    */
+    function getParsedHeaders($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+
+            $raw_headers = rtrim($this->getRawHeaders($msg_id));
+
+            $raw_headers = preg_replace("/\r\n[ \t]+/", ' ', $raw_headers); // Unfold headers
+            $raw_headers = explode("\r\n", $raw_headers);
+            foreach ($raw_headers as $value) {
+                $name  = substr($value, 0, $pos = strpos($value, ':'));
+                $value = ltrim(substr($value, $pos + 1));
+                if (isset($headers[$name]) AND is_array($headers[$name])) {
+                    $headers[$name][] = $value;
+                } elseif (isset($headers[$name])) {
+                    $headers[$name] = array($headers[$name], $value);
+                } else {
+                    $headers[$name] = $value;
+                }
+            }
+
+            return $headers;
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the body of the message with given message number.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either message body or false on error
+    */
+    function getBody($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            $msg = $this->_cmdRetr($msg_id);
+            return substr($msg, strpos($msg, "\r\n\r\n")+4);
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the entire message with given message number.
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed   Either entire message or false on error
+    */
+    function getMsg($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_cmdRetr($msg_id);
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns the size of the maildrop
+    *
+    * @return mixed Either size of maildrop or false on error
+    */
+    function getSize()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (isset($this->_maildrop['size'])) {
+                return $this->_maildrop['size'];
+            } else {
+                list(, $size) = $this->_cmdStat();
+                return $size;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Returns number of messages in this maildrop
+    *
+    * @return mixed Either number of messages or false on error
+    */
+    function numMsg()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (isset($this->_maildrop['num_msg'])) {
+                return $this->_maildrop['num_msg'];
+            } else {
+                list($num_msg, ) = $this->_cmdStat();
+                return $num_msg;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Marks a message for deletion. Only will be deleted if the
+    * disconnect() method is called.
+    *
+    * @param  integer $msg_id Message to delete
+    * @return bool Success/Failure
+    */
+    function deleteMsg($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_cmdDele($msg_id);
+        }
+
+        return false;
+    }
+
+    /*
+    * Combination of LIST/UIDL commands, returns an array
+    * of data
+    *
+    * @param  integer $msg_id Optional message number
+    * @return mixed Array of data or false on error
+    */
+    function getListing($msg_id = null)
+    {
+    
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (!isset($msg_id)){
+            
+                $list=array();
+                if ($list = $this->_cmdList()) {
+                    if ($uidl = $this->_cmdUidl()) {
+                        foreach ($uidl as $i => $value) {
+                            $list[$i]['uidl'] = $value['uidl'];
+                        }
+                    }
+                    return $list;
+                }else{
+                    return array();
+                }
+            } else {
+                if ($list = $this->_cmdList($msg_id) AND $uidl = $this->_cmdUidl($msg_id)) {
+                    return array_merge($list, $uidl);
+                }
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the USER command
+    *
+    * @param  string $user Username to send
+    * @return bool  Success/Failure
+    */
+    function _cmdUser($user)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+            return $this->_sendCmd('USER ' . $user);
+        }
+        return $this->_raiseError('Not In NET_POP3_STATE_AUTHORISATION State');
+    }
+
+
+    /*
+    * Sends the PASS command
+    *
+    * @param  string $pass Password to send
+    * @return bool  Success/Failure
+    */
+    function _cmdPass($pass)
+    {
+        if ($this->_state == NET_POP3_STATE_AUTHORISATION) {
+            return $this->_sendCmd('PASS ' . $pass);
+        }
+        return $this->_raiseError('Not In NET_POP3_STATE_AUTHORISATION State');
+    }
+
+
+    /*
+    * Sends the STAT command
+    *
+    * @return mixed Indexed array of number of messages and
+    *               maildrop size, or false on error.
+    */
+    function _cmdStat()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('STAT'))){
+                sscanf($data, '+OK %d %d', $msg_num, $size);
+                $this->_maildrop['num_msg'] = $msg_num;
+                $this->_maildrop['size']    = $size;
+
+                return array($msg_num, $size);
+            }
+        }
+        return false;
+    }
+
+
+    /*
+    * Sends the LIST command
+    *
+    * @param  integer $msg_id Optional message number
+    * @return mixed   Indexed array of msg_id/msg size or
+    *                 false on error
+    */
+    function _cmdList($msg_id = null)
+    {
+        $return=array();
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if (!isset($msg_id)) {
+                if(!PEAR::isError($data = $this->_sendCmd('LIST') )){
+                    $data = $this->_getMultiline();
+                    $data = explode("\r\n", $data);                    
+                    foreach ($data as $line) {
+                        if($line !=''){
+                            sscanf($line, '%s %s', $msg_id, $size);
+                            $return[] = array('msg_id' => $msg_id, 'size' => $size);
+                        }
+                    }
+                    return $return;
+                }
+            } else {
+                if(!PEAR::isError($data = $this->_sendCmd('LIST ' . $msg_id))){
+                    if($data!=''){
+                        sscanf($data, '+OK %d %d', $msg_id, $size);
+                        return array('msg_id' => $msg_id, 'size' => $size);
+                    }
+                    return array();
+                }
+            }
+        }
+        
+
+        return false;
+    }
+
+
+    /*
+    * Sends the RETR command
+    *
+    * @param  integer $msg_id The message number to retrieve
+    * @return mixed   The message or false on error
+    */
+    function _cmdRetr($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('RETR ' . $msg_id) )){
+                $data = $this->_getMultiline();
+                return $data;
+            }
+        }
+
+        return false;
+    }
+
+
+    /*
+    * Sends the DELE command
+    *
+    * @param  integer $msg_id Message number to mark as deleted
+    * @return bool Success/Failure
+    */
+    function _cmdDele($msg_id)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            return $this->_sendCmd('DELE ' . $msg_id);
+        }
+
+        return false;
+    }
+
+
+    /*
+    * Sends the NOOP command
+    *
+    * @return bool Success/Failure
+    */
+    function _cmdNoop()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('NOOP'))){
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the RSET command
+    *
+    * @return bool Success/Failure
+    */
+    function _cmdRset()
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+            if(!PEAR::isError($data = $this->_sendCmd('RSET'))){
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the QUIT command
+    *
+    * @return bool Success/Failure
+    */
+    function _cmdQuit()
+    {
+        $data = $this->_sendCmd('QUIT');
+        $this->_state = NET_POP3_STATE_DISCONNECTED;
+        $this->_socket->disconnect();
+
+        return (bool)$data;
+    }
+
+
+    /*
+    * Sends the TOP command
+    *
+    * @param  integer  $msg_id    Message number
+    * @param  integer  $num_lines Number of lines to retrieve
+    * @return mixed Message data or false on error
+    */
+    function _cmdTop($msg_id, $num_lines)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+
+            if(!PEAR::isError($data = $this->_sendCmd('TOP ' . $msg_id . ' ' . $num_lines))){
+                return $this->_getMultiline();
+            }
+        }
+
+        return false;
+    }
+
+    /*
+    * Sends the UIDL command
+    *
+    * @param  integer $msg_id Message number
+    * @return mixed indexed array of msg_id/uidl or false on error
+    */
+    function _cmdUidl($msg_id = null)
+    {
+        if ($this->_state == NET_POP3_STATE_TRANSACTION) {
+
+            if (!isset($msg_id)) {
+                if(!PEAR::isError($data = $this->_sendCmd('UIDL') )){
+                    $data = $this->_getMultiline();
+                    $data = explode("\r\n", $data);
+                    foreach ($data as $line) {
+                        sscanf($line, '%d %s', $msg_id, $uidl);
+                        $return[] = array('msg_id' => $msg_id, 'uidl' => $uidl);
+                    }
+
+                    return $return;
+                }
+            } else {
+
+                $data = $this->_sendCmd('UIDL ' . $msg_id);
+                sscanf($data, '+OK %d %s', $msg_id, $uidl);
+                return array('msg_id' => $msg_id, 'uidl' => $uidl);
+            }
+        }
+
+        return false;
+    }
+
+
+
+
+
+
+
+
+
+    /*
+    * Sends a command, checks the reponse, and
+    * if good returns the reponse, other wise
+    * returns false.
+    *
+    * @param  string $cmd  Command to send (\r\n will be appended)
+    * @return mixed First line of response if successful, otherwise false
+    */
+    function _sendCmd($cmd)
+    {
+        if (PEAR::isError($result = $this->_send($cmd) )){
+            return $result ;
+        }
+
+        if (PEAR::isError($data = $this->_recvLn() )){
+            return $data;
+        }
+        
+        if ( strtoupper(substr($data, 0, 3)) == '+OK') {
+            return $data;
+        }
+        
+        
+        return $this->_raiseError($data);
+    }
+
+    /*
+    * Reads a multiline reponse and returns the data
+    *
+    * @return string The reponse.
+    */
+    function _getMultiline()
+    {
+        $data = '';
+        while(!PEAR::isError($tmp = $this->_recvLn() ) ) {
+            if($tmp == '.'){
+                return substr($data, 0, -2);
+            }
+            if (substr($tmp, 0, 2) == '..') {
+                $tmp = substr($tmp, 1);
+            }
+            $data .= $tmp . "\r\n";
+        }
+        return substr($data, 0, -2);
+    }
+
+
+   /**
+    * Sets the bebug state
+    *
+    * @param  bool $debug 
+    * @access public
+    * @return void
+    */
+    function setDebug($debug=true)
+    {
+        $this->_debug=$debug;
+    }
+
+
+
+
+
+   /**
+     * Send the given string of data to the server.
+     *
+     * @param   string  $data       The string of data to send.
+     *
+     * @return  mixed   True on success or a PEAR_Error object on failure.
+     *
+     * @access  private
+     * @since   1.0
+     */
+    function _send($data)
+    {
+        if ($this->_debug) {
+            echo "C: $data\n";
+        }
+
+        if (PEAR::isError($error = $this->_socket->writeLine($data))) {
+            return $this->_raiseError('Failed to write to socket: ' . $error->getMessage());
+        }
+        return true;
+    }
+
+
+
+     /**
+     * Receive the given string of data from the server.
+     *
+     * @return  mixed   a line of response on success or a PEAR_Error object on failure.
+     *
+     * @access  private
+     * @since  1.0
+     */
+    function _recvLn()
+    {
+        if (PEAR::isError( $lastline = $this->_socket->readLine( 8192 ) ) ) {
+            return $this->_raiseError('Failed to write to socket: ' . $this->lastline->getMessage() );
+        }
+        if($this->_debug){
+            // S: means this data was sent by  the POP3 Server
+            echo "S:$lastline\n" ;
+        }
+        return $lastline;
+    }
+
+     /**
+     * Checks de server Response
+     *
+     * @param  string $response the response
+     * @return  mixed   true on success or a PEAR_Error object on failure.
+     *
+     * @access  private
+     * @since  1.3.3
+     */
+
+    function _checkResponse($response)
+    {
+        if (@substr(strtoupper($response), 0, 3) == '+OK') {
+            return true;
+        }else{
+            if (@substr(strtoupper($response), 0, 4) == '-ERR') {
+                return $this->_raiseError($response);
+            }else{
+                if (@substr(strtoupper($response), 0, 2) == '+ ') {
+                    return true;
+                }
+            }
+    
+        }
+        return $this->_raiseError("Unknown Response ($response)");
+    }
+    
+
+
+}
+
+?>
diff --git a/Net/Socket.php b/Net/Socket.php
new file mode 100644
index 0000000..7c4ff1d
--- /dev/null
+++ b/Net/Socket.php
@@ -0,0 +1,528 @@
+<?php
+//
+// +----------------------------------------------------------------------+
+// | PHP Version 4                                                        |
+// +----------------------------------------------------------------------+
+// | Copyright (c) 1997-2003 The PHP Group                                |
+// +----------------------------------------------------------------------+
+// | This source file is subject to version 2.0 of the PHP license,       |
+// | that is bundled with this package in the file LICENSE, and is        |
+// | available at through the world-wide-web at                           |
+// | http://www.php.net/license/2_02.txt.                                 |
+// | If you did not receive a copy of the PHP license and are unable to   |
+// | obtain it through the world-wide-web, please send a note to          |
+// | license@php.net so we can mail you a copy immediately.               |
+// +----------------------------------------------------------------------+
+// | Authors: Stig Bakken <ssb@php.net>                                   |
+// |          Chuck Hagenbuch <chuck@horde.org>                           |
+// +----------------------------------------------------------------------+
+//
+// $Id: Socket.php,v 1.24 2005/02/03 20:40:16 chagenbu Exp $
+
+require_once 'PEAR.php';
+
+define('NET_SOCKET_READ',  1);
+define('NET_SOCKET_WRITE', 2);
+define('NET_SOCKET_ERROR', 3);
+
+/**
+ * Generalized Socket class.
+ *
+ * @version 1.1
+ * @author Stig Bakken <ssb@php.net>
+ * @author Chuck Hagenbuch <chuck@horde.org>
+ */
+class Net_Socket extends PEAR {
+
+    /**
+     * Socket file pointer.
+     * @var resource $fp
+     */
+    var $fp = null;
+
+    /**
+     * Whether the socket is blocking. Defaults to true.
+     * @var boolean $blocking
+     */
+    var $blocking = true;
+
+    /**
+     * Whether the socket is persistent. Defaults to false.
+     * @var boolean $persistent
+     */
+    var $persistent = false;
+
+    /**
+     * The IP address to connect to.
+     * @var string $addr
+     */
+    var $addr = '';
+
+    /**
+     * The port number to connect to.
+     * @var integer $port
+     */
+    var $port = 0;
+
+    /**
+     * Number of seconds to wait on socket connections before assuming
+     * there's no more data. Defaults to no timeout.
+     * @var integer $timeout
+     */
+    var $timeout = false;
+
+    /**
+     * Number of bytes to read at a time in readLine() and
+     * readAll(). Defaults to 2048.
+     * @var integer $lineLength
+     */
+    var $lineLength = 2048;
+
+    /**
+     * Connect to the specified port. If called when the socket is
+     * already connected, it disconnects and connects again.
+     *
+     * @param string  $addr        IP address or host name.
+     * @param integer $port        TCP port number.
+     * @param boolean $persistent  (optional) Whether the connection is
+     *                             persistent (kept open between requests
+     *                             by the web server).
+     * @param integer $timeout     (optional) How long to wait for data.
+     * @param array   $options     See options for stream_context_create.
+     *
+     * @access public
+     *
+     * @return boolean | PEAR_Error  True on success or a PEAR_Error on failure.
+     */
+    function connect($addr, $port = 0, $persistent = null, $timeout = null, $options = null)
+    {
+        if (is_resource($this->fp)) {
+            @fclose($this->fp);
+            $this->fp = null;
+        }
+
+        if (!$addr) {
+            return $this->raiseError('$addr cannot be empty');
+        } elseif (strspn($addr, '.0123456789') == strlen($addr) ||
+                  strstr($addr, '/') !== false) {
+            $this->addr = $addr;
+        } else {
+            $this->addr = @gethostbyname($addr);
+        }
+
+        $this->port = $port % 65536;
+
+        if ($persistent !== null) {
+            $this->persistent = $persistent;
+        }
+
+        if ($timeout !== null) {
+            $this->timeout = $timeout;
+        }
+
+        $openfunc = $this->persistent ? 'pfsockopen' : 'fsockopen';
+        $errno = 0;
+        $errstr = '';
+        if ($options && function_exists('stream_context_create')) {
+            if ($this->timeout) {
+                $timeout = $this->timeout;
+            } else {
+                $timeout = 0;
+            }
+            $context = stream_context_create($options);
+            $fp = @$openfunc($this->addr, $this->port, $errno, $errstr, $timeout, $context);
+        } else {
+            if ($this->timeout) {
+                $fp = @$openfunc($this->addr, $this->port, $errno, $errstr, $this->timeout);
+            } else {
+                $fp = @$openfunc($this->addr, $this->port, $errno, $errstr);
+            }
+        }
+
+        if (!$fp) {
+            return $this->raiseError($errstr, $errno);
+        }
+
+        $this->fp = $fp;
+
+        return $this->setBlocking($this->blocking);
+    }
+
+    /**
+     * Disconnects from the peer, closes the socket.
+     *
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function disconnect()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        @fclose($this->fp);
+        $this->fp = null;
+        return true;
+    }
+
+    /**
+     * Find out if the socket is in blocking mode.
+     *
+     * @access public
+     * @return boolean  The current blocking mode.
+     */
+    function isBlocking()
+    {
+        return $this->blocking;
+    }
+
+    /**
+     * Sets whether the socket connection should be blocking or
+     * not. A read call to a non-blocking socket will return immediately
+     * if there is no data available, whereas it will block until there
+     * is data for blocking sockets.
+     *
+     * @param boolean $mode  True for blocking sockets, false for nonblocking.
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function setBlocking($mode)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $this->blocking = $mode;
+        socket_set_blocking($this->fp, $this->blocking);
+        return true;
+    }
+
+    /**
+     * Sets the timeout value on socket descriptor,
+     * expressed in the sum of seconds and microseconds
+     *
+     * @param integer $seconds  Seconds.
+     * @param integer $microseconds  Microseconds.
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function setTimeout($seconds, $microseconds)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return socket_set_timeout($this->fp, $seconds, $microseconds);
+    }
+
+    /**
+     * Returns information about an existing socket resource.
+     * Currently returns four entries in the result array:
+     *
+     * <p>
+     * timed_out (bool) - The socket timed out waiting for data<br>
+     * blocked (bool) - The socket was blocked<br>
+     * eof (bool) - Indicates EOF event<br>
+     * unread_bytes (int) - Number of bytes left in the socket buffer<br>
+     * </p>
+     *
+     * @access public
+     * @return mixed Array containing information about existing socket resource or an error object otherwise
+     */
+    function getStatus()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return socket_get_status($this->fp);
+    }
+
+    /**
+     * Get a specified line of data
+     *
+     * @access public
+     * @return $size bytes of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function gets($size)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return @fgets($this->fp, $size);
+    }
+
+    /**
+     * Read a specified amount of data. This is guaranteed to return,
+     * and has the added benefit of getting everything in one fread()
+     * chunk; if you know the size of the data you're getting
+     * beforehand, this is definitely the way to go.
+     *
+     * @param integer $size  The number of bytes to read from the socket.
+     * @access public
+     * @return $size bytes of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function read($size)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return @fread($this->fp, $size);
+    }
+
+    /**
+     * Write a specified amount of data.
+     *
+     * @param string  $data       Data to write.
+     * @param integer $blocksize  Amount of data to write at once.
+     *                            NULL means all at once.
+     *
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function write($data, $blocksize = null)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        if (is_null($blocksize) && !OS_WINDOWS) {
+            return fwrite($this->fp, $data);
+        } else {
+            if (is_null($blocksize)) {
+                $blocksize = 1024;
+            }
+
+            $pos = 0;
+            $size = strlen($data);
+            while ($pos < $size) {
+                $written = @fwrite($this->fp, substr($data, $pos, $blocksize));
+                if ($written === false) {
+                    return false;
+                }
+                $pos += $written;
+            }
+
+            return $pos;
+        }
+    }
+
+    /**
+     * Write a line of data to the socket, followed by a trailing "\r\n".
+     *
+     * @access public
+     * @return mixed fputs result, or an error
+     */
+    function writeLine($data)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return fwrite($this->fp, $data . "\r\n");
+    }
+
+    /**
+     * Tests for end-of-file on a socket descriptor.
+     *
+     * @access public
+     * @return bool
+     */
+    function eof()
+    {
+        return (is_resource($this->fp) && feof($this->fp));
+    }
+
+    /**
+     * Reads a byte of data
+     *
+     * @access public
+     * @return 1 byte of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readByte()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        return ord(@fread($this->fp, 1));
+    }
+
+    /**
+     * Reads a word of data
+     *
+     * @access public
+     * @return 1 word of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readWord()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $buf = @fread($this->fp, 2);
+        return (ord($buf[0]) + (ord($buf[1]) << 8));
+    }
+
+    /**
+     * Reads an int of data
+     *
+     * @access public
+     * @return integer  1 int of data from the socket, or a PEAR_Error if
+     *                  not connected.
+     */
+    function readInt()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $buf = @fread($this->fp, 4);
+        return (ord($buf[0]) + (ord($buf[1]) << 8) +
+                (ord($buf[2]) << 16) + (ord($buf[3]) << 24));
+    }
+
+    /**
+     * Reads a zero-terminated string of data
+     *
+     * @access public
+     * @return string, or a PEAR_Error if
+     *         not connected.
+     */
+    function readString()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $string = '';
+        while (($char = @fread($this->fp, 1)) != "\x00")  {
+            $string .= $char;
+        }
+        return $string;
+    }
+
+    /**
+     * Reads an IP Address and returns it in a dot formated string
+     *
+     * @access public
+     * @return Dot formated string, or a PEAR_Error if
+     *         not connected.
+     */
+    function readIPAddress()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $buf = @fread($this->fp, 4);
+        return sprintf("%s.%s.%s.%s", ord($buf[0]), ord($buf[1]),
+                       ord($buf[2]), ord($buf[3]));
+    }
+
+    /**
+     * Read until either the end of the socket or a newline, whichever
+     * comes first. Strips the trailing newline from the returned data.
+     *
+     * @access public
+     * @return All available data up to a newline, without that
+     *         newline, or until the end of the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readLine()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $line = '';
+        $timeout = time() + $this->timeout;
+        while (!feof($this->fp) && (!$this->timeout || time() < $timeout)) {
+            $line .= @fgets($this->fp, $this->lineLength);
+            if (substr($line, -1) == "\n") {
+                return rtrim($line, "\r\n");
+            }
+        }
+        return $line;
+    }
+
+    /**
+     * Read until the socket closes, or until there is no more data in
+     * the inner PHP buffer. If the inner buffer is empty, in blocking
+     * mode we wait for at least 1 byte of data. Therefore, in
+     * blocking mode, if there is no data at all to be read, this
+     * function will never exit (unless the socket is closed on the
+     * remote end).
+     *
+     * @access public
+     *
+     * @return string  All data until the socket closes, or a PEAR_Error if
+     *                 not connected.
+     */
+    function readAll()
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $data = '';
+        while (!feof($this->fp)) {
+            $data .= @fread($this->fp, $this->lineLength);
+        }
+        return $data;
+    }
+
+    /**
+     * Runs the equivalent of the select() system call on the socket
+     * with a timeout specified by tv_sec and tv_usec.
+     *
+     * @param integer $state    Which of read/write/error to check for.
+     * @param integer $tv_sec   Number of seconds for timeout.
+     * @param integer $tv_usec  Number of microseconds for timeout.
+     *
+     * @access public
+     * @return False if select fails, integer describing which of read/write/error
+     *         are ready, or PEAR_Error if not connected.
+     */
+    function select($state, $tv_sec, $tv_usec = 0)
+    {
+        if (!is_resource($this->fp)) {
+            return $this->raiseError('not connected');
+        }
+
+        $read = null;
+        $write = null;
+        $except = null;
+        if ($state & NET_SOCKET_READ) {
+            $read[] = $this->fp;
+        }
+        if ($state & NET_SOCKET_WRITE) {
+            $write[] = $this->fp;
+        }
+        if ($state & NET_SOCKET_ERROR) {
+            $except[] = $this->fp;
+        }
+        if (false === ($sr = stream_select($read, $write, $except, $tv_sec, $tv_usec))) {
+            return false;
+        }
+
+        $result = 0;
+        if (count($read)) {
+            $result |= NET_SOCKET_READ;
+        }
+        if (count($write)) {
+            $result |= NET_SOCKET_WRITE;
+        }
+        if (count($except)) {
+            $result |= NET_SOCKET_ERROR;
+        }
+        return $result;
+    }
+
+}
diff --git a/PEAR.php b/PEAR.php
new file mode 100644
index 0000000..eedf247
--- /dev/null
+++ b/PEAR.php
@@ -0,0 +1,1101 @@
+<?php
+/**
+ * PEAR, the PHP Extension and Application Repository
+ *
+ * PEAR class and PEAR_Error class
+ *
+ * PHP versions 4 and 5
+ *
+ * LICENSE: This source file is subject to version 3.0 of the PHP license
+ * that is available through the world-wide-web at the following URI:
+ * http://www.php.net/license/3_0.txt.  If you did not receive a copy of
+ * the PHP License and are unable to obtain it through the web, please
+ * send a note to license@php.net so we can mail you a copy immediately.
+ *
+ * @category   pear
+ * @package    PEAR
+ * @author     Sterling Hughes <sterling@php.net>
+ * @author     Stig Bakken <ssb@php.net>
+ * @author     Tomas V.V.Cox <cox@idecnet.com>
+ * @author     Greg Beaver <cellog@php.net>
+ * @copyright  1997-2006 The PHP Group
+ * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
+ * @version    CVS: $Id: PEAR.php,v 1.98 2006/01/23 05:38:05 cellog Exp $
+ * @link       http://pear.php.net/package/PEAR
+ * @since      File available since Release 0.1
+ */
+
+/**#@+
+ * ERROR constants
+ */
+define('PEAR_ERROR_RETURN',     1);
+define('PEAR_ERROR_PRINT',      2);
+define('PEAR_ERROR_TRIGGER',    4);
+define('PEAR_ERROR_DIE',        8);
+define('PEAR_ERROR_CALLBACK',  16);
+/**
+ * WARNING: obsolete
+ * @deprecated
+ */
+define('PEAR_ERROR_EXCEPTION', 32);
+/**#@-*/
+define('PEAR_ZE2', (function_exists('version_compare') &&
+                    version_compare(zend_version(), "2-dev", "ge")));
+
+if (substr(PHP_OS, 0, 3) == 'WIN') {
+    define('OS_WINDOWS', true);
+    define('OS_UNIX',    false);
+    define('PEAR_OS',    'Windows');
+} else {
+    define('OS_WINDOWS', false);
+    define('OS_UNIX',    true);
+    define('PEAR_OS',    'Unix'); // blatant assumption
+}
+
+// instant backwards compatibility
+if (!defined('PATH_SEPARATOR')) {
+    if (OS_WINDOWS) {
+        define('PATH_SEPARATOR', ';');
+    } else {
+        define('PATH_SEPARATOR', ':');
+    }
+}
+
+$GLOBALS['_PEAR_default_error_mode']     = PEAR_ERROR_RETURN;
+$GLOBALS['_PEAR_default_error_options']  = E_USER_NOTICE;
+$GLOBALS['_PEAR_destructor_object_list'] = array();
+$GLOBALS['_PEAR_shutdown_funcs']         = array();
+$GLOBALS['_PEAR_error_handler_stack']    = array();
+
+@ini_set('track_errors', true);
+
+/**
+ * Base class for other PEAR classes.  Provides rudimentary
+ * emulation of destructors.
+ *
+ * If you want a destructor in your class, inherit PEAR and make a
+ * destructor method called _yourclassname (same name as the
+ * constructor, but with a "_" prefix).  Also, in your constructor you
+ * have to call the PEAR constructor: $this->PEAR();.
+ * The destructor method will be called without parameters.  Note that
+ * at in some SAPI implementations (such as Apache), any output during
+ * the request shutdown (in which destructors are called) seems to be
+ * discarded.  If you need to get any debug information from your
+ * destructor, use error_log(), syslog() or something similar.
+ *
+ * IMPORTANT! To use the emulated destructors you need to create the
+ * objects by reference: $obj =& new PEAR_child;
+ *
+ * @category   pear
+ * @package    PEAR
+ * @author     Stig Bakken <ssb@php.net>
+ * @author     Tomas V.V. Cox <cox@idecnet.com>
+ * @author     Greg Beaver <cellog@php.net>
+ * @copyright  1997-2006 The PHP Group
+ * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
+ * @version    Release: 1.4.10
+ * @link       http://pear.php.net/package/PEAR
+ * @see        PEAR_Error
+ * @since      Class available since PHP 4.0.2
+ * @link        http://pear.php.net/manual/en/core.pear.php#core.pear.pear
+ */
+class PEAR
+{
+    // {{{ properties
+
+    /**
+     * Whether to enable internal debug messages.
+     *
+     * @var     bool
+     * @access  private
+     */
+    var $_debug = false;
+
+    /**
+     * Default error mode for this object.
+     *
+     * @var     int
+     * @access  private
+     */
+    var $_default_error_mode = null;
+
+    /**
+     * Default error options used for this object when error mode
+     * is PEAR_ERROR_TRIGGER.
+     *
+     * @var     int
+     * @access  private
+     */
+    var $_default_error_options = null;
+
+    /**
+     * Default error handler (callback) for this object, if error mode is
+     * PEAR_ERROR_CALLBACK.
+     *
+     * @var     string
+     * @access  private
+     */
+    var $_default_error_handler = '';
+
+    /**
+     * Which class to use for error objects.
+     *
+     * @var     string
+     * @access  private
+     */
+    var $_error_class = 'PEAR_Error';
+
+    /**
+     * An array of expected errors.
+     *
+     * @var     array
+     * @access  private
+     */
+    var $_expected_errors = array();
+
+    // }}}
+
+    // {{{ constructor
+
+    /**
+     * Constructor.  Registers this object in
+     * $_PEAR_destructor_object_list for destructor emulation if a
+     * destructor object exists.
+     *
+     * @param string $error_class  (optional) which class to use for
+     *        error objects, defaults to PEAR_Error.
+     * @access public
+     * @return void
+     */
+    function PEAR($error_class = null)
+    {
+        $classname = strtolower(get_class($this));
+        if ($this->_debug) {
+            print "PEAR constructor called, class=$classname\n";
+        }
+        if ($error_class !== null) {
+            $this->_error_class = $error_class;
+        }
+        while ($classname && strcasecmp($classname, "pear")) {
+            $destructor = "_$classname";
+            if (method_exists($this, $destructor)) {
+                global $_PEAR_destructor_object_list;
+                $_PEAR_destructor_object_list[] = &$this;
+                if (!isset($GLOBALS['_PEAR_SHUTDOWN_REGISTERED'])) {
+                    register_shutdown_function("_PEAR_call_destructors");
+                    $GLOBALS['_PEAR_SHUTDOWN_REGISTERED'] = true;
+                }
+                break;
+            } else {
+                $classname = get_parent_class($classname);
+            }
+        }
+    }
+
+    // }}}
+    // {{{ destructor
+
+    /**
+     * Destructor (the emulated type of...).  Does nothing right now,
+     * but is included for forward compatibility, so subclass
+     * destructors should always call it.
+     *
+     * See the note in the class desciption about output from
+     * destructors.
+     *
+     * @access public
+     * @return void
+     */
+    function _PEAR() {
+        if ($this->_debug) {
+            printf("PEAR destructor called, class=%s\n", strtolower(get_class($this)));
+        }
+    }
+
+    // }}}
+    // {{{ getStaticProperty()
+
+    /**
+    * If you have a class that's mostly/entirely static, and you need static
+    * properties, you can use this method to simulate them. Eg. in your method(s)
+    * do this: $myVar = &PEAR::getStaticProperty('myclass', 'myVar');
+    * You MUST use a reference, or they will not persist!
+    *
+    * @access public
+    * @param  string $class  The calling classname, to prevent clashes
+    * @param  string $var    The variable to retrieve.
+    * @return mixed   A reference to the variable. If not set it will be
+    *                 auto initialised to NULL.
+    */
+    function &getStaticProperty($class, $var)
+    {
+        static $properties;
+        return $properties[$class][$var];
+    }
+
+    // }}}
+    // {{{ registerShutdownFunc()
+
+    /**
+    * Use this function to register a shutdown method for static
+    * classes.
+    *
+    * @access public
+    * @param  mixed $func  The function name (or array of class/method) to call
+    * @param  mixed $args  The arguments to pass to the function
+    * @return void
+    */
+    function registerShutdownFunc($func, $args = array())
+    {
+        // if we are called statically, there is a potential
+        // that no shutdown func is registered.  Bug #6445
+        if (!isset($GLOBALS['_PEAR_SHUTDOWN_REGISTERED'])) {
+            register_shutdown_function("_PEAR_call_destructors");
+            $GLOBALS['_PEAR_SHUTDOWN_REGISTERED'] = true;
+        }
+        $GLOBALS['_PEAR_shutdown_funcs'][] = array($func, $args);
+    }
+
+    // }}}
+    // {{{ isError()
+
+    /**
+     * Tell whether a value is a PEAR error.
+     *
+     * @param   mixed $data   the value to test
+     * @param   int   $code   if $data is an error object, return true
+     *                        only if $code is a string and
+     *                        $obj->getMessage() == $code or
+     *                        $code is an integer and $obj->getCode() == $code
+     * @access  public
+     * @return  bool    true if parameter is an error
+     */
+    function isError($data, $code = null)
+    {
+        if (is_a($data, 'PEAR_Error')) {
+            if (is_null($code)) {
+                return true;
+            } elseif (is_string($code)) {
+                return $data->getMessage() == $code;
+            } else {
+                return $data->getCode() == $code;
+            }
+        }
+        return false;
+    }
+
+    // }}}
+    // {{{ setErrorHandling()
+
+    /**
+     * Sets how errors generated by this object should be handled.
+     * Can be invoked both in objects and statically.  If called
+     * statically, setErrorHandling sets the default behaviour for all
+     * PEAR objects.  If called in an object, setErrorHandling sets
+     * the default behaviour for that object.
+     *
+     * @param int $mode
+     *        One of PEAR_ERROR_RETURN, PEAR_ERROR_PRINT,
+     *        PEAR_ERROR_TRIGGER, PEAR_ERROR_DIE,
+     *        PEAR_ERROR_CALLBACK or PEAR_ERROR_EXCEPTION.
+     *
+     * @param mixed $options
+     *        When $mode is PEAR_ERROR_TRIGGER, this is the error level (one
+     *        of E_USER_NOTICE, E_USER_WARNING or E_USER_ERROR).
+     *
+     *        When $mode is PEAR_ERROR_CALLBACK, this parameter is expected
+     *        to be the callback function or method.  A callback
+     *        function is a string with the name of the function, a
+     *        callback method is an array of two elements: the element
+     *        at index 0 is the object, and the element at index 1 is
+     *        the name of the method to call in the object.
+     *
+     *        When $mode is PEAR_ERROR_PRINT or PEAR_ERROR_DIE, this is
+     *        a printf format string used when printing the error
+     *        message.
+     *
+     * @access public
+     * @return void
+     * @see PEAR_ERROR_RETURN
+     * @see PEAR_ERROR_PRINT
+     * @see PEAR_ERROR_TRIGGER
+     * @see PEAR_ERROR_DIE
+     * @see PEAR_ERROR_CALLBACK
+     * @see PEAR_ERROR_EXCEPTION
+     *
+     * @since PHP 4.0.5
+     */
+
+    function setErrorHandling($mode = null, $options = null)
+    {
+        if (isset($this) && is_a($this, 'PEAR')) {
+            $setmode     = &$this->_default_error_mode;
+            $setoptions  = &$this->_default_error_options;
+        } else {
+            $setmode     = &$GLOBALS['_PEAR_default_error_mode'];
+            $setoptions  = &$GLOBALS['_PEAR_default_error_options'];
+        }
+
+        switch ($mode) {
+            case PEAR_ERROR_EXCEPTION:
+            case PEAR_ERROR_RETURN:
+            case PEAR_ERROR_PRINT:
+            case PEAR_ERROR_TRIGGER:
+            case PEAR_ERROR_DIE:
+            case null:
+                $setmode = $mode;
+                $setoptions = $options;
+                break;
+
+            case PEAR_ERROR_CALLBACK:
+                $setmode = $mode;
+                // class/object method callback
+                if (is_callable($options)) {
+                    $setoptions = $options;
+                } else {
+                    trigger_error("invalid error callback", E_USER_WARNING);
+                }
+                break;
+
+            default:
+                trigger_error("invalid error mode", E_USER_WARNING);
+                break;
+        }
+    }
+
+    // }}}
+    // {{{ expectError()
+
+    /**
+     * This method is used to tell which errors you expect to get.
+     * Expected errors are always returned with error mode
+     * PEAR_ERROR_RETURN.  Expected error codes are stored in a stack,
+     * and this method pushes a new element onto it.  The list of
+     * expected errors are in effect until they are popped off the
+     * stack with the popExpect() method.
+     *
+     * Note that this method can not be called statically
+     *
+     * @param mixed $code a single error code or an array of error codes to expect
+     *
+     * @return int     the new depth of the "expected errors" stack
+     * @access public
+     */
+    function expectError($code = '*')
+    {
+        if (is_array($code)) {
+            array_push($this->_expected_errors, $code);
+        } else {
+            array_push($this->_expected_errors, array($code));
+        }
+        return sizeof($this->_expected_errors);
+    }
+
+    // }}}
+    // {{{ popExpect()
+
+    /**
+     * This method pops one element off the expected error codes
+     * stack.
+     *
+     * @return array   the list of error codes that were popped
+     */
+    function popExpect()
+    {
+        return array_pop($this->_expected_errors);
+    }
+
+    // }}}
+    // {{{ _checkDelExpect()
+
+    /**
+     * This method checks unsets an error code if available
+     *
+     * @param mixed error code
+     * @return bool true if the error code was unset, false otherwise
+     * @access private
+     * @since PHP 4.3.0
+     */
+    function _checkDelExpect($error_code)
+    {
+        $deleted = false;
+
+        foreach ($this->_expected_errors AS $key => $error_array) {
+            if (in_array($error_code, $error_array)) {
+                unset($this->_expected_errors[$key][array_search($error_code, $error_array)]);
+                $deleted = true;
+            }
+
+            // clean up empty arrays
+            if (0 == count($this->_expected_errors[$key])) {
+                unset($this->_expected_errors[$key]);
+            }
+        }
+        return $deleted;
+    }
+
+    // }}}
+    // {{{ delExpect()
+
+    /**
+     * This method deletes all occurences of the specified element from
+     * the expected error codes stack.
+     *
+     * @param  mixed $error_code error code that should be deleted
+     * @return mixed list of error codes that were deleted or error
+     * @access public
+     * @since PHP 4.3.0
+     */
+    function delExpect($error_code)
+    {
+        $deleted = false;
+
+        if ((is_array($error_code) && (0 != count($error_code)))) {
+            // $error_code is a non-empty array here;
+            // we walk through it trying to unset all
+            // values
+            foreach($error_code as $key => $error) {
+                if ($this->_checkDelExpect($error)) {
+                    $deleted =  true;
+                } else {
+                    $deleted = false;
+                }
+            }
+            return $deleted ? true : PEAR::raiseError("The expected error you submitted does not exist"); // IMPROVE ME
+        } elseif (!empty($error_code)) {
+            // $error_code comes alone, trying to unset it
+            if ($this->_checkDelExpect($error_code)) {
+                return true;
+            } else {
+                return PEAR::raiseError("The expected error you submitted does not exist"); // IMPROVE ME
+            }
+        } else {
+            // $error_code is empty
+            return PEAR::raiseError("The expected error you submitted is empty"); // IMPROVE ME
+        }
+    }
+
+    // }}}
+    // {{{ raiseError()
+
+    /**
+     * This method is a wrapper that returns an instance of the
+     * configured error class with this object's default error
+     * handling applied.  If the $mode and $options parameters are not
+     * specified, the object's defaults are used.
+     *
+     * @param mixed $message a text error message or a PEAR error object
+     *
+     * @param int $code      a numeric error code (it is up to your class
+     *                  to define these if you want to use codes)
+     *
+     * @param int $mode      One of PEAR_ERROR_RETURN, PEAR_ERROR_PRINT,
+     *                  PEAR_ERROR_TRIGGER, PEAR_ERROR_DIE,
+     *                  PEAR_ERROR_CALLBACK, PEAR_ERROR_EXCEPTION.
+     *
+     * @param mixed $options If $mode is PEAR_ERROR_TRIGGER, this parameter
+     *                  specifies the PHP-internal error level (one of
+     *                  E_USER_NOTICE, E_USER_WARNING or E_USER_ERROR).
+     *                  If $mode is PEAR_ERROR_CALLBACK, this
+     *                  parameter specifies the callback function or
+     *                  method.  In other error modes this parameter
+     *                  is ignored.
+     *
+     * @param string $userinfo If you need to pass along for example debug
+     *                  information, this parameter is meant for that.
+     *
+     * @param string $error_class The returned error object will be
+     *                  instantiated from this class, if specified.
+     *
+     * @param bool $skipmsg If true, raiseError will only pass error codes,
+     *                  the error message parameter will be dropped.
+     *
+     * @access public
+     * @return object   a PEAR error object
+     * @see PEAR::setErrorHandling
+     * @since PHP 4.0.5
+     */
+    function &raiseError($message = null,
+                         $code = null,
+                         $mode = null,
+                         $options = null,
+                         $userinfo = null,
+                         $error_class = null,
+                         $skipmsg = false)
+    {
+        // The error is yet a PEAR error object
+        if (is_object($message)) {
+            $code        = $message->getCode();
+            $userinfo    = $message->getUserInfo();
+            $error_class = $message->getType();
+            $message->error_message_prefix = '';
+            $message     = $message->getMessage();
+        }
+
+        if (isset($this) && isset($this->_expected_errors) && sizeof($this->_expected_errors) > 0 && sizeof($exp = end($this->_expected_errors))) {
+            if ($exp[0] == "*" ||
+                (is_int(reset($exp)) && in_array($code, $exp)) ||
+                (is_string(reset($exp)) && in_array($message, $exp))) {
+                $mode = PEAR_ERROR_RETURN;
+            }
+        }
+        // No mode given, try global ones
+        if ($mode === null) {
+            // Class error handler
+            if (isset($this) && isset($this->_default_error_mode)) {
+                $mode    = $this->_default_error_mode;
+                $options = $this->_default_error_options;
+            // Global error handler
+            } elseif (isset($GLOBALS['_PEAR_default_error_mode'])) {
+                $mode    = $GLOBALS['_PEAR_default_error_mode'];
+                $options = $GLOBALS['_PEAR_default_error_options'];
+            }
+        }
+
+        if ($error_class !== null) {
+            $ec = $error_class;
+        } elseif (isset($this) && isset($this->_error_class)) {
+            $ec = $this->_error_class;
+        } else {
+            $ec = 'PEAR_Error';
+        }
+        if ($skipmsg) {
+            $a = &new $ec($code, $mode, $options, $userinfo);
+            return $a;
+        } else {
+            $a = &new $ec($message, $code, $mode, $options, $userinfo);
+            return $a;
+        }
+    }
+
+    // }}}
+    // {{{ throwError()
+
+    /**
+     * Simpler form of raiseError with fewer options.  In most cases
+     * message, code and userinfo are enough.
+     *
+     * @param string $message
+     *
+     */
+    function &throwError($message = null,
+                         $code = null,
+                         $userinfo = null)
+    {
+        if (isset($this) && is_a($this, 'PEAR')) {
+            $a = &$this->raiseError($message, $code, null, null, $userinfo);
+            return $a;
+        } else {
+            $a = &PEAR::raiseError($message, $code, null, null, $userinfo);
+            return $a;
+        }
+    }
+
+    // }}}
+    function staticPushErrorHandling($mode, $options = null)
+    {
+        $stack = &$GLOBALS['_PEAR_error_handler_stack'];
+        $def_mode    = &$GLOBALS['_PEAR_default_error_mode'];
+        $def_options = &$GLOBALS['_PEAR_default_error_options'];
+        $stack[] = array($def_mode, $def_options);
+        switch ($mode) {
+            case PEAR_ERROR_EXCEPTION:
+            case PEAR_ERROR_RETURN:
+            case PEAR_ERROR_PRINT:
+            case PEAR_ERROR_TRIGGER:
+            case PEAR_ERROR_DIE:
+            case null:
+                $def_mode = $mode;
+                $def_options = $options;
+                break;
+
+            case PEAR_ERROR_CALLBACK:
+                $def_mode = $mode;
+                // class/object method callback
+                if (is_callable($options)) {
+                    $def_options = $options;
+                } else {
+                    trigger_error("invalid error callback", E_USER_WARNING);
+                }
+                break;
+
+            default:
+                trigger_error("invalid error mode", E_USER_WARNING);
+                break;
+        }
+        $stack[] = array($mode, $options);
+        return true;
+    }
+
+    function staticPopErrorHandling()
+    {
+        $stack = &$GLOBALS['_PEAR_error_handler_stack'];
+        $setmode     = &$GLOBALS['_PEAR_default_error_mode'];
+        $setoptions  = &$GLOBALS['_PEAR_default_error_options'];
+        array_pop($stack);
+        list($mode, $options) = $stack[sizeof($stack) - 1];
+        array_pop($stack);
+        switch ($mode) {
+            case PEAR_ERROR_EXCEPTION:
+            case PEAR_ERROR_RETURN:
+            case PEAR_ERROR_PRINT:
+            case PEAR_ERROR_TRIGGER:
+            case PEAR_ERROR_DIE:
+            case null:
+                $setmode = $mode;
+                $setoptions = $options;
+                break;
+
+            case PEAR_ERROR_CALLBACK:
+                $setmode = $mode;
+                // class/object method callback
+                if (is_callable($options)) {
+                    $setoptions = $options;
+                } else {
+                    trigger_error("invalid error callback", E_USER_WARNING);
+                }
+                break;
+
+            default:
+                trigger_error("invalid error mode", E_USER_WARNING);
+                break;
+        }
+        return true;
+    }
+
+    // {{{ pushErrorHandling()
+
+    /**
+     * Push a new error handler on top of the error handler options stack. With this
+     * you can easily override the actual error handler for some code and restore
+     * it later with popErrorHandling.
+     *
+     * @param mixed $mode (same as setErrorHandling)
+     * @param mixed $options (same as setErrorHandling)
+     *
+     * @return bool Always true
+     *
+     * @see PEAR::setErrorHandling
+     */
+    function pushErrorHandling($mode, $options = null)
+    {
+        $stack = &$GLOBALS['_PEAR_error_handler_stack'];
+        if (isset($this) && is_a($this, 'PEAR')) {
+            $def_mode    = &$this->_default_error_mode;
+            $def_options = &$this->_default_error_options;
+        } else {
+            $def_mode    = &$GLOBALS['_PEAR_default_error_mode'];
+            $def_options = &$GLOBALS['_PEAR_default_error_options'];
+        }
+        $stack[] = array($def_mode, $def_options);
+
+        if (isset($this) && is_a($this, 'PEAR')) {
+            $this->setErrorHandling($mode, $options);
+        } else {
+            PEAR::setErrorHandling($mode, $options);
+        }
+        $stack[] = array($mode, $options);
+        return true;
+    }
+
+    // }}}
+    // {{{ popErrorHandling()
+
+    /**
+    * Pop the last error handler used
+    *
+    * @return bool Always true
+    *
+    * @see PEAR::pushErrorHandling
+    */
+    function popErrorHandling()
+    {
+        $stack = &$GLOBALS['_PEAR_error_handler_stack'];
+        array_pop($stack);
+        list($mode, $options) = $stack[sizeof($stack) - 1];
+        array_pop($stack);
+        if (isset($this) && is_a($this, 'PEAR')) {
+            $this->setErrorHandling($mode, $options);
+        } else {
+            PEAR::setErrorHandling($mode, $options);
+        }
+        return true;
+    }
+
+    // }}}
+    // {{{ loadExtension()
+
+    /**
+    * OS independant PHP extension load. Remember to take care
+    * on the correct extension name for case sensitive OSes.
+    *
+    * @param string $ext The extension name
+    * @return bool Success or not on the dl() call
+    */
+    function loadExtension($ext)
+    {
+        if (!extension_loaded($ext)) {
+            // if either returns true dl() will produce a FATAL error, stop that
+            if ((ini_get('enable_dl') != 1) || (ini_get('safe_mode') == 1)) {
+                return false;
+            }
+            if (OS_WINDOWS) {
+                $suffix = '.dll';
+            } elseif (PHP_OS == 'HP-UX') {
+                $suffix = '.sl';
+            } elseif (PHP_OS == 'AIX') {
+                $suffix = '.a';
+            } elseif (PHP_OS == 'OSX') {
+                $suffix = '.bundle';
+            } else {
+                $suffix = '.so';
+            }
+            return @dl('php_'.$ext.$suffix) || @dl($ext.$suffix);
+        }
+        return true;
+    }
+
+    // }}}
+}
+
+// {{{ _PEAR_call_destructors()
+
+function _PEAR_call_destructors()
+{
+    global $_PEAR_destructor_object_list;
+    if (is_array($_PEAR_destructor_object_list) &&
+        sizeof($_PEAR_destructor_object_list))
+    {
+        reset($_PEAR_destructor_object_list);
+        if (@PEAR::getStaticProperty('PEAR', 'destructlifo')) {
+            $_PEAR_destructor_object_list = array_reverse($_PEAR_destructor_object_list);
+        }
+        while (list($k, $objref) = each($_PEAR_destructor_object_list)) {
+            $classname = get_class($objref);
+            while ($classname) {
+                $destructor = "_$classname";
+                if (method_exists($objref, $destructor)) {
+                    $objref->$destructor();
+                    break;
+                } else {
+                    $classname = get_parent_class($classname);
+                }
+            }
+        }
+        // Empty the object list to ensure that destructors are
+        // not called more than once.
+        $_PEAR_destructor_object_list = array();
+    }
+
+    // Now call the shutdown functions
+    if (is_array($GLOBALS['_PEAR_shutdown_funcs']) AND !empty($GLOBALS['_PEAR_shutdown_funcs'])) {
+        foreach ($GLOBALS['_PEAR_shutdown_funcs'] as $value) {
+            call_user_func_array($value[0], $value[1]);
+        }
+    }
+}
+
+// }}}
+/**
+ * Standard PEAR error class for PHP 4
+ *
+ * This class is supserseded by {@link PEAR_Exception} in PHP 5
+ *
+ * @category   pear
+ * @package    PEAR
+ * @author     Stig Bakken <ssb@php.net>
+ * @author     Tomas V.V. Cox <cox@idecnet.com>
+ * @author     Gregory Beaver <cellog@php.net>
+ * @copyright  1997-2006 The PHP Group
+ * @license    http://www.php.net/license/3_0.txt  PHP License 3.0
+ * @version    Release: 1.4.10
+ * @link       http://pear.php.net/manual/en/core.pear.pear-error.php
+ * @see        PEAR::raiseError(), PEAR::throwError()
+ * @since      Class available since PHP 4.0.2
+ */
+class PEAR_Error
+{
+    // {{{ properties
+
+    var $error_message_prefix = '';
+    var $mode                 = PEAR_ERROR_RETURN;
+    var $level                = E_USER_NOTICE;
+    var $code                 = -1;
+    var $message              = '';
+    var $userinfo             = '';
+    var $backtrace            = null;
+
+    // }}}
+    // {{{ constructor
+
+    /**
+     * PEAR_Error constructor
+     *
+     * @param string $message  message
+     *
+     * @param int $code     (optional) error code
+     *
+     * @param int $mode     (optional) error mode, one of: PEAR_ERROR_RETURN,
+     * PEAR_ERROR_PRINT, PEAR_ERROR_DIE, PEAR_ERROR_TRIGGER,
+     * PEAR_ERROR_CALLBACK or PEAR_ERROR_EXCEPTION
+     *
+     * @param mixed $options   (optional) error level, _OR_ in the case of
+     * PEAR_ERROR_CALLBACK, the callback function or object/method
+     * tuple.
+     *
+     * @param string $userinfo (optional) additional user/debug info
+     *
+     * @access public
+     *
+     */
+    function PEAR_Error($message = 'unknown error', $code = null,
+                        $mode = null, $options = null, $userinfo = null)
+    {
+        if ($mode === null) {
+            $mode = PEAR_ERROR_RETURN;
+        }
+        $this->message   = $message;
+        $this->code      = $code;
+        $this->mode      = $mode;
+        $this->userinfo  = $userinfo;
+        if (function_exists("debug_backtrace")) {
+            if (@!PEAR::getStaticProperty('PEAR_Error', 'skiptrace')) {
+                $this->backtrace = debug_backtrace();
+            }
+        }
+        if ($mode & PEAR_ERROR_CALLBACK) {
+            $this->level = E_USER_NOTICE;
+            $this->callback = $options;
+        } else {
+            if ($options === null) {
+                $options = E_USER_NOTICE;
+            }
+            $this->level = $options;
+            $this->callback = null;
+        }
+        if ($this->mode & PEAR_ERROR_PRINT) {
+            if (is_null($options) || is_int($options)) {
+                $format = "%s";
+            } else {
+                $format = $options;
+            }
+            printf($format, $this->getMessage());
+        }
+        if ($this->mode & PEAR_ERROR_TRIGGER) {
+            trigger_error($this->getMessage(), $this->level);
+        }
+        if ($this->mode & PEAR_ERROR_DIE) {
+            $msg = $this->getMessage();
+            if (is_null($options) || is_int($options)) {
+                $format = "%s";
+                if (substr($msg, -1) != "\n") {
+                    $msg .= "\n";
+                }
+            } else {
+                $format = $options;
+            }
+            die(sprintf($format, $msg));
+        }
+        if ($this->mode & PEAR_ERROR_CALLBACK) {
+            if (is_callable($this->callback)) {
+                call_user_func($this->callback, $this);
+            }
+        }
+        if ($this->mode & PEAR_ERROR_EXCEPTION) {
+            trigger_error("PEAR_ERROR_EXCEPTION is obsolete, use class PEAR_Exception for exceptions", E_USER_WARNING);
+            eval('$e = new Exception($this->message, $this->code);throw($e);');
+        }
+    }
+
+    // }}}
+    // {{{ getMode()
+
+    /**
+     * Get the error mode from an error object.
+     *
+     * @return int error mode
+     * @access public
+     */
+    function getMode() {
+        return $this->mode;
+    }
+
+    // }}}
+    // {{{ getCallback()
+
+    /**
+     * Get the callback function/method from an error object.
+     *
+     * @return mixed callback function or object/method array
+     * @access public
+     */
+    function getCallback() {
+        return $this->callback;
+    }
+
+    // }}}
+    // {{{ getMessage()
+
+
+    /**
+     * Get the error message from an error object.
+     *
+     * @return  string  full error message
+     * @access public
+     */
+    function getMessage()
+    {
+        return ($this->error_message_prefix . $this->message);
+    }
+
+
+    // }}}
+    // {{{ getCode()
+
+    /**
+     * Get error code from an error object
+     *
+     * @return int error code
+     * @access public
+     */
+     function getCode()
+     {
+        return $this->code;
+     }
+
+    // }}}
+    // {{{ getType()
+
+    /**
+     * Get the name of this error/exception.
+     *
+     * @return string error/exception name (type)
+     * @access public
+     */
+    function getType()
+    {
+        return get_class($this);
+    }
+
+    // }}}
+    // {{{ getUserInfo()
+
+    /**
+     * Get additional user-supplied information.
+     *
+     * @return string user-supplied information
+     * @access public
+     */
+    function getUserInfo()
+    {
+        return $this->userinfo;
+    }
+
+    // }}}
+    // {{{ getDebugInfo()
+
+    /**
+     * Get additional debug information supplied by the application.
+     *
+     * @return string debug information
+     * @access public
+     */
+    function getDebugInfo()
+    {
+        return $this->getUserInfo();
+    }
+
+    // }}}
+    // {{{ getBacktrace()
+
+    /**
+     * Get the call backtrace from where the error was generated.
+     * Supported with PHP 4.3.0 or newer.
+     *
+     * @param int $frame (optional) what frame to fetch
+     * @return array Backtrace, or NULL if not available.
+     * @access public
+     */
+    function getBacktrace($frame = null)
+    {
+        if (defined('PEAR_IGNORE_BACKTRACE')) {
+            return null;
+        }
+        if ($frame === null) {
+            return $this->backtrace;
+        }
+        return $this->backtrace[$frame];
+    }
+
+    // }}}
+    // {{{ addUserInfo()
+
+    function addUserInfo($info)
+    {
+        if (empty($this->userinfo)) {
+            $this->userinfo = $info;
+        } else {
+            $this->userinfo .= " ** $info";
+        }
+    }
+
+    // }}}
+    // {{{ toString()
+
+    /**
+     * Make a string representation of this object.
+     *
+     * @return string a string with an object summary
+     * @access public
+     */
+    function toString() {
+        $modes = array();
+        $levels = array(E_USER_NOTICE  => 'notice',
+                        E_USER_WARNING => 'warning',
+                        E_USER_ERROR   => 'error');
+        if ($this->mode & PEAR_ERROR_CALLBACK) {
+            if (is_array($this->callback)) {
+                $callback = (is_object($this->callback[0]) ?
+                    strtolower(get_class($this->callback[0])) :
+                    $this->callback[0]) . '::' .
+                    $this->callback[1];
+            } else {
+                $callback = $this->callback;
+            }
+            return sprintf('[%s: message="%s" code=%d mode=callback '.
+                           'callback=%s prefix="%s" info="%s"]',
+                           strtolower(get_class($this)), $this->message, $this->code,
+                           $callback, $this->error_message_prefix,
+                           $this->userinfo);
+        }
+        if ($this->mode & PEAR_ERROR_PRINT) {
+            $modes[] = 'print';
+        }
+        if ($this->mode & PEAR_ERROR_TRIGGER) {
+            $modes[] = 'trigger';
+        }
+        if ($this->mode & PEAR_ERROR_DIE) {
+            $modes[] = 'die';
+        }
+        if ($this->mode & PEAR_ERROR_RETURN) {
+            $modes[] = 'return';
+        }
+        return sprintf('[%s: message="%s" code=%d mode=%s level=%s '.
+                       'prefix="%s" info="%s"]',
+                       strtolower(get_class($this)), $this->message, $this->code,
+                       implode("|", $modes), $levels[$this->level],
+                       $this->error_message_prefix,
+                       $this->userinfo);
+    }
+
+    // }}}
+}
+
+/*
+ * Local Variables:
+ * mode: php
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ */
+?>
diff --git a/admin/schema.php b/admin/schema.php
index da0eb70..b83263d 100644
--- a/admin/schema.php
+++ b/admin/schema.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: schema.php,v 1.8.10.1 2006-02-19 13:42:24 thraxisp Exp $
+	# $Id: schema.php,v 1.8.10.1 2006/02/19 13:42:24 thraxisp Exp $
 	# --------------------------------------------------------
 
 	# Each entry below defines the schema. The upgrade array consists of
@@ -192,7 +192,10 @@ $upgrade[] = Array('CreateTableSQL',Array(config_get('mantis_news_table'),"
 $upgrade[] = Array('CreateTableSQL',Array(config_get('mantis_project_category_table'),"
   project_id 		 I  UNSIGNED NOTNULL PRIMARY DEFAULT '0',
   category 		C(64) NOTNULL PRIMARY DEFAULT \" '' \",
-  user_id 		 I  UNSIGNED NOTNULL DEFAULT '0'
+  user_id 		 I  UNSIGNED NOTNULL DEFAULT '0',
+  pop3_host		C(250) NULL,
+  pop3_user		C(250) NULL,
+  pop3_pass		C(250) NULL
 ",Array('mysql' => 'TYPE=MyISAM', 'pgsql' => 'WITHOUT OIDS')));
 
 $upgrade[] = Array('CreateTableSQL',Array(config_get('mantis_project_file_table'),"
@@ -222,7 +225,11 @@ $upgrade[] = Array('CreateTableSQL',Array(config_get('mantis_project_table'),"
   view_state 		I2 NOTNULL DEFAULT '10',
   access_min 		I2 NOTNULL DEFAULT '10',
   file_path 		C(250) NOTNULL DEFAULT \" '' \",
-  description 		XS NOTNULL
+  description 		XS NOTNULL,
+  pop3_host		C(250) NULL,
+  pop3_user		C(250) NULL,
+  pop3_pass		C(250) NULL,
+  pop3_categories	L NOTNULL DEFAULT '0'
 ",Array('mysql' => 'TYPE=MyISAM', 'pgsql' => 'WITHOUT OIDS')));
 $upgrade[] = Array('CreateIndexSQL',Array('idx_project_id',config_get('mantis_project_table'),'id'));
 $upgrade[] = Array('CreateIndexSQL',Array('idx_project_name',config_get('mantis_project_table'),'name',Array('UNIQUE')));
@@ -341,4 +348,8 @@ $upgrade[] = Array('InsertData', Array( config_get('mantis_user_table'),
     "(username, realname, email, password, date_created, last_visit, enabled, protected, access_level, login_count, lost_password_request_count, failed_login_count, cookie_string) VALUES
         ('administrator', '', 'root@localhost', '63a9f0ea7bb98050796b649e85481845', " . db_now() . ", " . db_now() . ", 1, 0, 90, 3, 0, 0, '" .
              md5( mt_rand( 0, mt_getrandmax() ) + mt_rand( 0, mt_getrandmax() ) ) . md5( time() ) . "')" ) );
+$upgrade[] = Array('InsertData', Array( config_get('mantis_user_table'), 
+    "(username, realname, email, password, date_created, last_visit, enabled, protected, access_level, login_count, lost_password_request_count, failed_login_count, cookie_string) VALUES 
+        ('mail', 'Mail Reporter', 'nomail@localhost', 'a268462c3c679a9027658c5aa723f97c', " . db_now() . ", " . db_now() . ", 1, 0, 25, 0, 0, 0, '" . 
+             md5( mt_rand( 0, mt_getrandmax() ) + mt_rand( 0, mt_getrandmax() ) ) . md5( time() ) . "')" ) );
 ?>
diff --git a/bug_report_mail.php b/bug_report_mail.php
new file mode 100644
index 0000000..81f708d
--- /dev/null
+++ b/bug_report_mail.php
@@ -0,0 +1,31 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	# This page receives an E-Mail via POP3 and generates an Report
+	header("Content-type: text/plain");
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'string_api.php' );
+	require_once( $t_core_path . 'bug_api.php' );
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$t_mailaccounts = mail_get_accounts();
+
+	foreach ($t_mailaccounts as $t_mailaccount) {
+		if ( config_get( 'mail_debug' ) ) {
+			print_r($t_mailaccount);
+		}
+		mail_process_all_mails( $t_mailaccount );
+	}
+?>
+
diff --git a/config_defaults_inc.php b/config_defaults_inc.php
index e745498..a03674c 100644
--- a/config_defaults_inc.php
+++ b/config_defaults_inc.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: config_defaults_inc.php,v 1.283.2.1.2.1.2.1.2.2.2.7 2006-07-24 01:43:05 thraxisp Exp $
+	# $Id: config_defaults_inc.php,v 1.283.2.1.2.1.2.1.2.2.2.7 2006/07/24 01:43:05 thraxisp Exp $
 	# --------------------------------------------------------
 
 
@@ -1617,4 +1617,84 @@
 	#   )
 	# );
 	$g_custom_group_actions = array();
+
+	######################
+	# Mail Reporting
+	######################
+
+	# --- mail reporting settings -----
+	# This tells Mantis to report all the Mail with only one account
+	$g_mail_use_reporter	= ON;
+
+	# The account's name for mail reporting
+	# Also used for fallback if a user is not found in database
+	$g_mail_reporter	= 'Mail';
+
+	# Signup new users automatically (possible security risk!)
+	# Default is OFF, ignored if mail_use_reporter is ON
+	$g_mail_auto_signup	= OFF;
+
+	# How many mails should be fetched at the same time
+	# If big mails with attachments should be received, specify only one
+	$g_mail_fetch_max	= 1;
+
+	# Write complete mail into the "Additional Information"
+	$g_mail_additional	= OFF;
+
+	# Write sender of the message into the bug report
+	$g_mail_save_from	= OFF;
+
+	# Parse MIME mails (may require a lot of memory)
+	$g_mail_parse_mime	= OFF;
+
+	# Parse HTML mails
+	$g_mail_parse_html	= OFF;
+
+	# HTML Parser Command
+	# It should print the formatted text to STDOUT
+	# For example: "/usr/bin/w3m -T text/html -dump"
+	$g_mail_html_parser	= OFF;
+
+	# directory for saving temporary mail content
+	$g_mail_tmp_directory	= '/tmp';
+	
+	# Delete incoming mail from POP3 server
+	$g_mail_delete		= ON;
+
+	# Signup new users automatically (possible security risk!)
+	# Default is OFF, ignored if mail_use_reporter is ON
+	$g_mail_debug		= OFF;
+	
+	# Save mail contents to this directory if debug mode is ON
+	$g_mail_directory	= '/tmp/mantis';
+	
+	# The auth method used for POP3
+	# Valid methods are: 'DIGEST-MD5','CRAM-MD5','LOGIN','PLAIN','APOP','USER'
+	$g_mail_auth_method	= 'USER';
+	
+	# Looks for priority header field
+	$g_mail_use_bug_priority = ON;
+	
+	# Default priority for mail reported bugs
+	$g_mail_bug_priority_default = NORMAL;
+	
+	# Classify bug priorities
+	$g_mail_bug_priority = array(
+		'5 (lowest)'	=> 10,
+		'4 (low)'	=> 20,
+		'3 (normal)'	=> 30,
+		'2 (high)'	=> 40,
+		'1 (highest)'	=> 50,
+		'5'		=> 20,
+		'4'		=> 20,
+		'3'		=> 30,
+		'2'		=> 40,
+		'1'		=> 50,
+		'0'		=> 10,
+		'low'		=> 20,
+		'normal' 	=> 30,
+		'high' 		=> 40,
+		'' 		=> 30,
+		'?' 		=> 30
+	);
 ?>
diff --git a/core/category_api.php b/core/category_api.php
index 1114f27..49e85e6 100644
--- a/core/category_api.php
+++ b/core/category_api.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: category_api.php,v 1.14 2005-02-12 20:01:10 jlatour Exp $
+	# $Id: category_api.php,v 1.14 2005/02/12 20:01:10 jlatour Exp $
 	# --------------------------------------------------------
 
 	### Category API ###
@@ -186,7 +186,7 @@
 
 		$t_project_category_table = config_get( 'mantis_project_category_table' );
 
-		$query = "SELECT category, user_id
+		$query = "SELECT category, user_id, pop3_host, pop3_user, pop3_pass
 				FROM $t_project_category_table
 				WHERE project_id='$c_project_id' AND
 					category='$c_category'";
@@ -206,7 +206,7 @@
 
 		$t_project_category_table = config_get( 'mantis_project_category_table' );
 
-		$query = "SELECT category, user_id
+		$query = "SELECT category, user_id, pop3_host, pop3_user, pop3_pass
 				FROM $t_project_category_table
 				WHERE project_id='$c_project_id'
 				ORDER BY category";
diff --git a/core/file_api.php b/core/file_api.php
index f43d925..8113543 100644
--- a/core/file_api.php
+++ b/core/file_api.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: file_api.php,v 1.72 2005-08-11 01:53:02 thraxisp Exp $
+	# $Id: file_api.php,v 1.72 2005/08/11 01:53:02 thraxisp Exp $
 	# --------------------------------------------------------
 
 	$t_core_dir = dirname( __FILE__ ).DIRECTORY_SEPARATOR;
@@ -572,8 +572,8 @@
 						file_ftp_disconnect ( $conn_id );
 					}
 
-					if ( !move_uploaded_file( $p_tmp_file, $t_disk_file_name ) ) {
-					    trigger_error( FILE_MOVE_FAILED, ERROR );
+					if ( !rename( $p_tmp_file, $t_disk_file_name ) ) {
+					    trigger_error( ERROR_FILE_MOVE_FAILED, ERROR );
 					}
 					chmod( $t_disk_file_name, 0400 );
 
diff --git a/core/mail_api.php b/core/mail_api.php
new file mode 100644
index 0000000..c475912
--- /dev/null
+++ b/core/mail_api.php
@@ -0,0 +1,468 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	$t_core_dir = dirname( __FILE__ ).DIRECTORY_SEPARATOR;
+
+	require_once( $t_core_dir . 'bug_api.php' );
+	require_once( $t_core_dir . 'bugnote_api.php' );
+	require_once( $t_core_dir . 'user_api.php' );
+	require_once( $t_core_dir . 'project_api.php' );
+	require_once( $t_core_dir . 'file_api.php' );
+
+	# This page receives an E-Mail via POP3 and generates an Report
+
+	require_once( 'Net/POP3.php' );
+	require_once( 'Mail/Parser.php' );
+
+	# --------------------
+	# Return mail account data for the specified project
+	function mail_get_account_data( $p_project_id ) {
+		$v_project_id = db_prepare_int( $p_project_id );
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "SELECT pop3_host, pop3_user, pop3_pass, pop3_categories
+				FROM $t_project_table 
+				WHERE id='$v_project_id'";
+
+		$result = db_query( $query );
+
+		return db_fetch_array( $result );
+	}
+
+	# --------------------
+	# Update the mail account data for a project
+	function mail_update( $p_project_id, $p_pop3_host, $p_pop3_user, $p_pop3_pass ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_pop3_host	= db_prepare_string( $p_pop3_host );
+		$v_pop3_user	= db_prepare_string( $p_pop3_user );
+		$v_pop3_pass	= db_prepare_string( $p_pop3_pass );
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "UPDATE $t_project_table 
+			 	SET pop3_host='$v_pop3_host',
+				pop3_user='$v_pop3_user',
+				pop3_pass='$v_pop3_pass'
+				WHERE id='$v_project_id'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Removes the mail account data from a project
+	function mail_delete( $p_project_id ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "UPDATE $t_project_table 
+				SET pop3_host=NULL,
+				pop3_user=NULL,
+				pop3_pass=NULL
+				WHERE id='$v_project_id'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Activate the 'Mail per Category' feature for a project
+	function mail_categories( $p_project_id, $p_active ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+
+		if ($p_active == 'On') {
+			$v_active = 1;
+		} else {
+			$v_active = 0;
+		}
+
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$query = "UPDATE $t_project_table 
+				SET pop3_categories='$v_active'
+				WHERE id='$v_project_id'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Return mail account data for the specified project and category
+	function mail_category_get_account_data( $p_project_id, $p_category ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_category	= db_prepare_string( $p_category );
+
+		$t_project_category_table = config_get( 'mantis_project_category_table' );
+
+		$query = "SELECT pop3_host, pop3_user, pop3_pass
+				FROM $t_project_category_table 
+				WHERE project_id='$v_project_id' AND category='$v_category'";
+
+		$result = db_query( $query );
+
+		return db_fetch_array( $result );
+	}
+
+	# --------------------
+	# Update the mail account data for a category
+	function mail_category_update( $p_project_id, $p_category, $p_pop3_host, $p_pop3_user, $p_pop3_pass ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_category	= db_prepare_string( $p_category );
+		$v_pop3_host	= db_prepare_string( $p_pop3_host );
+		$v_pop3_user	= db_prepare_string( $p_pop3_user );
+		$v_pop3_pass	= db_prepare_string( $p_pop3_pass );
+
+		$t_project_category_table = config_get( 'mantis_project_category_table' );
+
+		$query = "UPDATE $t_project_category_table 
+			 	SET pop3_host='$v_pop3_host',
+				pop3_user='$v_pop3_user',
+				pop3_pass='$v_pop3_pass'
+				WHERE project_id='$v_project_id' AND category='$v_category'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# Removes the mail account data for a category
+	function mail_category_delete( $p_project_id, $p_category ) {
+		$v_project_id	= db_prepare_int( $p_project_id );
+		$v_category	= db_prepare_string( $p_category );
+		
+		$t_project_table = config_get( 'mantis_project_table' );
+
+		$t_project_category_table = config_get( 'mantis_project_category_table' );
+
+		$query = "UPDATE $t_project_category_table 
+			 	SET pop3_host=NULL,
+				pop3_user=NULL,
+				pop3_pass=NULL
+				WHERE project_id='$v_project_id' AND category='$v_category'";
+
+		db_query( $query );
+
+		return true;
+	}
+
+	# --------------------
+	# return all mailaccounts
+	#  return an empty array if there are no
+	function mail_get_accounts() {
+		$v_accounts = array();
+		$t_projects = mail_project_get_all_rows();
+
+		foreach ($t_projects as $t_project) {
+			if ($t_project['pop3_categories']) {
+				$v_categories = mail_categories_get_all_rows( $t_project['id'] );
+				$v_accounts = array_merge($v_accounts, $v_categories);
+			} else {
+				array_push($v_accounts, $t_project);
+			}
+		}
+
+		return $v_accounts;
+	}
+
+	# --------------------
+	# return all projects with valid data for mail access
+	#  return an empty array if there are no such projects
+	function mail_project_get_all_rows() {
+		$v_projects = array();
+		$t_projects = project_get_all_rows();
+
+		foreach ($t_projects as $t_project) {
+			if ($t_project['pop3_host'] || $t_project['pop3_categories']) {
+				array_push($v_projects, $t_project);
+			}
+		}
+
+		return $v_projects;
+	}
+
+	# --------------------
+	# return all categories from a project with valid data for mail access
+	#  return an empty array if there are no such categories
+	function mail_categories_get_all_rows( $p_project_id ) {
+		$v_categories = array();
+		$t_categories = category_get_all_rows( $p_project_id );
+
+		foreach ($t_categories as $t_category) {
+			if ($t_category['pop3_host']) {
+				$t_category['id'] = $p_project_id;
+				array_push($v_categories, $t_category);
+			}
+		}
+
+		return $v_categories;
+	}
+
+	# --------------------
+	# return all mails for an account
+	#  return an empty array if there are no new mails
+	function mail_process_all_mails( &$p_account ) {
+		$t_mail_fetch_max	= config_get( 'mail_fetch_max' );
+		$t_mail_delete		= config_get( 'mail_delete' );
+		$t_mail_auth_method	= config_get( 'mail_auth_method' );
+
+
+		$t_pop3 = &new Net_POP3();
+		$t_pop3_host = $p_account['pop3_host'];
+		$t_pop3_user = $p_account['pop3_user'];
+		$t_pop3_password = $p_account['pop3_pass'];
+		$t_pop3->connect($t_pop3_host, 110);
+		$t_result = $t_pop3->login($t_pop3_user, $t_pop3_password, $t_mail_auth_method);
+
+		if (PEAR::isError($t_result)) {
+		    echo "\n\nerror:".$p_account['pop3_user']."\n";
+		    echo $t_result->toString();
+		}
+
+		if ( 0 == $t_pop3->numMsg() ) {
+			return;
+		}
+
+		
+		for ($j = 1; $j <= $t_pop3->numMsg(); $j++ )
+		{
+			for ($i = $j; $i < $j+$t_mail_fetch_max; $i++) {
+				$t_msg = $t_pop3->getMsg($i);
+
+				$t_mail = mail_parse_content( $t_msg );
+
+
+				if ( $t_mail_debug ) {
+					print_r($t_mail);
+				}
+
+				mail_save_message_to_file( $t_msg );
+				mail_add_bug( $t_mail, $p_account );
+
+				if ( $t_mail_delete ) {
+					$t_pop3->deleteMsg($i);
+				}
+			}
+		}
+
+		$t_pop3->disconnect();
+	}
+
+	# --------------------
+	# return the mail parsed for Mantis
+	function mail_parse_content ( &$p_mail ) {
+		$t_mail_debug		= config_get( 'mail_debug' );
+		$t_mail_parse_mime	= config_get( 'mail_parse_mime' );
+		$t_mail_parse_html	= config_get( 'mail_parse_html' );
+		$t_mail_html_parser	= config_get( 'mail_html_parser' );
+		$t_mail_tmp_directory	= config_get( 'mail_tmp_directory' );
+		$t_mail_use_bug_priority = config_get( 'mail_use_bug_priority' );
+		$t_mail_bug_priority_default = config_get( 'mail_bug_priority_default' );
+		$t_mail_bug_priority	= config_get( 'mail_bug_priority' );
+		$t_mail_additional	= config_get( 'mail_additional' );
+
+		$t_options = array();
+		$t_options['parse_mime'] = $t_mail_parse_mime;
+		$t_options['parse_html'] = $t_mail_parse_html;
+		$t_options['htmlparser'] = $t_mail_html_parser;
+		$t_options['htmltmpdir'] = $t_mail_tmp_directory;
+
+		$t_mp = new Mail_Parser( $t_options );
+		$t_mp->setInputString( $p_mail );
+		$t_mp->parse();
+
+		$t_mail = array();
+		$t_mail['From'] = $t_mp->from();
+
+		$t_mail['Subject'] = $t_mp->subject();
+                if ( 0 == strlen( $t_mail['Subject'] ) ) {
+		    $t_mail['Subject'] = "No subject found";
+		}
+
+		$t_mail['X-Mantis-Body'] = $t_mp->body();
+                if ( 0 == strlen( $t_mail['X-Mantis-Body'] ) ) {
+		    $t_mail['X-Mantis-Body'] = "No description found";
+		}
+
+                $t_mail['X-Mantis-Parts'] = $t_mp->parts();
+
+		if ( true == $t_mail_use_bug_priority ) {
+			$t_priority =  strtolower($t_mp->priority());
+			$t_mail['Priority'] = $t_mail_bug_priority[$t_priority];
+		} else {
+			$t_mail['Priority'] = gpc_get_int( 'priority', $t_mail_bug_priority_default );
+		}
+		if ( true == $t_mail_additional ) {
+			$t_mail['X-Mantis-Complete'] = $t_msg;
+		}
+
+		return $t_mail;
+	}
+
+	# --------------------
+	# return the mailadress from the mail's 'From'
+	function mail_parse_address ( $p_mailaddress ) {
+		if (preg_match("/<(.*?)>/", $p_mailaddress, $matches)) {
+			$v_mailaddress = $matches[1];
+		}
+
+		return $v_mailaddress;
+	}
+
+	# --------------------
+	# return the a valid username from an email address
+	function mail_user_name_from_address ( $p_mailaddress ) {
+		return strtolower(preg_replace("/[@\.-]/", '_', $p_mailaddress));
+	}
+
+	# --------------------
+	# return true if there is a valid mantis bug referernce in subject
+	function mail_is_a_bugnote ( $p_mail_subject ) {
+		return preg_match("/\[([A-Za-z0-9-_\. ]*\s[0-9]{1,7})\]/", $p_mail_subject);
+	}
+
+	# --------------------
+	# return the bug's id from the subject
+	function mail_get_bug_id_from_subject ( $p_mail_subject ) {
+		preg_match("/\[([A-Za-z0-9-_\. ]*\s([0-9]{1,7}?))\]/", $p_mail_subject, $v_matches);
+
+		return $v_matches[2];
+	}
+	
+	# --------------------
+	# return the user id for the mail reporting user
+	function mail_get_user ($p_mailaddress) {
+		$t_mail_use_reporter	= config_get( 'mail_use_reporter' );
+		$t_mail_auto_signup	= config_get( 'mail_auto_signup' );
+		$t_mail_reporter	= config_get( 'mail_reporter' );
+		
+		$v_mailaddress = mail_parse_address( $p_mailaddress );
+
+		if ( $t_mail_use_reporter ) {
+			// Always report as mail_reporter
+			$t_reporter_id = user_get_id_by_name( $t_mail_reporter );
+			$t_reporter = $t_mail_reporter;
+		} else {
+			// Try to get the reporting users id
+			$t_reporter_id = user_get_id_by_mail ( $v_mailaddress );
+			print_r($t_reporter_id);
+			if ( ! $t_reporter_id && $t_mail_auto_signup ) {
+				// So, we've to sign up a new user...
+				$t_reporter = mail_user_name_from_address ( $v_mailaddress );
+				user_signup ( $t_reporter, $v_mailaddress );
+				$t_reporter_id = user_get_id_by_name ( $t_reporter );
+			} elseif ( ! $t_reporter_id ) {
+				// Fall back to the default mail_reporter
+				$t_reporter_id = user_get_id_by_name( $t_mail_reporter );
+				$t_reporter = $t_mail_reporter;
+			} else {
+				$t_reporter = user_get_field( $t_reporter_id, 'username' );
+			}
+		}
+
+		auth_attempt_script_login($t_reporter);
+
+		return $t_reporter_id;
+	}
+
+	# --------------------
+	# Very dirty: Adds a file to a bug.
+	function mail_add_file( $p_bug_id, $p_part, $number ) {
+		$GLOBALS['_mail_file_'] = $p_part['name'];
+		if ( 0 < strlen($p_part['name']) ) {
+			$t_file_name = '/tmp/'.$p_part['name'];
+			file_put_contents($t_file_name, $p_part['body']);
+			file_add($p_bug_id, $t_file_name,  $number."-".$p_part['name'], $p_part['ctype'], 'bug');
+			unlink($t_file_name);
+		}
+	}
+
+	function mail_save_message_to_file ( &$p_msg ) {
+		$t_mail_debug		= config_get( 'mail_debug' );
+		$t_mail_directory	= config_get( 'mail_directory' );
+		
+		if ( is_dir($t_mail_directory) && is_writeable($t_mail_directory) ) {
+			$t_file_name = $t_mail_directory . '/' . time() . md5($p_msg);
+			file_put_contents($t_file_name, $p_msg);
+		}
+	}
+
+	# --------------------
+	# Adds a bug which is reported via email
+	# Taken from bug_report.php and 
+	function mail_add_bug ( &$p_mail, &$p_account ) {
+		$t_mail_save_from	= config_get( 'mail_save_from' );
+
+		$t_bug_data = new BugData;
+		$t_bug_data->build			= gpc_get_string( 'build', '' );
+		$t_bug_data->platform			= gpc_get_string( 'platform', '' );
+		$t_bug_data->os				= gpc_get_string( 'os', '' );
+		$t_bug_data->os_build			= gpc_get_string( 'os_build', '' );
+		$t_bug_data->version			= gpc_get_string( 'product_version', '' );
+		$t_bug_data->profile_id			= gpc_get_int( 'profile_id', 0 );
+		$t_bug_data->handler_id			= gpc_get_int( 'handler_id', 0 );
+		$t_bug_data->view_state			= gpc_get_int( 'view_state', config_get( 'default_bug_view_status' ) );
+
+		if ( $p_account['category']) {
+			$t_bug_data->category			= gpc_get_string( 'category', $p_account['category'] );
+		} else {
+			$t_bug_data->category			= gpc_get_string( 'category', '' );
+		}
+		$t_bug_data->reproducibility		= 10;
+		$t_bug_data->severity			= 50;
+		$t_bug_data->priority			= $p_mail['Priority'];
+		$t_bug_data->summary			= $p_mail['Subject'];
+		if ( $t_mail_save_from ) {
+			$t_bug_data->description	= "Report from: ".$p_mail['From']."\n\n".$p_mail['X-Mantis-Body'];
+		} else {
+			$t_bug_data->description	= $p_mail['X-Mantis-Body'];
+		}
+		$t_bug_data->steps_to_reproduce		= gpc_get_string( 'steps_to_reproduce', '' );
+		$t_bug_data->additional_information	= $p_mail['X-Mantis-Complete'];
+
+		$t_bug_data->project_id			= $p_account['id'];
+
+		$t_bug_data->reporter_id		= mail_get_user( $p_mail['From'] );
+
+		if ( mail_is_a_bugnote( $p_mail['Subject'] ) ) {
+			# Add a bug note
+			$t_bug_id = mail_get_bug_id_from_subject( $p_mail['Subject'] );
+			if ( ! bug_is_readonly( $t_bug_id ) ) {
+				bugnote_add ( $t_bug_id, $p_mail['X-Mantis-Body'] );
+				email_bugnote_add ( $t_bug_id );
+				if ( bug_get_field( $t_bug_id, 'status' ) > config_get( 'bug_reopen_status' ) )
+				{
+				    bug_reopen( $t_bug_id );
+				}
+			}
+		} else	{
+			# Create the bug
+			$t_bug_id = bug_create( $t_bug_data );
+			email_new_bug( $t_bug_id );
+		}
+		# Add files
+		if ( null != $p_mail['X-Mantis-Parts'] ) {
+			$number = 1;
+			foreach ($p_mail['X-Mantis-Parts'] as $part) {
+				mail_add_file ( $t_bug_id, $part, $number );
+				$number++;
+			}
+		}
+
+	}
+
+?>
+
diff --git a/core/user_api.php b/core/user_api.php
index a9c01fc..adf7265 100644
--- a/core/user_api.php
+++ b/core/user_api.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: user_api.php,v 1.106 2005-07-22 15:34:03 thraxisp Exp $
+	# $Id: user_api.php,v 1.106 2005/07/22 15:34:03 thraxisp Exp $
 	# --------------------------------------------------------
 
 	$t_core_dir = dirname( __FILE__ ).DIRECTORY_SEPARATOR;
@@ -526,6 +526,24 @@
 		}
 	}
 
+	# get a user id from an mail address
+	#  return false if the mail address does not exist
+	function user_get_id_by_mail( $p_mailaddress ) {
+		$c_mailaddress = db_prepare_string( $p_mailaddress );
+		$t_user_table = config_get( 'mantis_user_table' );
+
+		$query = "SELECT id
+				  FROM $t_user_table
+				  WHERE email='$c_mailaddress'";
+		$result = db_query( $query );
+
+		if ( 0 == db_num_rows( $result ) ) {
+			return false;
+		} else {
+			return db_result( $result );
+		}
+	}
+
 	# --------------------
 	# return all data associated with a particular user name
 	#  return false if the username does not exist
diff --git a/doc/README.bug_report_mail b/doc/README.bug_report_mail
new file mode 100644
index 0000000..d088911
--- /dev/null
+++ b/doc/README.bug_report_mail
@@ -0,0 +1,176 @@
+The current version of bug_report_mail support plain text and MIME
+encoded e-mails via POP3 Mailaccounts with PEAR's Net_POP3 package.
+
+bug_report_mail is able to recognize if mail is a reply to an already opened
+bug and adds the content as a bugnote.
+
+If you are alway running Mantis you have to alter your projects table
+with the sql/bug_report_mail.sql script.
+If not, you can create the database tables in the way described in
+the doc/INSTALL file.
+
+This patch changes the following files:
+    core/category_api.php
+    core/file_api.php
+    core/user_api.php
+    admin/schema.php
+    config_defaults_inc.php
+    manage_proj_cat_edit_page.php
+    manage_proj_edit_page.php
+These files are new:
+    Mail/mime.php
+    Mail/mimeDecode.php
+    Mail/mimePart.php
+    Mail/Parser.php
+    Net/POP3.php
+    Net/Socket.php
+    core/mail_api.php
+    doc/README.bug_report_mail
+    doc/bug_report_mail.sql
+    PEAR.php
+    bug_report_mail.php
+    manage_proj_cat_mail_delete.php
+    manage_proj_cat_mail_update.php
+    manage_proj_mail_categories.php
+    manage_proj_mail_delete.php
+    manage_proj_mail_update.php
+
+After installing this patch, you can add a POP3 server's hostname
+and authentication data for each of your projects with the project edit form.
+
+There are two ways to receive mail with bug_report_mail:
+The secure (and default) way is to use a standard reporting user:
+You have to create a reporter account, for example 'Mail'.
+The name for this reporter account you have to write in your config_inc.php file:
+	$g_mail_reporter = "Mail";
+and then, bug_report_mail must be informed to behave like this:
+	$g_mail_use_reporter = ON;
+
+The other way is to signup new user accounts automatically.
+For using this, you have to change this
+	$g_mail_auto_signup     = OFF;
+from OFF to ON.
+Now, bug_report_mail will look for an user named like the mail's sender
+or an user which mail adress is identical.
+If no user is found, then a new account will be created.
+The new user's name will be the mail address.
+
+This could be used for attacks, but there is no other way in the moment.
+
+If you like to parse MIME encoded mails, you have to install the PEAR
+Mail_Mime package and set
+	$g_mail_parse_mime	= OFF;
+from OFF to ON.
+
+For parsing HTML mails, set 
+	$g_mail_parse_html	= ON;
+and set 
+	$g_mail_html_parser
+to a valid tool for dumping HTML contents ("/usr/bin/w3m -T text/html -dump")
+Also, 
+	$g_mail_tmp_directory
+has to be a valid directory to handle write the temporary HTML files.
+
+For debugging controls there is the switch
+	$g_mail_additional	= OFF;
+which puts the complete message into the Additional Information field,
+if it is activated.
+
+If you like to see what bug_report_mail.php is doing, set
+	$g_mail_debug = ON;
+
+If $g_mail_directory is a valid directory and also writeable,
+the complete mails will be saved to this directory.
+
+In this case you should decrease the amount of fetched messages via
+	$g_mail_fetch_max	= 1;
+because the mime decoding needs a lot of memory.
+
+If you'd like to use the Mail Reporter but don't save the whole message for
+making the sender's address available, set
+	$g_mail_save_from	= OFF;
+to ON.
+
+If you don't want bug_report_mail.php to delete the mails from your POP3
+server set
+	$g_mail_delete = OFF;
+Use this carefully!
+
+With 
+	$g_mail_auth_method
+you may set the AUTH method for your POP3 server. Default is 'USER',
+but 'DIGEST-MD5','CRAM-MD5','LOGIN','PLAIN','APOP' are also possible
+
+For using the priority of the mails for the bug priority, set
+	$g_mail_use_bug_priority = ON;
+The
+	$g_mail_bug_priority_default = NORMAL;
+is the default value for the priority of new bug entries.
+
+After this, bug_report_mail can be used via cron like this:
+
+*/5 *   *   *   * lynx --dump http://mantis.homepage.com/bug_report_mail.php
+or via command line interface
+*/5 *   *   *   * /usr/local/bin/php /path/to/mantis/bug_report_mail.php
+
+This line fetch bug reports from via POP3 every 5 minutes. 
+
+This addon is distributed under the same conditions as Mantis itself.
+
+Gerrit Beine, August 2004
+
+Changelog:
+Aug 2006
+	- update to Mantis 1.0.5
+	- mail parsing completely rewritten
+	- include additional patches submitted by
+		- cas (handling of attachments and empty fields)
+		  mail_add_file in core/mail.api
+		  mail_add_bug in core/mail.api
+May 2006
+	- update to Mantis 1.0.3
+	- added support for HTML mail
+	- added support for encoded mail bodies and subjects
+	- changed handling of mail
+	- the global mail_debug configuration option is now set OFF by default
+	- include the additional patches submitted by
+		- EBY (support for priorities and file uploads)
+		  file_add in core/file_api.php
+		  mail_parse_content in core/mail_api.php
+		  config_defaults_inc.php
+Dec 2005
+	- update to Mantis 1.0.0rc4
+	- update to Mantis 0.19.4
+Oct 2005
+	- update to Mantis 1.0.0rc3
+	- update to Mantis 0.19.3
+Sep 2005:
+	- update to Mantis 1.0.0rc2
+	- fixed a bug in getting all categories for a project
+		category_get_all_rows in core/category_api.php
+Aug 2005:
+	- update to Mantis 1.0.0rc1
+	- include the additional patches submitted by      
+		- gernot (Fixed MIME handling and save the mail's sender)
+		  mail_get_all_mails in core/mail_api.php
+		  mail_parse_content in core/mail_api.php
+		  mail_add_bug in core/mail_api.php
+		- stevenc (Fixed MIME handling)
+		  mail_parse_content in core/mail_api.php
+		- rainman (Fixed empty files bug and regex for finding a bug id)
+		  mail_add_file in core/mail_api.php
+		  mail_get_bug_id_from_subject in core/mail_api.php
+Dec 2004:
+	- update to Mantis 0.19.2
+	- add config: g_mail_parse_mime
+	- add config: g_mail_additional
+	- add config: g_mail_fetch_max
+	- make it working via CLI
+Nov 2004:
+	- update to Mantis 0.19.1
+	- add support for MIME decoding
+Sep 2004:
+	- update to Mantis 0.19.0
+Aug 2004:
+	- create patch for Mantis 0.18.3
+
diff --git a/doc/bug_report_mail.sql b/doc/bug_report_mail.sql
new file mode 100644
index 0000000..5724ae1
--- /dev/null
+++ b/doc/bug_report_mail.sql
@@ -0,0 +1,12 @@
+ALTER TABLE `mantis_project_table`
+ADD `pop3_host` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_user` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_pass` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_categories` ENUM( '0', '1' ) DEFAULT '0' NOT NULL ;
+
+ALTER TABLE `mantis_project_category_table`
+ADD `pop3_host` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_user` VARCHAR( 255 ) DEFAULT NULL ,
+ADD `pop3_pass` VARCHAR( 255 ) DEFAULT NULL ;
+
+INSERT INTO mantis_user_table (username, realname, email, password, date_created, last_visit, enabled, protected, access_level, login_count, lost_password_request_count, failed_login_count, cookie_string) VALUES ('Mail', 'Mail Reporter', 'nomail', 'a268462c3c679a9027658c5aa723f97c', '2004-12-25 15:41:49', '2004-12-25 15:41:49', 1, 0, 25, 0, 0, 0, CONCAT(MD5(RAND()),MD5(NOW())));
diff --git a/manage_proj_cat_edit_page.php b/manage_proj_cat_edit_page.php
index 093d6e0..a704eb0 100644
--- a/manage_proj_cat_edit_page.php
+++ b/manage_proj_cat_edit_page.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: manage_proj_cat_edit_page.php,v 1.31 2005-02-12 20:01:06 jlatour Exp $
+	# $Id: manage_proj_cat_edit_page.php,v 1.31 2005/02/12 20:01:06 jlatour Exp $
 	# --------------------------------------------------------
 ?>
 <?php
@@ -15,6 +15,7 @@
 	$t_core_path = config_get( 'core_path' );
 
 	require_once( $t_core_path.'category_api.php' );
+	require_once( $t_core_path.'mail_api.php' );
 ?>
 <?php
 	$f_project_id	= gpc_get_int( 'project_id' );
@@ -24,6 +25,10 @@
 
 	$t_row = category_get_row( $f_project_id, $f_category );
 	$t_assigned_to = $t_row['user_id'];
+	$t_mail = mail_get_account_data( $f_project_id );
+	if ( $t_mail['pop3_categories'] ) {
+		$t_category_mail = mail_category_get_account_data( $f_project_id, $f_category );
+	}
 ?>
 <?php html_page_top1() ?>
 <?php html_page_top2() ?>
@@ -84,4 +89,59 @@
 	</form>
 </div>
 
+<?php  if ( $t_mail['pop3_categories'] ) { ?>
+<!-- MAIL ACCOUNT CHANGE -->
+<br />
+<div align="center">
+	<form method="post" action="manage_proj_cat_mail_update.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="category" value="<?php echo string_attribute( $f_category ) ?>" />
+		<table class="width75" cellspacing="1">
+			<tr>
+				<td class="form-title" colspan="4">
+					<?php echo 'Category Mail Account Settings' ?>
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Host"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_host" size="64" maxlength="255" value="<?php echo string_attribute( $t_category_mail['pop3_host'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 User"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_user" size="64" maxlength="255" value="<?php echo string_attribute( $t_category_mail['pop3_user'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Password"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_pass" size="64" maxlength="255" value="<?php echo string_attribute( $t_category_mail['pop3_pass'] ) ?>" />
+				</td>
+			</tr>
+			<tr>
+			<td colspan="2">
+				<input type="submit" value="<?php echo 'Set Mail Account Data' ?>" />
+				</td>
+			</tr>
+		</table>
+	</form>
+</div>
+<!-- MAIL ACCOUNT RESET -->
+<div class="border-center">
+	<form method="post" action="manage_proj_cat_mail_delete.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="category" value="<?php echo string_attribute( $f_category ) ?>" />
+		<input type="submit" value="<?php echo 'Delete Mail Account Data' ?>" />
+	</form>
+</div>
+<?php } ?>
+ 
 <?php html_page_bottom1( __FILE__ ) ?>
diff --git a/manage_proj_cat_mail_delete.php b/manage_proj_cat_mail_delete.php
new file mode 100644
index 0000000..8bc62cd
--- /dev/null
+++ b/manage_proj_cat_mail_delete.php
@@ -0,0 +1,44 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_category	= gpc_get_string( 'category' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	mail_category_delete( $f_project_id, $f_category );
+
+	$t_redirect_url = 'manage_proj_cat_edit_page.php?project_id=' . $f_project_id . '&category=' . $f_category;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff --git a/manage_proj_cat_mail_update.php b/manage_proj_cat_mail_update.php
new file mode 100644
index 0000000..4220cf3
--- /dev/null
+++ b/manage_proj_cat_mail_update.php
@@ -0,0 +1,59 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_pop3_host	= gpc_get_string( 'pop3_host' );
+	$f_pop3_user	= gpc_get_string( 'pop3_user' );
+	$f_pop3_pass	= gpc_get_string( 'pop3_pass' );
+	$f_category	= gpc_get_string( 'category' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	if ( is_blank( $f_pop3_host ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+	else {
+		if ( is_blank( $f_pop3_user ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+		if ( is_blank( $f_pop3_pass ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+		}
+	}
+
+	mail_category_update( $f_project_id, $f_category, $f_pop3_host, $f_pop3_user, $f_pop3_pass );
+
+	$t_redirect_url = 'manage_proj_cat_edit_page.php?project_id=' . $f_project_id . '&category=' . $f_category;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff --git a/manage_proj_edit_page.php b/manage_proj_edit_page.php
index c37d8d7..c8c9bad 100644
--- a/manage_proj_edit_page.php
+++ b/manage_proj_edit_page.php
@@ -6,7 +6,7 @@
 	# See the README and LICENSE files for details
 
 	# --------------------------------------------------------
-	# $Id: manage_proj_edit_page.php,v 1.92.6.1 2006-01-01 02:58:50 thraxisp Exp $
+	# $Id: manage_proj_edit_page.php,v 1.92.6.1 2006/01/01 02:58:50 thraxisp Exp $
 	# --------------------------------------------------------
 ?>
 <?php
@@ -18,6 +18,7 @@
 	require_once( $t_core_path . 'version_api.php' );
 	require_once( $t_core_path . 'custom_field_api.php' );
 	require_once( $t_core_path . 'icon_api.php' );
+	require_once( $t_core_path . 'mail_api.php' );
 ?>
 <?php
 	$f_project_id = gpc_get_int( 'project_id' );
@@ -25,6 +26,7 @@
 	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
 
 	$row = project_get_row( $f_project_id );
+	$mail = mail_get_account_data( $f_project_id );
 ?>
 <?php html_page_top1() ?>
 <?php html_page_top2() ?>
@@ -690,4 +692,75 @@ if ( access_has_project_level( config_get( 'project_user_threshold' ), $f_projec
 	</table>
 </div>
 
+<?php  if ( ! $mail['pop3_categories'] ) { ?>
+<!-- MAIL ACCOUNT CHANGE -->
+<br />
+<div align="center">
+	<form method="post" action="manage_proj_mail_update.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<table class="width75" cellspacing="1">
+			<tr>
+				<td class="form-title" colspan="4">
+					<?php echo 'Mail Account Settings' ?>
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Host"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_host" size="64" maxlength="255" value="<?php echo string_attribute( $mail['pop3_host'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 User"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_user" size="64" maxlength="255" value="<?php echo string_attribute( $mail['pop3_user'] ) ?>" />
+				</td>
+			</tr>
+			<tr class="row-1">
+				<td class="category" width="25%">
+					<?php echo "POP3 Password"?>
+				</td>
+				<td width="75%">
+					<input type="text" name="pop3_pass" size="64" maxlength="255" value="<?php echo string_attribute( $mail['pop3_pass'] ) ?>" />
+				</td>
+			</tr>
+			<tr>
+				<td colspan="2">
+					<input type="submit" value="<?php echo 'Set Mail Account Data' ?>" />
+				</td>
+			</tr>
+		</table>
+	</form>
+</div>
+<!-- MAIL ACCOUNT RESET -->
+<div class="border-center">
+	<form method="post" action="manage_proj_mail_delete.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="submit" value="<?php echo 'Delete Mail Account Data' ?>" />
+	</form>
+</div>
+<br />
+<!-- MAIL ACCOUNT CATEGORIES -->
+<div class="border-center">
+	<form method="post" action="manage_proj_mail_categories.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="categories" value="On" />
+		<input type="submit" value="<?php echo 'Activate Mail Account per Category' ?>" />
+	</form>
+</div>
+<?php } else { ?>
+<!-- MAIL ACCOUNT CATEGORIES -->
+<div class="border-center">
+	<form method="post" action="manage_proj_mail_categories.php">
+		<input type="hidden" name="project_id" value="<?php echo $f_project_id ?>" />
+		<input type="hidden" name="categories" value="Off" />
+		<input type="submit" value="<?php echo 'Deactivate Mail Account per Category' ?>" />
+	</form>
+</div>
+<?php } ?>
+
 <?php html_page_bottom1( __FILE__ ) ?>
diff --git a/manage_proj_mail_categories.php b/manage_proj_mail_categories.php
new file mode 100644
index 0000000..68e5e02
--- /dev/null
+++ b/manage_proj_mail_categories.php
@@ -0,0 +1,43 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_activate	= gpc_get_string( 'categories' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	mail_categories( $f_project_id, $f_activate );
+
+	$t_redirect_url = 'manage_proj_edit_page.php?project_id=' . $f_project_id;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff --git a/manage_proj_mail_delete.php b/manage_proj_mail_delete.php
new file mode 100644
index 0000000..41bde5f
--- /dev/null
+++ b/manage_proj_mail_delete.php
@@ -0,0 +1,43 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	mail_delete( $f_project_id );
+
+	$t_redirect_url = 'manage_proj_edit_page.php?project_id=' . $f_project_id;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
diff --git a/manage_proj_mail_update.php b/manage_proj_mail_update.php
new file mode 100644
index 0000000..ca0a4c3
--- /dev/null
+++ b/manage_proj_mail_update.php
@@ -0,0 +1,58 @@
+<?php
+	# Mantis - a php based bugtracking system
+	# Copyright (C) 2002 - 2004  Mantis Team   - mantisbt-dev@lists.sourceforge.net
+	# Copyright (C) 2004  Gerrit Beine - gerrit.beine@pitcom.de
+	# This program is distributed under the terms and conditions of the GPL
+	# See the README and LICENSE files for details
+
+	# --------------------------------------------------------
+	# $Id$
+	# --------------------------------------------------------
+
+	require_once( 'core.php' );
+
+	$t_core_path = config_get( 'core_path' );
+
+	require_once( $t_core_path . 'mail_api.php' );
+
+	$f_project_id	= gpc_get_int( 'project_id' );
+	$f_pop3_host	= gpc_get_string( 'pop3_host' );
+	$f_pop3_user	= gpc_get_string( 'pop3_user' );
+	$f_pop3_pass	= gpc_get_string( 'pop3_pass' );
+
+	access_ensure_project_level( config_get( 'manage_project_threshold' ), $f_project_id );
+
+	if ( is_blank( $f_pop3_host ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+	else {
+		if ( is_blank( $f_pop3_user ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+	}
+		if ( is_blank( $f_pop3_pass ) ) {
+			trigger_error( ERROR_EMPTY_FIELD, ERROR );
+		}
+	}
+
+	mail_update( $f_project_id, $f_pop3_host, $f_pop3_user, $f_pop3_pass );
+
+	$t_redirect_url = 'manage_proj_edit_page.php?project_id=' . $f_project_id;
+
+	html_page_top1();
+
+	html_meta_redirect( $t_redirect_url );
+
+	html_page_top2();
+?>
+
+<br />
+<div align="center">
+<?php
+	echo lang_get( 'operation_successful' ) . '<br />';
+
+	print_bracket_link( $t_redirect_url, lang_get( 'proceed' ) );
+?>
+</div>
+
+<?php html_page_bottom1( __FILE__ ) ?>
+
-- 
1.8.3.2

